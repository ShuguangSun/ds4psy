---
title: "Basic R concepts and commands (ds4psy)"
author: "Hansjörg Neth, SPDS, uni.kn"
date: "2018 10 29"
output:
   rmdformats::html_clean: # html_clean html_docco readthedown material #
     code_folding: show # hide
     toc_float: true
     toc_depth: 3
     highlight: default # textmate default kate haddock monochrome #
     lightbox: true # true by default
     fig_width: 8 # in inches
editor_options: 
  chunk_output_type: console # inline
---

<!-- Example of essential commands | ds4psy: Winter 2018/2019 -->

```{r preamble, echo = FALSE, eval = TRUE, cache = FALSE, message = FALSE, warning = FALSE}
## (a) Housekeeping: -----
rm(list=ls()) # clean all.

## (b) Current file name and path: ----- 
# cur.path <- dirname(rstudioapi::getActiveDocumentContext()$path)
# cur.path
# setwd(cur.path) # set to current directory
setwd("~/Desktop/stuff/Dropbox/_code/R/_teachR/ds4psy/_essentials") # set to current directory
# list.files() # all files + folders in current directory
fileName <- "essentials.Rmd"

## (c) Packages: ----- 
library(knitr)
library(rmdformats)
library(tidyverse)

## (d) Global options: ----- 
options(max.print = "75")
opts_chunk$set(echo = TRUE,
               cache = TRUE,
               prompt = FALSE,
               tidy = FALSE,
               collapse = TRUE, # set TRUE in answers 
               comment = "#>",
               message = FALSE,
               warning = FALSE,
               ## Default figure options:
               fig.width = 8, 
               fig.asp = .618, # golden ratio
               out.width = "75%",
               fig.align = "center"
)
opts_knit$set(width = 75)

## (e) Graphics: ----- 

# Defining colors:
seeblau <- rgb(0, 169, 224, names = "seeblau", maxColorValue = 255) # seeblau.4 (non-transparent)

seeblau.colors <- c(rgb(204, 238, 249, maxColorValue = 255), # seeblau.1
                    rgb(166, 225, 244, maxColorValue = 255), # seeblau.2 
                    rgb(89, 199, 235, maxColorValue = 255),  # seeblau.3
                    rgb(0, 169, 224, maxColorValue = 255),   # seeblau.4 
                    rgb(0, 0, 0, maxColorValue = 255),       #  5. black
                    gray(level = 0, alpha = .6),             #  6. gray 60% transparent
                    gray(level = 0, alpha = .4),             #  7. gray 40% transparent
                    gray(level = 0, alpha = .2),             #  8. gray 20% transparent
                    gray(level = 0, alpha = .1),             #  9. gray 10% transparent
                    rgb(255, 255, 255, maxColorValue = 255)  # 10. white
)

unikn.pal = data.frame(                             ## in one df (for the yarrr package): 
  "seeblau1" = rgb(204, 238, 249, maxColorValue = 255), #  1. seeblau1 (non-transparent)
  "seeblau2" = rgb(166, 225, 244, maxColorValue = 255), #  2. seeblau2 (non-transparent)
  "seeblau3" = rgb( 89, 199, 235, maxColorValue = 255), #  3. seeblau3 (non-transparent)
  "seeblau4" = rgb(  0, 169, 224, maxColorValue = 255), #  4. seeblau4 (= seeblau base color)
  "black"    = rgb(  0,   0,   0, maxColorValue = 255), #  5. black
  "seegrau4" = rgb(102, 102, 102, maxColorValue = 255), #  6. grey40 (non-transparent)
  "seegrau3" = rgb(153, 153, 153, maxColorValue = 255), #  7. grey60 (non-transparent)
  "seegrau2" = rgb(204, 204, 204, maxColorValue = 255), #  8. grey80 (non-transparent)
  "seegrau1" = rgb(229, 229, 229, maxColorValue = 255), #  9. grey90 (non-transparent)
  "white"    = rgb(255, 255, 255, maxColorValue = 255), # 10. white
  stringsAsFactors = FALSE)

## (f) Counters: ----- 
nr <- 0  # task number
pt <- 0  # point total
```

```{r utility_add_random_NA_values, echo = FALSE, eval = TRUE}
# Adding a random amount (number or proportion) of NA or other values to a vector:

## Function to replace a random amount of vector elements by NA values:  
add_NAs <- function(vec, amount){
  
  stopifnot((is.vector(vec)) & (amount >= 0) & (amount <= length(vec)))
  
  out <- vec
  n <- length(vec)
  
  amount2 <- ifelse(amount < 1, round(n * amount, 0), amount) # turn amount prop into n
  
  out[sample(x = 1:n, size = amount2, replace = FALSE)] <- NA
  
  return(out)
  
}

## Check:
# add_NAs(1:10, 0)
# add_NAs(1:10, 3)
# add_NAs(1:10, .5)
# add_NAs(letters[1:10], 3)

## Generalization: Replace a random amount of vector elements by what: 
add_whats <- function(vec, amount, what = NA){
  
  stopifnot((is.vector(vec)) & (amount >= 0) & (amount <= length(vec)))
  
  out <- vec
  n <- length(vec)
  
  amount2 <- ifelse(amount < 1, round(n * amount, 0), amount) # turn amount prop into n
  
  out[sample(x = 1:n, size = amount2, replace = FALSE)] <- what
  
  return(out)
  
}

## Check:
# add_whats(1:10, 3) # default: what = NA
# add_whats(1:10, 3, what = 99)
# add_whats(1:10, .5, what = "ABC")
```

# Introduction

This file contains **essential commands** from the chapters of [r4ds](http://r4ds.had.co.nz) and corresponding examples. A command is considered "essential" when you really need to _know_ it and need to know _how to use_ it to succeed in this course. 

<!-- Table with links: -->

All [ds4psy](http://rpository.com/ds4psy/) essentials: 

Nr. | Topic       |
---:|:------------| 
1.  | [Creating and using tibbles](http://rpository.com/ds4psy/R/_essentials/tibble.html) |
2.  | [Data transformation](http://rpository.com/ds4psy/R/_essentials/transform.html) |
3.  | [Visualizing data](http://rpository.com/ds4psy/R/_essentials/visualize.html) | 
4.  | [Exploring data](http://rpository.com/ds4psy/R/_essentials/explore.html) | 
5.  | [Tidy data](http://rpository.com/ds4psy/R/_essentials/tidy.html) | 


## Course coordinates

* Taught at the [University of Konstanz](https://www.uni-konstanz.de/) by [Hansjörg Neth](http://neth.de/) (<h.neth@uni.kn>,  [SPDS](https://www.spds.uni-konstanz.de/), office D507).
* Winter 2018/2019: Mondays, 13:30--15:00, C511. 
* Links to [ZeUS](https://zeus.uni-konstanz.de/hioserver/pages/startFlow.xhtml?_flowId=detailView-flow&unitId=5101&periodId=78&navigationPosition=hisinoneLehrorganisation,examEventOverviewOwn) and [Ilias](https://ilias.uni-konstanz.de/ilias/goto_ilias_uni_crs_809936.html)

## Preparations

Create an R script (`.R`) or an R-Markdown file (`.Rmd`) and load the R packages of the `tidyverse`. (Hint: Structure your script by inserting spaces, meaningful comments, and sections.) 

```{r layout_template, echo = TRUE, eval = FALSE}
## Essential commmands | ds4psy
## 2018 10 28
## ----------------------------

## Preparations: ----------

library(tidyverse)

## Topic: ----------

# ...

## End of file (eof). ----------  
```

# Basic R Concepts and Commands

## Preliminaries 

This session provides some background knowledge and basics facts that are required 
for learning data science (in R or any other programming language).
It assumes the following:

1. **Software:** You have installed the software prerequisites mentioned in 
[Chapter 1.4](https://r4ds.had.co.nz/introduction.html#prerequisites) 
of [r4ds](https://r4ds.had.co.nz/). Specifically,

    1. A current version of [R](https://cloud.r-project.org);   
    2. A current version of [RStudio](http://www.rstudio.com);  
    3. The R packages comprising the [tidyverse](https://www.tidyverse.org).  

2. **Readings:** You have read the following chapters of [r4ds](https://r4ds.had.co.nz/):

    1. _Introductions_: [Chapter 1](https://r4ds.had.co.nz/introduction.html) and [Chapter 2](https://r4ds.had.co.nz/explore-intro.html));  
    2. _Workflow_: [basics (Chapter 4)](https://r4ds.had.co.nz/workflow-basics.html) 
    and [scripts (Chapter 6)](https://r4ds.had.co.nz/workflow-scripts.html).  

This implies that you understand and can do the following:

- Enter and run R commands at the prompt in the _Console_ window of RStudio (and check their results); 
- Use R as a calculator for simple arithmetic; 
- Assign numeric values and characters to named objects; 
- Call simple R functions on objects;  
- Enter and run R scripts in the _Editor_ window of RStudio. 

## Code as data and functions

Using R and most other programming languages consists in 

1. defining or loading _data_ (objects, values), and    

2. evaluating _functions_ (actions, verbs).  

Confusingly, both data and functions in R are _objects_ and evaluating functions 
typically returns or creates new data objects. To distinguish data from functions, think of data as _objects_ (i.e., material or values that are being measured or manipulated) and functions as _procedures_ (i.e., actions, operations, or verbs) that measure or manipulate data.

In the following, we will introduce some ways to describe data (by shape and type), learn to create new data objects, and apply some pre-defined functions on these data objects.

### Data

In R, different data objects are characterized by their shape and by their type. 

1. The most common _shapes_ of data are:

    - _scalars_: atomic objects (with a length of 1);  
    - _vectors_: a chain/sequence of objects of the same type;    
    - _data frames_/_matrices_/_tibbles_: rectangular data (i.e., tables with 2 dimensions: rows vs. columns).  
    
2. The most common _types_ of data are:

    - _numeric_ data (of type `double` or `integer`);  
    - _text_ data (of type `character`);  
    - _logical_ data (of type `logical`).  

### Functions

In R, functions are applied to data objects (so-called _arguments_, e.g., `a1` and `a2`) by 
specifying the function name and providing the arguments in round parentheses (i.e., `function(a1, a2)`). 
An example of a function with 2 arguments is: 

```{r}
sum(1, 2)
```

Here, the function `sum` is applied to 2 numeric arguments `1` and `2`. Evaluating the expression `sum(1, 2)` returns a new data object `3`, which is the sum of the two original arguments.

### Practice

Evaluate the following expressions and describe what they are doing (in terms of applying functions to arguments to obtain new data):

```{r}
min(1, 2, -3, 4)
paste0("ab", "cd")
substr("television", start = 5, stop = 10)
```


### Defining objects

To define a new object `o` as `x`, use the assignment function `o <- x` and note that object names are case-sensitive (i.e., `a` and `A` are different object names). Here are some examples of simple objects and simple arithmetic functions applied to objects:

```{r objects}
o <- 10  # assign/set o to 10
O <- 5   # assign/set O to  5

# Computing with objects: 
o * O
o * 0
o / O * 0
```

In R, objects can be described by their _length_ and _type_. Objects with a length of 1 are called _scalars_, longer objects (i.e., `length(object) > 1`) are either _vectors_ or _lists_. 


### Naming objects

Beware of the following characteristics and constraints: 

- R is case sensitive (so `tea_pot`, `Tea_pot` and `tea_Pot` are different names that denote 3 different objects)   
- No spaces inside variables (even though ``tea pot`` is possible)
- No special keywords that are reserved for R commands (`TRUE`, `FALSE`, `function`, `for`, `in`, `next`, `break`, `if`, `else`, `repeat`, `while`, `NULL`, `Inf`, `NaN`, `NA` and some variants like `NA_character`, `NA_integer`, ...)

Recommendations: 

- Aim for short and consistent names; 
- Avoid dots and special characters in names;  
- Use `snake_case` (with underscores) or `camelCase` (with capitalised first letters) for combined names. 


## Scalars 

### Defining scalars

We have learned that _scalars_ are objects of length 1 (aka. "atomic" objects) and how to define objects by assigning names to them. So let's define some scalar objects and then use basic functions to check their length and type: 

```{r basic_objects}
a <- 1     # assign/set a to 1
a          # print a
a + 2      # evaluate a + 2
sum(a, 2)  # evaluate the function sum() with arguments a and 2

b <- 2
b
b * b
prod(b, b)
b^2

c <- a + b
c
length(c)
typeof(c)

d <- "word" # note the quotes ("")
d
length(d)
typeof(d)

b > a 
e <- b > a
length(e)
typeof(e)
```

Thus, objects `a`, `b` and `c` are _numeric_ objects (of type _integer_ or _double_), whereas `d` is a text object (of type _character_), and `e` is a logical object (either `TRUE` or `FALSE`). 


### Changing objects

To change an existing object, we need to re-assign it. Thus, changing an object works just like creating it: 

```{r reassigning_objects}
a
a <- 100  # changes a
a
a/b

b <- 200  # changes b
b
a/b

d
d <- "weird"  # changes d
d 
```

This implies that the _order_ of evaluations matters: The same object (e.g., `a`) has different contents at different locations and at different times. (Note the line numbers in your editor window to mark locations and that R scripts are typically evaluated in a top-down fashion.) 


### Applying functions to scalars

We have evaluated some simple functions to data arguments, but not all functions can be applied to all data. 
Importantly, most functions require specific types of arguments to work (i.e., the actual argument types need to match the required argument types of the function). 

When starting with objects, the type of an object determines which functions can be applied to it:

```{r function_matching_object_types}
# numeric objects:
a
typeof(a)  # a generic function (working with all object types)
length(a)
a + b      
sum(a, b)  # an arithmetic function (requiring specifc object types)

# character objects:
d
typeof(d)
length(d) 
nchar(d)  # "length" of a character object

# logical objects:
e
typeof(e)
!e          # negation (reverses logical value)
!!e
isTRUE(e)   # tests a logcial expression
isTRUE(!e)
e == !!e    # tests equality
```

In case of a mismatch between function and object types an error occurs:

```{r mismatch_errors, eval = FALSE}
# Evaluate the following (and explain the error):
a + d
sum(a, d)
d^2
```


### Arithmetic functions

For numeric objects, we can compute numeric values by applying arithmetic functions:

```{r arithmetic_functions}
## (A) Arithmetic operators: ---- 
+ 2    # keeping sign
- 3    # reversing sign
1 + 2  # addition
3 - 1  # subtraction
2 * 3  # multiplication
5 / 2  # division

5 %/% 2  # integer division
5 %% 2   # remainder of integer division (x mod y)

## (B) Operator precedence: ---- 
1 / 2 * 3   # left to right
1 + 2 * 3   # precedence: */ before +-
(1 + 2) * 3 # changing order by parentheses
# "BEDMAS" order:  
# - brackets (), 
# - exponents ^, 
# - division / and multiplication *, 
# - addition + and subtraction -
# See 
# ?Syntax
# for complete rules.

2 * 2 * 2
2^3

## (C) Logical comparisons: ---- 
2 > 1   # larger than
2 >= 2  # larger than or equal to
2 < 1   # smaller than
2 <= 1  # smaller than or equal to

1 == 1  # equality
1 != 1  # inequality 

(2 > 1) & (1 > 2)  # logical AND
(2 < 1) | (1 < 2)  # logical OR


## (D) Arithmetic with scalar objects: ---- 
x <- 2
y <- 3

+ x     # keeping sign 
- y     # reversing sign
x + y   # addition
x - y   # subtraction
x * y   # multiplication
x / y   # division
x ^ y   # exponentiation
x %/% y # integer division
x %% y  # remainder of integer division (x mod y)
```

The same arithmetic operators work with numeric _vectors_ (see Exercise 2 below). (See `?Arithmetic` for help on arithmetic operators and `?Syntax` for a full list of precedence groups.) 


## Vectors

_Vectors_ are the most common and most important data type in R. A _vector_ is a sequence of objects of the same type. 

### Creating vectors

To create a new vector, we can _combine_ several objects of the _same type_ with the `c()` function, 
separating vector elements by commas:

```{r creating_vectors}
# Creating vectors: 
c(1, 2, 3)
c(a, b)

v <- c(a, b, c)
v

v <- c(c, c, c)  # vectors can have repeated elements
v

v <- c(a, b, v)     # vectors can contain vectors
v

v <- c(v, v)
v

# Character vectors:
w <- c("one", "two", "three")
w

w <- c(w, "four", "5", "many")
w

# Applying functions to vectors:
length(v)
typeof(v)
sum(v)

length(w)
typeof(w)
# sum(w)  # would yield an error

# Combining different types:
x <- c(1, "two", 3)
x
typeof(x)  # converted 1 to "1" (as all vector elements must be of the same type)
```

### Scalar objects are vectors

Actually, R has no dedicated type of scalar objects. Instead, individual numbers (of type integer or double) or text strings (of type character) are actually vectors of length 1:

```{r scalar_vectors}
a
is.vector(a)
length(a)

d
is.vector(d)
length(d)

e
is.vector(e)
length(e)
```

### Special vector creation functions

For creating vectors with more than just a few elements (i.e., with larger `length` values), the `c` function becomes impractical. Some useful functions and shortcuts are:

```{r}
# Sequences (with sep):
s1 <- seq(0, 100, 1)  # is short for: 
s2 <- seq(from = 0, to = 100, by = 1)
s2
all.equal(s1, s2)

# Shorter version (with by = 1):
s3 <- 0:100
all.equal(s1, s3)

# But seq allows different step sizes:
s4 <- seq(0, 100, by = 25)
s4

# Replicating (with rep):
s5 <- rep(c(0, 1), 3)  # is short for:
s5 <- rep(x = c(0, 1), times = 3)
s5

# Sampling vector elements (with sample):
sample(1:3, 10, replace = TRUE)
# Note:
# sample(1:3, 10, replace = FALSE)  # would yield an error

coin <- c("H", "T")    # 2 events: Heads or Tails
sample(coin, 5, TRUE)  # is short for: 
sample(x = coin, size = 5, replace = TRUE)     # flip coin 5 times
sample(x = coin, size = 1000, replace = TRUE)  # flip coin 1000 times
```

### Indexing vectors

We can select specific objects from vectors by specifying the condition or criterion for selection in brackets `[...]`.

```{r indexing_vectors}
# Example 1: Indexing numeric vectors
x <- 1:10
x

crit <- x > 5  # Condition: Which values of x are larger than 5?
crit

x[crit]   # using crit to select values of x (for which crit is TRUE)
x[x > 5]  # all in 1 step:


## Example 2: Indexing character vectors
spices <- c("salt", "pepper", "cinnamon", "lemongrass", "mint", "mustard", "wasabi")

spices[nchar(spices) == 4]  # spices with exactly 4 letters
spices[substr(spices, 2, 2) == "i"]  # spices with an "i" at 2nd position
```

## Rectangular data

Vectors are 1-dimensional objects (i.e., have a length, but no width). 
By combining several vectors, we get a _rectangular_ data structure. 

### Matrices

When a rectangle of data contains data of the same type in all cells, we get a _matrix_:

```{r rectangular_data}
x <- 1:3
y <- 4:6
z <- 7:9

# Combining vectors (of the same length): ---- 
r1 <- rbind(x, y, z)  # combine as rows
r1

r2 <- cbind(x, y, z)  # combine as columns
r2

# Putting a vector into a rectangular matrix:
r3 <- matrix(data = 1:20, nrow = 5, ncol = 4, byrow = TRUE)
r3

r4 <- matrix(data = 1:20, nrow = 5, ncol = 4, byrow = FALSE)
r4


# Selecting cells, rows, or columns of matrices: ---- 
r1[2, 3]  # in r1: select row 2, column 3
r2[3, 1]  # in r2: select row 3, column 1

r1[2,  ]  # in r1: select row 2, all columns
r2[ , 1]  # in r1: select column 1, all rows

r3
r3[2, 3:4] # in r3: select row 2, columns 3 to 4
r3[3:5, 2] # in r3: select rows 3 to 5, column 2

r4[]  # in r4: select all rows and all columns (i.e., all of r4)


# Applying functions to matrices: ---- 
is.matrix(r1)
typeof(r2)

dim(r1)   # dimensions of r2: 3 rows and 3 columns
nrow(r2)  # number of rows of r2
ncol(r3)  # number of columns of r3

sum(r1)
max(r2)
mean(r3)
colSums(r3)  # column sums of r3
rowSums(r4)  # row sums of r4

r4 > 10  # returns a matrix of logical values
typeof(r4 > 10)
r4[r4 > 10]  # indexing of matrices
```

### Data frames / tibbles

As matrices contain data of only 1 type (e.g., all cells are all numeric, character, or logical data), we need another data structure for more diverse and interesting datasets. 

```{r data_frame}
# Create some vectors (of different types, but same length): 
name <- c("Adam", "Bertha", "Cecily", "Dora", "Eve", "Nero", "Zeno")
gender <- c("male", "female", "female", "female", "female", "male", "male")
age <- c(21, 23, 22, 19, 21, 18, 24)
height <- c(165, 170, 168, 172, 158, 185, 182)

# Combine 4 vectors (of equal length) into a data frame: 
df <- data.frame(name, gender, age, height)
df    # Note: Vectors are the columns of the data frame!

is.matrix(df)
is.data.frame(df)
dim(df)

# Note that 
# sum(df)  # would yield an error

# Selecting cells, rows or columns:
df[2, 3]  # cell in row 2, column 3
df[6, ]   # row 6
df[ , 4]  # column 4

# Selecting columns by name (with $ operator):
df$gender  # returns gender vector
df$age     # returns age vector

# Applying functions to columns of df:
df$gender == "male"
sum(df$gender == "male")

df$age < 21
df$age[df$age < 21]
df$name[df$age < 21]

mean(df$height)
df$height < 170
df$gender[df$height < 170]
```

+++ here now +++

## Exercises

1. Evaluate and explain the following results (and correct any errors that may occur):

```{r ex1, echo = TRUE, eval = FALSE}
a
b
b <- a + a
a + a == b
!!a

sqrt(2)  # see ?sqrt
sqrt(2)^2
sqrt(2)^2 == 2  # Why FALSE? 
# Hint: Compute the difference sqrt(2)^2 - 2

o / O / 0
0 / (o * O)
0 / (o * 0)

a + b + C

sum(a, b) - sum(a + b)

b:a  # divide b by a
length(b:a)

i <- i + 1  # increment i by 1

nchar(d) - length(d)

e
e + e + !!e

e <- stuff
paste(d, e)  # paste "adds" 2 character objects
```

2. Financial arithmetic: Assume that you have won an amount of EUR 1000 and are considering to deposit this into a new bank account that offers an annual interest rate of 0.1%.  How much would your account be worth after 2 years?  What would be the time value of your money in 2 years if the annual inflation is 2%?

Solve this by defining well-named objects and simple arithmetic computations on them.


3. Demonstrate that the above list of arithmetic functions also works with 2 numeric vectors `x` and `y` (of the same length).  
What happens when `x` and `y` have different lengths?

```{r ex3_arithmetic_vectors}
## (a) Arithmetic with vectors of the same length:
x <- c(2, 4, 6)
y <- c(1, 2, 3)

+ x     # keeping sign 
- y     # reversing sign
x + y   # addition
x - y   # subtraction
x * y   # multiplication
x / y   # division
x ^ y   # exponentiation
x %/% y # integer division
x %% y  # remainder of integer division (x mod y)

## (b) Arithmetic with vectors of different length:
x <- c(2, 4, 6)
y <- c(1, 2)

+ x     # keeping sign 
- y     # reversing sign
x + y   # addition
x - y   # subtraction
x * y   # multiplication
x / y   # division
x ^ y   # exponentiation
x %/% y # integer division
x %% y  # remainder of integer division (x mod y)
```


4. Predit the result of the arithmetic expression `x %/% y * y + x %% y`. Then test your prediction by assigning some number to `x` and `y` and evaluating the expression. Finally, explain why the result occurs. 

```{r ex4_integer_arithmetic, echo = TRUE, eval = FALSE}
x <- 4711
y <- 1307

## Prediction: 
x %/% y * y + x %% y  # will evaluate to x.

## Explanation:
((x %/% y) * y) + (x %% y)
x %/% y 
x %/% y * y 
x %% y
```

5. Assume the following definitions for a survey: 

    - A person with an age from 1 to 17 years is classified as a _minor_,  
    - a person with an age from 18 to 64 years is classified as an _adult_, 
    - a person with an age from 65 to 99 years is classified as a _senior_.

Generate a vector that samples the `age` of 100 people, but contains exactly 20 minors, 50 adults, and 30 seniors. 

Now use some functions on `age` to answer the following questions: 

   - What is the average (mean), minimum, and maximum age in this sample? 
   - How many people are younger than 25 years? 
   - What is the average (mean) age of people older than 50 years?
   - How many people have a round age (i.e., an age that is divisible by 10)? What is their mean age? 

```{r ex5}
set.seed(42) # for replicable randomness

minor_range  <-  1:17
adult_range  <- 18:64
senior_range <- 64:99

minors  <- sample(minor_range, 20, replace = TRUE)
adults  <- sample(adult_range, 50, replace = TRUE)
seniors <- sample(senior_range, 30, replace = TRUE)

age <- c(minors, adults, seniors)
age

# Checks:
length(age)
min(age)
max(age)
mean(age)

# How many people are younger than 25 years? 
length(age[age < 25])

# What is the average (mean) age of people older than 50 years?
mean(age[age > 50])

# Round age:
round_ages <- age[age %% 10 == 0]
length(round_ages)
mean(round_ages)
```



## Concepts

- Different types of objects: Code contains data values (objects being measured or manipulated) vs. functions (actions, operators, verbs). 
- Data formats: scalars, vectors, matrices (data frame or tibbles), arrays. 
- Data types: numeric, character, logical. 
- Functions: Descriptions, arithmetic, text, sampling, etc.
- Accessing data formats (vectors, matrices) via names, indices, or subsetting.  

## Technology

- Essentials: R, packages, code (commands vs. scripts). 
- Convencience: IDE like RStudio. 
- Infrastructure: [R-project](https://www.r-project.org), stackoverflow, GitHub, ..., Google. 

## Organization 

- Clean code (spacing, comments, sections, ...) 
- Projects (with scripts, data, and folders)




## More resources

Introductory R books and scripts: 

- [YaRrr! The Pirate’s Guide to R](https://bookdown.org/ndphillips/YaRrr/). 



# Conclusion

<!-- Table with links: -->

All [ds4psy](http://rpository.com/ds4psy/) essentials: 

Nr. | Topic       |
---:|:------------| 
1.  | [Creating and using tibbles](http://rpository.com/ds4psy/R/_essentials/tibble.html) |
2.  | [Data transformation](http://rpository.com/ds4psy/R/_essentials/transform.html) |
3.  | [Visualizing data](http://rpository.com/ds4psy/R/_essentials/visualize.html) | 
4.  | [Exploring data](http://rpository.com/ds4psy/R/_essentials/explore.html) | 
5.  | [Tidy data](http://rpository.com/ds4psy/R/_essentials/tidy.html) |  

[Last update on `r Sys.time()` by [hn](http://neth.de/).]  

<!-- eof. --> 