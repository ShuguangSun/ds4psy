---
title: "Iteration, with WPA10 and solutions (ds4psy)"
author: "Hansjörg Neth, SPDS, uni.kn"
date: "2019 07 06"
output:
   rmdformats::html_clean: # html_clean html_docco readthedown material #
     code_folding: show # hide
     toc_float: true
     toc_depth: 3
     highlight: default # textmate default kate haddock monochrome #
     lightbox: true # true by default
     fig_width: 7 # in inches
editor_options: 
  chunk_output_type: console # inline
---

<!-- Example of essential commands | ds4psy: Winter/Spring 2018/2019 -->

```{r preamble, echo = FALSE, eval = TRUE, cache = FALSE, message = FALSE, warning = FALSE}
## (a) Housekeeping: -----
rm(list=ls()) # clean all.

## (b) Current file name and path: ----- 
# my_path <- dirname(rstudioapi::getActiveDocumentContext()$path)
# my_path
# setwd(my_path) # set to current directory
setwd("~/Desktop/stuff/Dropbox/_code/R/_teachR/ds4psy/_essentials") # set to current directory
# list.files() # all files + folders in current directory
fileName <- "iteration.Rmd"

## (c) Packages: ----- 
library(knitr)
library(rmdformats)
library(tidyverse)
library(unikn)

## (d) Global options: ----- 
options(max.print = "75")
opts_chunk$set(echo = TRUE,
	             cache = TRUE,
               prompt = FALSE,
               tidy = FALSE,
               collapse = TRUE, # set TRUE in answers 
               comment = "#>",
               message = FALSE,
               warning = FALSE,
               ## Default figure options:
               fig.width = 7, 
               fig.asp = .618, # golden ratio
               out.width = "75%",
               fig.align = "center"
               )
opts_knit$set(width = 75)

## (e) Custom functions: ----- 
source(file = "~/Desktop/stuff/Dropbox/_code/R/_teachR/ds4psy/R/custom_functions.R")
```

# Introduction

This file contains **essential commands** from [Chapter 21: Iteration](https://r4ds.had.co.nz/iteration.html) of the textbook [r4ds](http://r4ds.had.co.nz) and corresponding examples and exercises. A command is considered "essential" when you really need to _know_ it and need to know _how to use_ it to succeed in this course. 

<!-- Table with links: -->

All [ds4psy](http://rpository.com/ds4psy/) essentials so far: 

<!-- ds4psy logo 1: -->
<a href="http://rpository.com/ds4psy/">
<img src = "./../images/logo/logo_200_bwg.png" alt = "ds4psy" width = "110px" align = "right" style = "width: 150px; float: right; border:11;"/>
</a>

Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | [Transforming data](http://rpository.com/ds4psy/essentials/transform.html) |
4.  | [Exploring data (EDA)](http://rpository.com/ds4psy/essentials/explore.html) | 
5.  | [Tibbles](http://rpository.com/ds4psy/essentials/tibbles.html) |
6.  | [Importing data](http://rpository.com/ds4psy/essentials/import.html) |
7.  | [Tidying data](http://rpository.com/ds4psy/essentials/tidy.html) |
8.  | [Joining data](http://rpository.com/ds4psy/essentials/join.html) |
9.  | [Functions](http://rpository.com/ds4psy/essentials/function.html) |
10. | **Iteration** [*](http://rpository.com/ds4psy/essentials/iteration.html) |
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 

<!--
Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | [Transforming data](http://rpository.com/ds4psy/essentials/transform.html) |
4.  | [Exploring data (EDA)](http://rpository.com/ds4psy/essentials/explore.html) | 
5.  | [Tibbles](http://rpository.com/ds4psy/essentials/tibbles.html) |
6.  | [Importing data](http://rpository.com/ds4psy/essentials/import.html) |
7.  | [Tidying data](http://rpository.com/ds4psy/essentials/tidy.html) |
8.  | [Joining data](http://rpository.com/ds4psy/essentials/join.html) |
9.  | [Functions](http://rpository.com/ds4psy/essentials/function.html) |
10.  | [Iteration](http://rpository.com/ds4psy/essentials/iteration.html) |
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 
-->

## Course coordinates

<!-- uni.kn logo and link: -->  
<!-- ![](./inst/images/uniKn_logo.png) --> 
<a href="https://www.uni-konstanz.de/">
<img src = "../inst/images/uniKn_logo.png" alt = "uni.kn" align = "right" width = "300" style = "width: 300px; float: right; border:20;"/>
<!-- <img src = "./inst/images/uniKn_logo_s.png" alt = "uni.kn" style = "float: right; border:20;"/> --> 
</a>

* PSY-15150, at the [University of Konstanz](https://www.uni-konstanz.de/) by [Hansjörg Neth](http://neth.de/) (<h.neth@uni.kn>,  [SPDS](https://www.spds.uni-konstanz.de/), office D507).
* Summer 2019: Mondays, 15:15--16:45, D435.  
* Links to current [course syllabus](http://rpository.com/ds4psy/) | [ZeUS](https://zeus.uni-konstanz.de:443/hioserver/pages/startFlow.xhtml?_flowId=detailView-flow&unitId=5101&periodId=179&navigationPosition=hisinoneLehrorganisation,examEventOverviewOwn) |  [Ilias](https://ilias.uni-konstanz.de/ilias/goto_ilias_uni_crs_863036.html) 
* [ds4psy](https://bookdown.org/hneth/ds4psy/>) essentials and WPAs 


## Preparations

Create an R script (`.R`) or an R-Markdown file (`.Rmd`) and load the R packages of the **tidyverse**. (**Hint:** Structure your script by inserting spaces, meaningful comments, and sections.) 

```{r layout_template, echo = TRUE, eval = FALSE}
## Iteration | ds4psy
## 2019 01 31
## ----------------------------

## Preparations: ----------

library(tidyverse)

## 1. Topic: ----------

# etc.

## End of file (eof). ----------  
```

To use [R Markdown](https://rmarkdown.rstudio.com), create a corresponding file and save it with the `.Rmd` extension (e.g., by selecting `File > New File > R Markdown`). 
For instructions on combining text and code, see [Chapter 27: R Markdown](https://r4ds.had.co.nz/r-markdown.html) of our textbook, or use one of the following templates:  

- minimal template:  `rmd_template_s` [in [.Rmd](http://rpository.com/down/temp/rmd_template_s.Rmd) | [.html](http://rpository.com/down/temp/rmd_template_s.html) format]

- medium template: `rmd_template_m` [in [.Rmd](http://rpository.com/down/temp/rmd_template_m.Rmd) | [.html](http://rpository.com/down/temp/rmd_template_m.html) format]

- explicit explanations: `Rmarkdown_basics` [in [.Rmd](http://rpository.com/down/temp/Rmarkdown_basics.Rmd) | [.html](http://rpository.com/down/temp/Rmarkdown_basics.html) format]

**Hint:** Try to _knit_ your `.Rmd` file immediately after saving it and marvel at the beauty of the resulting `.html`-file. If this works, keep doing this routinely from now on, putting all your R-code into code chunks, and any text (like headings or conclusions) that describes or explains what you are doing outside of them. From now on, you can share your `.html` output files, rather than your `.Rmd` source files when showing off your R and data science skills.

# Iteration {#iteration}

Defining _iteration_ := doing things repeatedly. 
The repetition of a procedure or process. 

## Loops

```{r create_data_tb, echo = FALSE, eval = TRUE}
# Create data with numeric columns:
set.seed(100)
N <- 100

id <- 1:N

age <- round(rnorm(N, 25, 8), 0)
age[age < 18] <- (age[age < 18] + 8)

height <- round(rnorm(N, 178, 15), 0)
height[height < 148] <- (height[height < 148] + 4)
height[height > 195] <- (height[height > 195] - 5)

shoesize <- round(rnorm(N, 38, 4), 0)
shoesize[shoesize < 32] <- (shoesize[shoesize < 32] + 2)
shoesize[shoesize < 34] <- (shoesize[shoesize < 34] + 1)
shoesize[shoesize > 42] <- (shoesize[shoesize > 43] - 1)
shoesize[shoesize > 45] <- (shoesize[shoesize > 46] - 2)

# Correlation: shoesize & height: 
shoesize[height < 157] <- (shoesize[height < 157] - 3)
shoesize[height < 164] <- (shoesize[height < 164] - 2)
shoesize[height < 171] <- (shoesize[height < 171] - 1)
shoesize[height > 198] <- (shoesize[height > 198] + 4)
shoesize[height > 192] <- (shoesize[height > 192] + 3)
shoesize[height > 185] <- (shoesize[height > 185] + 2)
shoesize[height > 179] <- (shoesize[height > 179] + 1)

IQ <- round(rnorm(N, 105, 12), 0)
IQ[IQ < 81] <- (IQ[IQ < 81] + 6)
IQ[IQ < 85] <- (IQ[IQ < 85] + 4)
IQ[IQ < 92] <- (IQ[IQ < 92] + 2)

# Tibble:
tb <- tibble(id, age, height, shoesize, IQ)
head(tb)

## Correlation: shoesize ~ height: 
# plot(tb$shoesize ~ tb$height)
# abline(lm(shoesize ~ height, tb), col = "red")

## Correlation: IQ ~ height: 
# plot(tb$IQ ~ tb$height)
# abline(lm(IQ ~ height, tb), col = "green3")

## Write out table:
# write_csv2(tb, path = "../data/tb.csv")

## Read in table again:
# read_csv2("../data/tb.csv")
```

### Using a `for` loop

Asking and answering 3 questions:

1. _body_: What is the task performed in the loop?

2. _sequence_: Over which sequence should be iterated? _How many_ iterations are there?

3. _output_: What is the _result_ of the loop: What _type_ of object and _how many_ instances? 

After answering these questions, a `for` loop can be designed in reverse order (from output to body):

```{r for-loop-template, echo = TRUE, eval = FALSE}
# (a) prepare output: 
output <- vector(<type>, length(start:end))  

# (b) for loop: 
for (i in start:end} {                    # sequence
  
  result_i <- <solve task for i-th case>  # body: solve task
  output[[i]] <- result_i                 #       collect results in output

}

# (c) use output: 
output  
```

#### Loops for iteration

Assuming we know how often we want to do something. 

Example: Compute square number of integers from 1 to 10.

1. _body_: Square of some number `i`.
2. _sequence_: `i` from 1 to 10.
3. _output_: A vector of 10 numbers.

Implementation:

```{r for-loop-demo-1}
# (a) prepare output: 
output <- vector("double", length(1:10))

# (b) for loop: 
for (i in 1:10) {
  
  sq <- i^2
  print(paste0("i = ", i, ": sq = ", sq))  # for debugging
  output[[i]] <- sq
  
}

# (c) use output: 
output  
```

**Note:** In the `for` loop, we use `output[[i]]`, rather than `output[i]` to refer to the `i`-th element of `output` . 
Actually, using a single `[]` would have worked as well, but the double `[[]]` makes it clear that we want to remove a level of the hierarchy and 
assign something to a single element of `output`. 
(See [Ch. 20.5.2 Subsetting recursive vectors (lists)](https://r4ds.had.co.nz/vectors.html#subsetting-1) for more details on this distinction.) 

#### Loops over data

In the context of data science, we often want to iterate over (rows or columns) of data tables. 
Let's load some data to work with: 

```{r load_data_for_loop}
## Load data:
# tb <- read_csv2("../data/tb.csv")  # from local file
tb <- read_csv2("http://rpository.com/ds4psy/data/tb.csv")  # from local file

# inspect tb: 
dim(tb)  # 100 cases x 5 variables
head(tb)
```

Suppose we wanted to obtain the means of the variables from `age` to `IQ`. 
We could call the `mean` function for each descired variable. Thus, repeating this call for each variable would be:

```{r multiple_means}
# (a) Means: ---- 
mean(tb$age)
mean(tb$height)
mean(tb$shoesize)
mean(tb$IQ)
```

However, the statement "for each variable" in the previous sentence shows that we are dealing with an instance of _iteration_ here. 
When dealing with computers, _repetition_ of identical steps or commands is a signal that there are more efficient ways to accomplish the same task. 

How could we use a for loop here? To design this loop, we need to answer our 3 questions from above: 

1. _body_: We want to compute the mean of 4 columns (`age` to `IQ`) in `tb`.  

2. _sequence_: We want to iterate over columns 2 to 5 (i.e., 4 iterations).  

3. _output_: The _result_ or the loop is a vector of type "double", containing 4 elements.  


**Note:** 

- We remove the 1st column, as no computation is needed for it.  

- The i-th column of tibble `tb` (or data frame `df`) can be accessed via `tb[[i]]` (or `df[[i]]`).  

```{r loop_means_1}
# Prepare data: 
tb_2 <- tb %>% select(-1)
tb_2

# (a) prepare output: 
output <- vector("double", 4)

# (b) for loop: 
for (i in 1:4){
  
  mn <- mean(tb_2[[i]])
  
  output[[i]] <- mn
  
}

# (c) use output: 
output
```

In the **tidyverse** the range of a `for` loop can be defined with a special function: 

```{r}
seq_along(tb_2)  # loop through COLUMNS of a df/table
```

#### Practice {-}

1. Rewrite the for loop to compute the means of columns 2 to 5 of `tb` (i.e., without simplifying `tb` to `tb_2` first). 

#### Solution {-}

We create a new output vector `output_2` and need to change 2 things: 

- the column numbers of the `for` loop statement (from `1:4` to `2:5`). 

- the index to which we assign our current mean `mn` should be decreased to `i - 1` (to assign the mean of column 2 to the 1st element of `output_2`). 

```{r loop_means_2}
# Using data:
# tb

# (a) prepare output: 
output_2 <- vector("double", 4)

# (b) for loop: 
for (i in 2:5){
  
  mn <- mean(tb[[i]])
  
  output_2[[i - 1]] <- mn
  
}

# (c) use output: 
output_2

# Verify equality: 
all.equal(output, output_2)
```

2. We have learned that creating a `for` loop requires knowing (a)&nbsp;the data type of the loop results and 
(b)&nbsp;a data structure than can collect these results. 
This is simple and straightforward if each `for` loop results in a single number, as then all results can be stored in a vector. 

However, things get more complicated when `for` loops yield tables, lists, or plots, as outputs. 
Try creating similar `for` loops that return the `summary` and a histogram (using the **base** R function `hist`) of each variable in `tb` (or each variable of `tb_2`). 

#### Solution {-}

Creating a `summary`: 

```{r practice-summary-1}
# (b) Summary: ---- 
summary(tb$age)
summary(tb$height)
summary(tb$shoesize)
s <- summary(tb$IQ)
s

# What type of object is s?
typeof(s)     # "double"
is.vector(s)  # FALSE
is.table(s)   # TRUE
```

The following `for` loop is almost identical to the one (computing `mean` of columns 2:5 of `tb`) above. 
However, we initialize the `summaries` vector to a `mode = "list"`, which allows storing more complex objects in a vector: 

```{r practice-summary-2}
# Loop:
# (a) prepare output: 
summaries <- vector(mode = "list", length = 4)  # initialize to a vector of lists!

# (b) for loop: 
for (i in 2:5){
  
  sm <- summary(tb[[i]])
  
  summaries[[i - 1]] <- sm
  
}

# (c) use output: 
summaries  # print summaries:
```

Histogram: 

```{r}
# (c) Histogram: ---- 
hist(tb$age)
hist(tb$height)
hist(tb$shoesize)
h <- hist(tb$IQ)
h

typeof(h) # list

# As loop: 
tb_2
names(tb_2[1])
hist(tb_2[[1]], main = paste0("Histogram of ", names(tb_2[1]), " values:"), xlab = names(tb_2[1]))

# With loop:
out <- vector("list", 4)

for (i in seq_along(tb_2)) {  # loop through COLUMNS of tb_2: 
  
  print(i)
  var_name <- names(tb_2[i])
  title <- paste0("Histogram of ", var_name, " values:")
  x_lab <- var_name
  out[[i]] <- hist(tb_2[[i]], main = title, xlab = x_lab)
  
}

plot(out[[1]])
```

### For loop variations

We can distinguish between 4 variations of the basic theme of the for loop:

#### 1. Modifying an existing object, instead of creating a new object {-}

Example: Rescale every column of a table (tibble or data frame).

```{r}
set.seed(1)  # for reproducible results

tb <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)
tb

# Define rescale01 function:
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
```

(a) In 4 separate steps:

```{r}
df <- tb  # copy

# (a) each column individually:
df$a <- rescale01(df$a)
df$b <- rescale01(df$b)
df$c <- rescale01(df$c)
df$d <- rescale01(df$d)

df
```

(b) Using a loop to modify an existing object:  

Answers to our 3 questions:

1. _body_: apply `rescale01()` to every column of `tb`.

2. _sequence_: A list of columns (i.e., iterate over each column with `seq_along(tb)`).

3. _output_: `tb` (i.e., identical to the input).

```{r}
# (b) loop that modifies an existing object:
df2 <- tb  # copy

for (i in seq_along(df2)) {
  
  df2[[i]] <- rescale01(df2[[i]])
  
}

# Output: 
df2

# Verify equality:
all.equal(df, df2)
```

#### 2. Looping over names or values, instead of indices {-}

So far, we used `for loop` to loop over _numeric indices_ of `x` with `for (i in seq_along(x))`, 
and then extracted the `i`-th value of `x` with `x[[i]]`. 

There are 2 additional common loop patterns:

1. loop over the _elements_ of `x` with `for (x in xs)`: 
useful when only caring about side effects 

2. loop over the _names_ of `x` with `for (nm in names(xs))`: 
useful when names are needed for files or plots.

Whenever creating named output, make sure also provide _names_ to the results vector:

```{r}
x <- 1:3

results <- vector("list", length(x))
names(results) <- names(x)

results
```

Note that the basic iteration over the numeric indices is the most general form, 
because given a position we can extract both the current name and the current value:

```{r}
x <- 1:3

for (i in seq_along(x)) {
  name  <- names(x)[[i]]
  value <- x[[i]]
}
```

#### 3. Handling outputs of unknown length {-}

- Problem: Knowing the number of iterations, but not knowing how long the output will be. 

For example, imagine we knew the first `N = 1000` digits of pi (i.e., a series of digits `314159` etc.), but wanted to count how frequently a specific target subsequence (e.g., `target = 13`) occurs in this sequence. 

The following code loads the first `N = 1000` digits of pi into a scalar character object `pi_1000`:

```{r pi_data}
# Data:
## Orig. data source <http://www.geom.uiuc.edu/~huberty/math5337/groupe/digits.html>
## pi_all <- readLines("./data/pi_100k.txt")               # from local data file
pi_data <- "http://rpository.com/ds4psy/data/pi_100k.txt"  # from online data file
pi_all <- readLines(pi_data)                               # read from online source

N <- 1000
pi_1000 <- paste0(substr(pi_all, 1, 1), substr(pi_all, 3, (N + 1)))  # skip the "." at position 2! 
nchar(pi_1000)          # 1000 (qed)
substr(pi_1000, 1, 10)  # first 10 digits
```

The following code uses a for loop to answer the questions: How many times and at which positions does the `target <- 13` occur in `pi_1000`? 

```{r pi_counts_vector}
# initialize: 
count <- 0   # count number of occurrences
target <- 13
target_positions <- c()  # vector to store positions

# loop:
for (i in 1:(N-1)){
  
  # Current 2-digit sequence:
  digits_i <- substr(pi_1000, i, i+1)  # as character 
  digits_i <- as.integer(digits_i)     # as integer
  
  if (digits_i == target){
    
    count <- count + 1  # increment count
    target_positions <- c(target_positions, i)  # add the current i to pi_3
    
  } # end if. 

}

# Results: 
count
target_positions
count == length(target_positions) 
```

The answers are that `r target` occurs `r count` times in `pi_1000`. Its 1st occurrence is at position `r target_positions[1]` and its `r count`-th occurrence at position `r target_positions[count]`.

Note that we could specify the number of iterations (i.e., `N - 1` loops, from 1 to 999), but not the number of elements in `target_positions`. 

Incrementing the `target_positions` vector by `i` every time a new target is found --- by `target_positions <- c(target_positions, i)` --- is quite slow and inefficient. 
However, this is not problematic as long as we only do this once and for a relatively small problem (like a loop with `r (N - 1)` iterations). 

A more efficient solutions could initialize `target_positions` to a _list_ (which can take any data object as an element) and then store any instance of finding the `target` at the `i`-th position of `pi_1000` as the `i`-th instance of the list. Once the loop is finished, we can use `unlist()` to flatten the list to a vector:

```{r pi_counts_list}
# initialize: 
count <- 0   # count number of occurrences
target <- 13
target_positions <- vector("list", (N - 1))  # empty list (of N - 1 elements) to store positions

# loop:
for (i in 1:(N-1)){
  
  # Current 2-digit sequence:
  digits_i <- substr(pi_1000, i, i+1)  # as character 
  digits_i <- as.integer(digits_i)     # as integer
  
  if (digits_i == target){
    
    count <- count + 1        # increment count
    target_positions[i] <- i  # add the current i to pi_3
    
  } # end if. 

}

# Results: 
count
# target_positions # is a list with mostly NULL  
target_positions <- unlist(target_positions)  # flatten list to vector (removing NULL elements)
target_positions
count == length(target_positions) 
```

This way, we could initialize the length of `target_positions` before entering the for loop. 
This made it possible to assign any new target to `target_positions[i]`, but made the list much larger than it actually needed to be. 
The advantages and disadvantages of these different options should be considered for the specific problem at hand. 

#### 4. Handling sequences of unknown length {-}

- Problem: The number of iterations is not known in advance.
- Solution: Use a `while` loop, with a `condition` to stop the loop. 

Sometimes we cannot know in advance how many iterations our loop should run for. 
This is common when dealing with random outcomes or running simulations that need to reach some threshold value to stop. 

We can address these problems with a `while` loop.  
Actually, a `while` loop is simpler than a `for` loop because it only has 2&nbsp;components, a condition and a body:

```{r while_loop_structure, eval = FALSE}
while (condition) {
  # body
}
```

A `while` loop is also more general than a `for` loop because we can write any `for` loop as a `while` loop, but not vice versa. 
For instance, any `for` loop with `N` steps: 

```{r while-vs-for-loop-1}
for (i in 1:N){
  
  # loop body

}
```

can be re-written as a `while` loop that uses a counter variable `i` for the number of iterations and a condition that the maximum number of steps `N` must not be exceeded: 

```{r while-vs-for-loop-2}
i <- 1  # initialize counter

while (i <= N){
  
  # loop body
  
  i <- i + 1  # increment position counter
  
}
```

As this requires explicit maintenance (here: the initialization and incrementation of a counter), we prefer using `for` loops when the number of iterations is known in advance. 

However, we often do not know in advance how many iterations we will need. 
For instance, let's ask ourselves the following question: 

- At which position in the first 1000&nbsp;digits of pi do we first encounter the subsequence&nbsp;`13`?

Actually, we do know the answer to this problem from `target_positions` above: The 1st occurrence of `r target` in `pi_1000` is at position `r target_positions[1]`. Knowing a solution makes this a good practice problem. 

Assuming that we know nothing else of the sequence, we cannot do that sort of iteration with the `for` loop (unless we loop over the entire sequence, as we did above). 
The following `while` loop solves this task by incrementally increasing `i` to inspect the corresponding digits (at positions `i` and `i + 1`) of `pi_1000` as long as we meet the condition `digits_i != target`: 

```{r while-target-pi-13}
# Data:
# pi_1000  # 1000 digits of pi (from above)

target <- 13
i <- 1  # initialize position counter
digits_i <- as.integer(substr(pi_1000, i, i+1)) # 2-digit integer starting at position i 

while (digits_i != target){
  
  i <- i + 1  # increment position counter
  digits_i <- as.integer(substr(pi_1000, i, i+1)) # 2-digit integer starting at position i 

} # end while

# position of 1st target: 
i
```

A danger of `while` loops is that they may never stop. For instance, if we asked:

- At which position in the first 1000&nbsp;digits of pi do we first encounter the subsequence&nbsp;`999`?

we could slightly modify our code above (to accommodate `digits_i` to look for 3-digit number): 

```{r while-target-pi-999}
# Data:
# pi_1000  # 1000 digits of pi (from above)

target <- 999    # 3-digit target (found)
# target <- 123  # alternative target (yielding error)

i <- 1  # initialize position counter
digits_i <- as.integer(substr(pi_1000, i, i+2)) # 3-digit integer starting at position i 

while (digits_i != target){
  
  i <- i + 1  # increment position counter
  digits_i <- as.integer(substr(pi_1000, i, i+2)) # 3-digit integer starting at position i 

} # end while

# position of 1st target: 
i
```

The answer is: The digits `r target` first appear in `pi_1000` at position `r i`. 

However, if we changed our target to `123` to ask the analog question:

- At which position in the first 1000&nbsp;digits of pi do we first encounter the subsequence&nbsp;`123`?

the same `while` loop would encounter an error message:

```{r error-message, eval = FALSE}
Error in while (digits_i != target) { : 
  missing value where TRUE/FALSE needed
```

The source of this error becomes obvious when realizing that `i` is set to a value of&nbsp;1001: 
We simply did not find an instance of `123` in the first 1000&nbsp;digits of pi and the counter is trying to access its 1001.&nbsp;digit, which is undefined (`NA`) and hence causes an error in our condition (`digits_i != target`). 

To prevent this sort of error, we could modify our condition to also stop the `while` loop after the maximum number of possible steps has been reached. 
In our case, the `while` loop does only makes sense as long as we do not exceed the number of characters in `pi_1000`, so that we can add the requirement `(i <= nchar(pi_1000))` as an additional (conjunctive, i.e., using `&&`) test to our condition: 

```{r while-target-pi-123}
# Data:
# pi_1000  # 1000 digits of pi (from above)

# target <- 999  # 3-digit target (found)
target <- 123    # alternative target (not found)

i <- 1  # initialize position counter
digits_i <- as.integer(substr(pi_1000, i, i+2)) # 3-digit integer starting at position i 

while ( (digits_i != target) && (i <= nchar(pi_1000)) ){
  
  i <- i + 1  # increment position counter
  digits_i <- as.integer(substr(pi_1000, i, i+2)) # 3-digit integer starting at position i 

} # end while

# position of 1st target: 
i
```

This way, the `while` loop is limited to a maximum of `nchar(pi_1000) =` `r nchar(pi_1000)` iterations. 
If the counter `i` shows an impossible value of `r i`, we can conclude that the `target` sequence was not found. 

#### Practice {-}

- Combine a `for` loop and a `while` loop to find the positions of the first 3 occurrences of `13` in `pi_1000`. 

**Hint:** Inspecting `target_positions` (computed above) tells you the solution. 
But it's still instructive to combine both type of loops to solve this problem. 

```{r practice-for-while}
# Data:
# pi_1000

first_3 <- rep(NA, 3)  # initialize output 
target <- 13
i <- 1  # initialize position counter
digits_i <- as.integer(substr(pi_1000, i, i+1)) # 2-digit integer starting at position i 

for (n in seq_along(first_3)){
  
  while (digits_i != target){
    
      i <- i + 1  # increment position counter
      digits_i <- as.integer(substr(pi_1000, i, i+1)) # 2-digit integer starting at position i 
    
  } # end while loop.
  
  first_3[n] <- i  # store current position

  i <- i + 1  # increment position counter
  digits_i <- as.integer(substr(pi_1000, i, i+1)) # 2-digit integer starting at position i 
  
} # end for loop,

# Solution:
first_3

# Verify equality:
all.equal(first_3, target_positions[1:3])  
```

+++ here now +++

## Functional programming

### For loops vs. functionals

In R, `for` loops are not as important as in other languages, because R is a _functional_ programming language. 
This means that it’s possible to replace `for` loops by wrapping up the `for` loop in a function, and call that function.

#### Example 

Consider a simple data table `df`: 

```{r}
# Data:
set.seed(1)  # for reproducible results

df <- tibble(a = rnorm(10),
             b = rnorm(10),
             c = rnorm(10),
             d = rnorm(10)
)

df
```

Assume that our goal is getting the mean of every column. 
The standard solution is using a `for` loop:

```{r}
# loop:
output <- vector("double", length(df))

# for loop over columns i: 
for (i in seq_along(df)) {
  
  output[[i]] <- mean(df[[i]])

}

output
```

As we will want to compute the means of every column pretty frequently, we extract it into a function:

```{r}
col_mean <- function(data) {
  
  output <- vector("double", length(data))
  
  for (i in seq_along(data)) {
    
    output[i] <- mean(data[[i]])  # apply function to i-th column of df
    
  }
  
  output
}

# Check: 
col_mean(df)
```

But now we also want the _median_ and _standard deviation_ of every column. 
Of course we could write analog functions `col_median()` and `col_sd()`, 
but they would only differ in 1 lines from `col_mean` above. 

#### Motivation: Generalising functions

What would we do if we saw a set of functions like this:

```{r}
f1 <- function(x) abs(x - mean(x)) ^ 1
f2 <- function(x) abs(x - mean(x)) ^ 2
f3 <- function(x) abs(x - mean(x)) ^ 3
```

Hopefully, we’d notice that there’s a lot of duplication, 
and extract it into an _additional argument_ to a more general function:

```{r}
f <- function(x, i) abs(x - mean(x)) ^ i
```

By doing this, we’ve reduced the chance of bugs (because you now have 1/3 of the original code), 
and made it easier to generalise to new situations.

#### Application: Using functions as arguments to functions

We can do exactly the same thing with `col_mean()`, `col_median()`, and `col_sd()` 
by adding an argument that supplies the _function_ to apply to each column:

```{r}
col_summary <- function(data, fun) {
  
  out <- vector("double", length(data))
  
  for (i in seq_along(data)) {
    
    out[i] <- fun(data[[i]])  # !!!
    
  }
  
  out

  }

# Repeat use of col_mean (from above): 
col_summary(df, fun = mean) # Note: same functionality/results as above.

# New uses: 
col_summary(df, fun = median)
col_summary(df, fun = sd)
```

The idea of passing a _function_ as an _argument_ to another _function_ is an extremely powerful idea, 
and it’s one of the behaviors that makes R a _functional programming language_.


## Replacing loops by `apply` and **purrr**

The `apply` family of functions and the **purrr** package provide functions that eliminate the need for many `for` loops.  

Note that using `apply` and `map` is not necessarily faster than using `for` loops. 
The chief benefit of using these functions is not speed, but _clarity_: They make code easier to write and read.

### Using `apply`

The `base::apply` family of functions in (i.e., `apply`, `lapply`, `tapply`, etc.) 
solve this problem by allowing to apply a function to designated parts of a data structure.

`apply` takes the following arguments: 

- `X` argument takes an array or matrix (i.e., data);
- `MARGIN` argument: `1` = rows, `2` = columns;
- `FUN` is the function to be applied. 

Example: Using `base::apply` to solve the problem above:

```{r apply}
dim(df)  # 10 rows, 4 columns:

# apply FUN to columns:
apply(X = df, MARGIN = 2, FUN = mean)    # mean of every column
apply(X = df, MARGIN = 2, FUN = median)  # median of every column
apply(X = df, MARGIN = 2, FUN = sd)      # SD of every column

# apply FUN to rows:
apply(X = df, MARGIN = 1, FUN = mean)    # mean of every row
apply(X = df, MARGIN = 1, FUN = median)  # median of every row
apply(X = df, MARGIN = 1, FUN = sd)      # SD of every row
```

Note: 

- `lapply` returns a _list_ of the same length as `X`, 
each element of which is the result of applying `FUN` to the corresponding element of `X`.

- See also `sapply` and `vapply` for simplifying arrays and returning vectors. 

### Using **purrr**

The **purrr** package provides modern and more consistent versions of `apply`. 

The main goal of using **purrr** functions (instead of `for` loops) is to allow breaking common list manipulation challenges into independent pieces. 

This strategy involves 2 steps, each of which scales down the problem: 

1. Solving the problem for a _single element_ of the list.  
Once we’ve solved that problem, **purrr** takes care of generalising the solution to every element in the list.

2. Breaking a complex problem down into _smaller sub-problems_ that allow us to advance towards a solution.  
With **purrr**, we get many small pieces that we can compose together with the pipe (`%>%`).

This scaling-down strategy makes it easier to solve new problems and to understand our solutions to old problems when we re-read older code.


### `map` functions

The pattern of looping over a vector, doing something to each element and saving the results is so common that the **purrr** package provides a family of functions for it. 
There is a function for each type of output:

- `map()` makes a _list_.
- `map_lgl()` makes a _logical vector_.
- `map_int()` makes an _integer vector_.
- `map_dbl()` makes a _double vector_.
- `map_chr()` makes a _character vector_.

Each function takes a vector `.x` as input, applies a function `.f` to each element, and then returns a new vector that’s the same length (and has the same names) as the input.   
The type of the output vector is determined by the suffix to the map function.

#### Examples 

Using map on the above example (with doubles as output):

```{r map_dbl_1}
map_dbl(.x = df, .f = mean)
map_dbl(df, median)
map_dbl(df, sd)
```

Notes: 

- Without the suffix `_dbl`,  `map(df, sd)` returns a list (with an element for every column of `df`). 

- With `map`, our focus is on the function/operation, not the bookkeeping of the `for` loop. 
This is even more obvious when using the pipe: 

```{r map_dbl_pipe}
df %>% map_dbl(mean)
df %>% map_dbl(median)
df %>% map_dbl(sd)
```

- `map` also uses the generic `...` argument to allow for additional arguments:

```{r map_dotdotdot}
map_dbl(df, mean, trim = 0.5)
map_dbl(df, sd, na.rm = FALSE)
```

- `map` preserves names:

```{r}
z <- list(x = 1:3, y = 4:5)
z %>% map_int(length)
```


#### Shortcuts

There are a few shortcuts to save typing in the `.f` argument of `map`. 

Imagine we want to fit a linear model to each group in a dataset. 

The following example splits the up the `mtcars` dataset in to 3 pieces (by value of cylinder) 
and fits the same linear model to each piece. 
The linear model is supplied as an _anonymous function_: 

```{r map_split_anon_fun}
mtcars %>%
  group_by(cyl) %>% 
  count()

models <- mtcars %>% 
  split(.$cyl) %>%                            # split data into 3 sets (by cyl) 
  map(function(df) lm(mpg ~ wt, data = df))   # map lm function to each set

models # 3 linear models
```

As the syntax for creating an _anonymous function_ in R is quite verbose, **purrr** provides a _one-sided formula_ as a shortcut: 

```{r map_split_shortcut}
models <- mtcars %>% 
  split(.$cyl) %>% 
  map(~lm(mpg ~ wt, data = .))

models
```

Here, the `.` is used as a pronoun that refers to the current list element. 

When inspecting many models, we may want to extract a summary statistic like $R^{2}$. 
To do that we need to first run `summary()` on our `models` and then extract the component called `r.squared`. 
We could do that using the _shorthand for anonymous functions_:

```{r map_split_map_2}
models %>% 
  map(summary) %>% 
  map_dbl(~.$r.squared)
```

But extracting named components is a common operation, so **purrr** provides an even shorter shortcut: We can use a _string_:

```{r map_split_map_named}
models %>% 
  map(summary) %>% 
  map_dbl("r.squared")
```

Alternatively, we can also use an _integer_ to select elements by position:

```{r map_split_map_number}
x <- list(list(1, 2, 3), 
          list(4, 5, 6), 
          list(7, 8, 9))

x %>% map_dbl(2)  # 2nd column of x
```

### `map` vs. `apply`

The `map` functions of **purrr** are modeled on the `apply` functions:

- `lapply` is basically identical to `map`, except that `map` is consistent with all the other functions in **purrr**, and we can use the shortcuts for `.f`.

- `sapply` is a wrapper around `lapply` that automatically simplifies the output (which can yield unexpected results).

- `vapply` is a safe alternative to `sapply` because you supply an additional argument that defines the type. 
The only problem with `vapply` is that it’s a lot of typing: `vapply(df, is.numeric, logical(1))` is equivalent to `map_lgl(df, is.numeric)`. 


- One advantage of `vapply` over **purrr**’s `map` functions is that it can also produce _matrices_ — the `map` functions only ever produce _vectors_.

<!-- +++ here now +++ --> 

### Dealing with failure

Adverbs:

- `safely`
- `possibly`
- `quietly`

### Mapping over multiple arguments

### Walk 






# Exercises (WPA10) {#iteration:ex}

Here are the exercises of WPA10 and possible solutions for them.

## Exercise 1 {#iteration:ex01}

- Look up the term _Fibonacci numbers_ and write a function that uses a for loop to create and return the first `n` Fibonacci numbers.

- Use your function to print the first 25 Fibonacci numbers.

#### Solution {-}

According to [Wikipedia](https://en.wikipedia.org/wiki/Fibonacci_number), a Fibonacci sequence is the integer sequence of `0, 1, 1, 2, 3, 5, 8, ...`. 

For any element $e_{i}$ and $i > 2$, each element is the sum of the 2 preceding elements: 

$e_{i} = e_{i-2} + e_{i-1}$.   

```{r fibonacci}
fibonacci <- function(n){
  
  if (is.na(n) || (n < 1) || (n != round(n)))  {
    stop("n must be a positive integer.")
  }
  
  # initialize the sequence:
  fib <- c(0, 1)
  
  if (n <= 2){
    
    fib <- fib[1:n]
    
  } else {

    # initialize output vector:    
    fib <- c(fib, rep(NA, (n-2)))
    
    # loop:
    for (i in 3:n){
      
      fib[i] <- fib[i-2] + fib[i-1]
      
    } # end for loop.
  } # end if (n > 2).
  
  return(fib)

}

# Check:
fibonacci(1)
fibonacci(2)
fibonacci(3)
fibonacci(4)

# First 25 Fibonacci numbers:
fibonacci(25)

## Errors:
# fibonacci(0)
# fibonacci(-1)
# fibonacci(3/2)
# fibonacci(NA)
```

## Exercise 2 {#iteration:ex02}

#### Looping for divisors

1. Write a for loop that prints out all positive divisors of the number 1000.  

(**Hint:** Use `N %% x == 0` to test whether `x` is a divisor of `N`.)

#### Solution {-}

```{r iter-ex2-1}
N <- 1000
for (i in 1:N){
  
  if (N %% i == 0) 
    print(i)
  
}
```

2. How many iterations did your loop require? Could you achieve the same results with fewer iterations?

#### Solution {-}

We took `N = 1000` iterations, but can achieve the same with fewer:

```{r iter-ex2-2}
# Using a sequence of N/2 + 1 loops:
seq <- c(1:ceiling(N/2), N)
length(seq)

for (i in seq){
  
  if (N %% i == 0) 
    print(i)
  
}
```

3. Write a `divisors` function that uses a for loop to return a numeric vector containing all positive divisors of a natural number `N`. 

(**Hint:** Note that we do not know the length of the resulting vector.)

#### Solution {-}

```{r iter-ex2-3}
divisors <- function(N){
  
  if ( is.na(N) || (N < 1) || (N %% 1 != 0)) { stop("N should be a natural number.") }
  
  # initialize: 
  out <- c() 
  seq <- c(1:ceiling(N/2), N)
  
  if (N == 1) { 
    
    return(1) # done
    
  } else {
    
    # loop:
    for (i in seq){
      
      if (N %% i == 0) 
        
        out <- c(out, i)
      
    } # end loop.
    
    return(out)
    
  }  # end if.
  
}

# Check:
divisors(1)
divisors(8)
divisors(12)
divisors(1000)

## Errors for:
# divisors(NA)
# divisors(-10)
# divisors(1/2)
```

## Exercise 3 {#iteration:ex03}

1. Implement a function `dice` that uses the **base** R function `sample()` to simulate a throw of a dice (i.e., yielding an integer from&nbsp;1 to&nbsp;6 with equal probability). 

#### Solution {-}

```{r iter-ex03-1}
dice <- function() {
  sample(x = 1:6, size = 1)
}

# Check:
dice()
# Using for loop to throw dice 10 times:
for (i in 1:10){
  print(dice())
}
```

2. Add an argument `n` (for the number of throws) to your function and modify it by using a `for` loop to throw the dice `n` times, and returning a vector of length `n` that shows the results of the `n` throws.

#### Solution {-}

```{r iter-ex03-2a}
dice <- function(n = 1) {
  
  out <- rep(NA, n)
  
  for (i in 1:n){
    
    out[i] <- sample(x = 1:6, size = 1)
    
  } # end for loop.
  
  return(out)
  
}
  
# Check:
dice()
dice(10)  # throw dice 10 times
```

Note: As the `sample` function contains a `size` argument, a simpler version of the same function could have been:

```{r iter-ex03-2b}
dice <- function(n = 1) {
  sample(x = 1:6, size = n, replace = TRUE)
}

# Check:
dice()
dice(10)  # throw dice 10 times
```

3. Use a `while` loop to throw `dice(n = 1)` until you throw the number 6 twice in a row and show the sequence of all throws up to this point.

**Hint:** Given a sequence `throws`, the `n`-th element is `throws[n]`. 
Hence, the last element of `throws` is `throws[length(throws)]`. 

#### Solution {-}

```{r iter-ex03-3}
throws <- c(dice(1), dice(1))  # first 2 throws
throws

while (!( (throws[length(throws) - 1] == 6) &&
          (throws[length(throws)] == 6) )) {
  
          throws <- c(throws, dice(1))  # throw dice(1) and add it to throws
  
}

throws
```

4. Use your solution of 3. to conduct a simulation that addresses the following question: 

- How many times on average do we need to throw `dice(1)` to obtain the number 6 twice in a row?

**Hint:** Use a `for` loop to run your solution to 3. for `N = 10000` times and store the length of the individual `throws` in a numeric vector. 

#### Solution {-}

```{r iter-ex03-4}
N <- 10000

out <- rep(NA, N)  # initialize output vector

for (n in 1:N){
  
  throws <- c(dice(1), dice(1))  # first 2 throws  
  
  while (!( (throws[length(throws) - 1] == 6) &&
            (throws[length(throws)] == 6) )) {
    
    throws <- c(throws, dice(1))  # throw dice(1) and add it to throws
  }
  
  out[n] <- length(throws)
  
}

# Results:
mean(out)
summary(out)
```

A histogram shows the distribution of the individual number of throws:

```{r iter-ex03-4b, fig.asp = .40}
library(tidyverse)
library(unikn)

# Turn out into a tibble: 
tb <- tibble(nr = out)
# tb

# Histogram of individual number of throws:
ggplot(tb) + 
  geom_histogram(aes(x = nr), binwidth = 5, fill = Seeblau) + 
  # Show mean and median:
  geom_vline(xintercept = mean(out), linetype = 1, color = Bordeaux) +  # mean line
  geom_text(label = paste0("mean = ", round(mean(out), 2)), x = mean(out) + 20, y = 950, color = Bordeaux) +    # mean label
  geom_vline(xintercept = median(out), linetype = 2, color = Petrol) +  # median line 
  geom_text(label = paste0("median = ", round(median(out), 2)), x = median(out) + 20, y = 750, color = Petrol) +  # mean label
  # Text and formatting: 
  labs(title = "Number of throws needed to get 6 twice in a row") + 
  coord_cartesian(xlim = c(0, 300)) +  # do not show values beyond x = 300
  theme_unikn(col_title = "black")
```

+++ here now +++ 

## Exercise X

Iteration only:

- `z`-transform every numeric column of a table

Loops in new functions

- Write a function that z-transforms every numeric column in a table. 


## `map` functions of **purrr**

- See <https://r4ds.had.co.nz/iteration.html#exercises-58> 



# More on iteration

- For loops in general, see the [contributed cheatsheets](https://www.rstudio.com/resources/cheatsheets/) on _Base R_ and _Advanced R_. 

- For references on functional programming (FP) with **purrr**, see <https://purrr.tidyverse.org> and the [purrr cheatsheet](https://www.rstudio.com/resources/cheatsheets/). 

- See [Chapter 21: Iteration](https://r4ds.had.co.nz/iteration.html) of [r4ds](https://r4ds.had.co.nz/) and its exercises. 


# Conclusion

<!-- Table with links: -->

All [ds4psy](http://rpository.com/ds4psy/) essentials so far: 

Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | [Transforming data](http://rpository.com/ds4psy/essentials/transform.html) |
4.  | [Exploring data (EDA)](http://rpository.com/ds4psy/essentials/explore.html) | 
5.  | [Tibbles](http://rpository.com/ds4psy/essentials/tibbles.html) |
6.  | [Importing data](http://rpository.com/ds4psy/essentials/import.html) |
7.  | [Tidying data](http://rpository.com/ds4psy/essentials/tidy.html) |
8.  | [Joining data](http://rpository.com/ds4psy/essentials/join.html) |
9.  | [Functions](http://rpository.com/ds4psy/essentials/function.html) |
10.  | **Iteration**|
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 

<!--
Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | [Transforming data](http://rpository.com/ds4psy/essentials/transform.html) |
4.  | [Exploring data (EDA)](http://rpository.com/ds4psy/essentials/explore.html) | 
5.  | [Tibbles](http://rpository.com/ds4psy/essentials/tibbles.html) |
6.  | [Importing data](http://rpository.com/ds4psy/essentials/import.html) |
7.  | [Tidying data](http://rpository.com/ds4psy/essentials/tidy.html) |
8.  | [Joining data](http://rpository.com/ds4psy/essentials/join.html) |
9.  | [Functions](http://rpository.com/ds4psy/essentials/function.html) |
10. | [Iteration](http://rpository.com/ds4psy/essentials/iteration.html) |
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 
-->

[Last update on `r Sys.time()` by [hn](https://neth.de/).]  

<!-- eof. --> 