---
title: "Tidy data, with solutions (ds4psy)"
author: "Hansjörg Neth, SPDS, uni.kn"
date: "2018 12 12"
output:
   rmdformats::html_clean: # html_clean html_docco readthedown material #
     code_folding: show # hide
     toc_float: true
     toc_depth: 3
     highlight: default # textmate default kate haddock monochrome #
     lightbox: true # true by default
     fig_width: 7 # in inches
editor_options: 
  chunk_output_type: console # inline
---

<!-- Example of essential commands | ds4psy: Winter 2018 -->

```{r preamble, echo = FALSE, eval = TRUE, cache = FALSE, message = FALSE, warning = FALSE}
## (a) Housekeeping: -----
rm(list=ls()) # clean all.

## (b) Current file name and path: ----- 
# my_path <- dirname(rstudioapi::getActiveDocumentContext()$path)
# my_path
# setwd(my_path) # set to current directory
setwd("~/Desktop/stuff/Dropbox/_code/R/_teachR/ds4psy/_essentials") # set to current directory
# list.files() # all files + folders in current directory
fileName <- "tidy.Rmd"

## (c) Packages: ----- 
library(knitr)
library(rmdformats)
library(tidyverse)

## (d) Global options: ----- 
options(max.print = "75")
opts_chunk$set(echo = TRUE,
	             cache = TRUE,
               prompt = FALSE,
               tidy = FALSE,
               collapse = TRUE, # set TRUE in answers 
               comment = "#>",
               message = FALSE,
               warning = FALSE,
               ## Default figure options:
               fig.width = 7, 
               fig.asp = .618, # golden ratio
               out.width = "75%",
               fig.align = "center"
               )
opts_knit$set(width = 75)

## (e) Custom functions: ----- 
source(file = "~/Desktop/stuff/Dropbox/_code/R/_teachR/ds4psy/R/custom_functions.R")
```

# Introduction

This file contains **essential commands** from [Chapter 10: Tibbles](https://r4ds.had.co.nz/tibbles.html) of the textbook [r4ds](http://r4ds.had.co.nz) and corresponding examples and exercises. 
A command is considered "essential" when you really need to _know_ it and need to know _how to use_ it to succeed in this course. 

<!-- Table with links: -->

All [ds4psy](http://rpository.com/ds4psy/) essentials so far: 

Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | [Transforming data](http://rpository.com/ds4psy/essentials/transform.html) |
4.  | [Exploring data (EDA)](http://rpository.com/ds4psy/essentials/explore.html) | 
5.  | [Tibbles](http://rpository.com/ds4psy/essentials/tibbles.html) |
6.  | [Tidy data](http://rpository.com/ds4psy/essentials/tidy.html) | 
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 

<!--
Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | [Transforming data](http://rpository.com/ds4psy/essentials/transform.html) |
4.  | [Exploring data (EDA)](http://rpository.com/ds4psy/essentials/explore.html) | 
5.  | [Tibbles](http://rpository.com/ds4psy/essentials/tibbles.html) |
6.  | [Tidy data](http://rpository.com/ds4psy/essentials/tidy.html) |
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 
-->

## Course coordinates

<!-- uni.kn logo and link to SPDS: -->  
<!-- ![](./inst/pix/uniKn_logo.png) --> 
<a href="https://www.spds.uni-konstanz.de/">
<img src = "../inst/pix/uniKn_logo.png" alt = "spds.uni.kn" align = "right" width = "300" style = "width: 300px; float: right; border:20;"/>
<!-- <img src = "./inst/pix/uniKn_logo_s.png" alt = "spds.uni.kn" style = "float: right; border:20;"/> --> 
</a>

* Taught at the [University of Konstanz](https://www.uni-konstanz.de/) by [Hansjörg Neth](http://neth.de/) (<h.neth@uni.kn>,  [SPDS](https://www.spds.uni-konstanz.de/), office D507).
* Winter 2018/2019: Mondays, 13:30--15:00, C511. 
* Links to current [course syllabus](http://rpository.com/ds4psy/) | [ZeUS](https://zeus.uni-konstanz.de/hioserver/pages/startFlow.xhtml?_flowId=detailView-flow&unitId=5101&periodId=78&navigationPosition=hisinoneLehrorganisation,examEventOverviewOwn) |  [Ilias](https://ilias.uni-konstanz.de/ilias/goto_ilias_uni_crs_809936.html) 


## Preparations

Create an R script (`.R`) or an R-Markdown file (`.Rmd`) and load the R packages of the `tidyverse`. (**Hint:** Structure your script by inserting spaces, meaningful comments, and sections.) 

```{r layout_template, echo = TRUE, eval = FALSE}
## Tidy data | ds4psy
## 2019 01 10
## ----------------------------

## Preparations: ----------

library(tidyverse)

## 1. Topic: ----------

# etc.

## End of file (eof). ----------  
```

To use [R Markdown](https://rmarkdown.rstudio.com), create a corresponding file and save it with the `.Rmd` extension (e.g., by selecting `File > New File > R Markdown`). 
For instructions on combining text and code, see [Chapter 27: R Markdown](https://r4ds.had.co.nz/r-markdown.html) of our textbook, or use one of the following templates:  

- minimal template:  `rmd_template_s` [in [.Rmd](http://rpository.com/down/temp/rmd_template_s.Rmd) | [.html](http://rpository.com/down/temp/rmd_template_s.html) format]

- medium template: `rmd_template_m` [in [.Rmd](http://rpository.com/down/temp/rmd_template_m.Rmd) | [.html](http://rpository.com/down/temp/rmd_template_m.html) format]

- explicit explanations: `Rmarkdown_basics` [in [.Rmd](http://rpository.com/down/temp/Rmarkdown_basics.Rmd) | [.html](http://rpository.com/down/temp/Rmarkdown_basics.html) format]

**Hint:** Try to _knit_ your `.Rmd` file immediately after saving it and marvel at the beauty of the resulting `.html`-file. If this works, keep doing this routinely from now on, putting all your R-code into code chunks, and any text (like headings or conclusions) that describes or explains what you are doing outside of them. From now on, you can share your `.html` output files, rather than your `.Rmd` source files when showing off your R and data science skills.


# Tibbles


# Tidy data

## Tabular data

In R, rectangular data is often organized in _tibbles_ or _data frames_. Importantly, each column is a vector (of a particular type) that contains the values of a variable. Thus, whereas every column must be of one type, every row can contain values of different variables and types. 

The same set of data (values of variables) can be organised in many different ways. For instance, the following tables (or tibbles) all provide the number of TB cases documented by the World Health Organization in 3 countries (Afghanistan, Brazil, and China) in 2 years (1999 and 2000):

```{r table1_as_barplot, echo = FALSE, eval = TRUE}
library(tidyverse)
library(knitr)

# Illustrating the data in tidyr::table1 
kable(tidyr::table1)

ggplot(data = tidyr::table1, aes(x = year, y = cases, fill = country)) + 
    geom_bar(stat = "identity", position = "dodge", color = "black") + 
    geom_text(aes(label = cases), position = position_dodge(width = 0.9), vjust = -0.5) +
    scale_x_continuous(name = "Year", breaks = 1999:2000) + 
    scale_fill_manual(name = "Country", 
                      values = c("grey33", "forestgreen", "firebrick")) + 
    labs(title = "TB cases per country and year", y = "Cases", 
         caption = "[Data from tidyr::table1.]") +
    theme_classic() +
    theme(panel.grid.major.y = element_line(linetype = 2, color = "grey50", size = 1/4))
```

```{r rectangular_data}
library(tidyverse)

## Example of the same data organised in 4 different ways:
# ?table1 # for semantics and source of data

tidyr::table1

tidyr::table2

tidyr::table3

tidyr::table4a
tidyr::table4b

tidyr::table5
```

**Practice:** Recreate the above bar plot using `ggplot2` with `data = table1`. 

### Defining tidy data

**Definition:** A _tidy_ dataset conforms to 3 interrelated rules:

1. Each _variable_ must have its own _column_.

2. Each _case/observation_ must have its own _row_.

3. Each _value_ must have its own _cell_.

See <http://r4ds.had.co.nz/tidy-data.html#fig:tidy-structure> for a graphical illustration of these rules. 

The 3 rules defining _tidy_ data are connected, as it is impossible to only satisfy 2 of the 3. 
This leads to a simpler set of practical instructions for tidying a messy set of data: 

a. turn each dataset into a tibble.  
b. put each variable into a column.  

Note that we need to interpret the semantics of the variables to understand whether a data set is tidy. 

**Practice:** Which of the data tables in the above example (`table1` to `table5`) are tidy? Why or why not?


### Advantages of tidy data 

1. _Consistency_: Consistent data structures make it easier to learn the tools that work with it because they have an underlying uniformity.

2. _Vectorization_: Placing variables in columns allows R’s vectorised nature to shine. For instance, the basic verbs of `dplyr` (and most built-in R functions) work with vectors of values. That makes transforming tidy data easy and natural. 

3. _Matching_ data and tools: Packages like `dplyr`, `ggplot2`, and many others are designed to work with tidy data. 


## Commands and examples

We consider 2 pairs of 2 complementary commands as essential:

1. `separate` splits 1 variable into 2 variables;  
2. `unite` combines 2 variables into 1 variable;  
3. `gather` makes wide data longer (by gathering many variables into 1);  
4. `spread` makes long data wider (by spreading 1 variable into many).  

`separate` is the complement/opposite of `unite` and `spread` is the complement/opposite of `gather`. 

Here are some basic examples for using these 4 commands: 

### 1. `separate` 1 variable into 2

`separate` splits 1 variable (column) into multiple variables (columns) -- at a position where some separator character appears -- and is the complement to `unite`. 
Using `separate` requires the following arguments: 

- some tibble/data frame `data`; 
- the variable (column) `col` to be separated (specified by its name or column number); 
- the names of the new variables (columns) `into` which `col` is to be split (specified as a character vector); 
- the separator character `sep` (as a character/regular expression). 

An additional argument `remove` regulates whether the original columns are dropped from the output tibble. By default, `remove = TRUE`.

```{r separate_example_1}
# Data to use: 
tidyr::table3  # Note that column rate contains 2 numbers, separated by "/". 

## Basics: ----- 

# Full separate command:
separate(data = table3, col = rate, into = c("cases", "population"), sep = "/")
# Note that "/" disappears from output tibble.

# Shorter versions of the same command:
separate(table3, rate, c("cases", "population"))

# Using the pipe: 
table3 %>% 
  separate(rate, c("cases", "population"))

## Variants: ----- 

# Specifying the variable to be split (rate) by its column number (3):
table3 %>% 
  separate(3, c("cases", "population"))

# Not dropping the original rate variable:
table3 %>% 
  separate(rate, c("cases", "population"), remove = FALSE)
```

The example shows that the argument names (`data`, `col`, and `into`) can be left out (but still require appropriate arguments in the correct order) and  `sep` can be left unspecified when `tidyr` can make a good guess what the separator character might be. 

```{r create_data_for_separate_example_2, echo = FALSE, eval = TRUE}
table6 <- table5 %>% 
  unite(col = when, century, year, sep = "_") %>%
  unite(col = when_what, when, rate, sep = ".")
# table6

## Writing out data:
# write_csv(table6, "data/table6.csv")

## Reading in again (from csv-file):
# tb6 <- read_csv("data/table6.csv")
# tb6

table7 <- table5 %>%
  mutate(rate_2 = stringr::str_replace_all(table5$rate, "/", "\\\\")) %>%  # replace "/" with "\\"
  unite(col = when, century, year, sep = ":") %>%
  unite(col = when_what, when, rate_2, sep = "$") %>%
  unite(col = where_when_what, country, when_what, sep = "@") %>%
  select(where_when_what)
# table7

## Writing out data:
# write_csv(table7, "data/table7.csv")

## Reading in again (from csv-file):
# tb7 <- read_csv("data/table7.csv")
# tb7
```

However, consider the following `table6`, which is available online and can be read into R via `read_csv("http://rpository.com/ds4psy/data/table6.csv")`: 

```{r show_tb6, echo = TRUE, eval = TRUE}
## Load data (as comma-separated file): 
table6 <- read_csv("http://rpository.com/ds4psy/data/table6.csv")  # from online source

## Alternatively (from local source "data/table6.csv"): 
# table6 <- read_csv("data/table6.csv")  # from local directory

table6
```

Here, the variable `when_what` contains several plausible separation characters: `_`, `.`, and `/`. 
Let's first see what happens when we fail to provide a separating character `sep`, and then split the variable `when_what` in three different ways: 

```{r separate_example_2}
# Data to use: 
table6 <- read_csv("http://rpository.com/ds4psy/data/table6.csv") # from online source
table6    # Note that column when_what contains several splitting options. 

# What happens when we do not specify "sep"? 
table6 %>%
  separate(col = when_what, into = c("var_1", "var_2"))  # sep is not provided!

# => when_what is split at 1st option (_), but Warning (and loss of data)!

# Specifying different splitting characters:
# (a) split at "_": 
table6 %>%
  separate(col = when_what, into = c("var_1", "var_2"), sep = "_")  # 

# (b) split at "." (specified as a regular expression "\\."):
table6 %>%
  separate(col = when_what, into = c("var_1", "var_2"), sep = "\\.")  

# (c) split at "/":
table6 %>%
  separate(col = when_what, into = c("var_1", "var_2"), sep = "/")
```

Note that using the point or period (`.`) as a splitting character `sep = "."` would _not_ work. 
Instead, we need to use the corresponding regular expression `sep = "\\."`. 
(See [Chapter 14: Strings](http://r4ds.had.co.nz/strings.html) for details.) 

**Practice:** Split the `when_what` variable of `table6` 3 times to create a tibble `table6a` that contains 5 variables (columns) and reasonable variable names: 

```{r separate_practice, echo = FALSE, eval = TRUE}
table6a <- table6 %>%
  separate(col = when_what, into = c("century", "stuff"), sep = "_") %>%
  separate(col = stuff, into = c("year", "stuff"), sep = "\\.") %>% 
  separate(col = stuff, into = c("cases", "population"), sep = "/")

table6a
```


### 2. `unite` 2 variables into 1

`unite` combines 2 variables (columns) into 1 variable (column) -- adding an optional separator character -- and is the complement to `separate`. 
Using `unite` requires the following arguments: 

- some tibble/data frame `data`; 
- the name of the new compound variable (column) `col` (specified as a character); 
- the names of the variables (columns) to be combined (specified by their names or column numbers); 
- an optional separator character `sep` (as a character/regular expression). 

An additional argument `remove` regulates whether the original columns are dropped from the output tibble. By default, `remove = TRUE`.

```{r unite_example_1}
# Data to use: 
tidyr::table5  # Note that columns 2 and 3 contain 2 values (as characters!) that belong together. 

## Basics: ----- 

# Full separate command:
unite(data = table5, col = "yr", century, year, sep = "")
# Note that century and year variables disappear from output tibble.

# Shorter versions of the same command:
unite(table5, "yr", century, year, sep = "")

# Using the pipe: 
table5 %>%
  unite("yr", century, year, sep = "")

## Variants: ----- 

# Providing a different separation character:
table5 %>%
  unite("yr", century, year, sep = "<--|-->")

# Specifying the variables to be combined () by their column numbers (2 & 3):
table5 %>% 
  unite("yr", 2, 3, sep = "")

# Not dropping the original variables:
table5 %>%
  unite("yr", century, year, sep = "", remove = FALSE)
```

**Practice:** Take the data from `dplyr::storms` and unite the variables `year`, `month`, `day` into 1 variable `date`.

```{r unite_practice, echo = FALSE, eval = TRUE}
## Data to use: 
# dplyr::storms

## Uniting year:day into date:
storms %>%
  unite("date", year:day, sep = "/") %>%
  head()
```

**Practice:** Read the data from `read_csv("http://rpository.com/ds4psy/data/table7.csv")` into a tibble `table7` and inspect its dimension and contents.

a. Use multiple (4) `separate` commands to split `table7` into a tibble `table7a` with multiple (5) columns. 

b. Use multiple (4) `unite` commands on `table7a` to re-create a tibble `table7b` that contains _all_ data in 1 column. 

Examples of `table7` and possible solutions for `table7a` and `table7b`: 

```{r separate+unite_practice, echo = FALSE, eval = TRUE}
# Data to use: 
table7 <- read_csv("http://rpository.com/ds4psy/data/table7.csv") # from online source
table7  # Note that column when_what contains several splitting options.

# (a) Separating:
table7a <- table7 %>%
  separate(col = where_when_what, into = c("country", "stuff"), sep = "@") %>%
  separate(col = stuff, into = c("year", "stuff"), sep = "\\$") %>%    # using regex "\\$"
  separate(col = year, into = c("century", "year"), sep = ":") %>%
  separate(col = stuff, into = c("rate", "population"), sep = "\\\\")  # using regex "\\\\"

table7a

# (b) Uniting: 
table7b <- table7a %>% 
  unite("yr", century, year, sep = "") %>%
  unite("what", rate, population, sep = "/") %>%
  unite("where_when", country, yr, sep = ":") %>%
  unite("where_when_what", where_when, what, sep = "_")

table7b
```


### 3. `gather` makes wide data longer 

Gathering is the opposite of spreading and used when observations that are distributed over multiple columns should be contained in 1 variable (column). More specifically, `gather` moves the values of several variables (columns) into 1 column `value` and describes this value by the value of a new `key` variable. When gathering more than 2 variables, this reduces the number of columns by increasing the number of rows (i.e., makes a wide data set longer).^[The length and width of a data set are relative terms here: gathering tends to decrease data width by increasing length, spreading tends to decrease data length by increasing width.] 

Using `gather` requires the following arguments: 

- `data` is a data frame or tibble;  
- `key` is the name of the variable that describes the values of the gathered columns (or name of the _independent_ variable);  
- `value` is the name of the variable that is contained in the gathered columns (or the name of the _dependent_ variable);  
- `...` or `var_x:var_y` is a list of variables (columns) to be gathered. 

```{r gather_example_1}
# ?gather # provides documentation

## Data to use: 
table4a
# Note that counts of cases is distributed over 2 variables (columns) for each country.

## Basics: -----

# gather 2 variables into 1 variable:
gather(data = table4a, 
       key = year, value = cases, 
       `1999`:`2000`)

# The same command using the pipe:
table4a %>%
  gather(key = year, value = cases, 
         `1999`:`2000`)

## Variants: ----- 

# The same command with in different order of arguments:
table4a %>%
  gather(`1999`:`2000`, key = year, value = cases)

# The same command specifying the numbers of the columns to gather:
table4a %>%
  gather(2:3, key = year, value = cases)
```

Note that `year` is of type _character_ in the above example. If we wanted our `key` variable to be converted into a number (here: an integer), we can add the optional argument `convert = TRUE`:

```{r gather_convert}
## Default: convert = FALSE: 
table4a %>%
  gather(key = year, value = cases, `1999`:`2000`, convert = FALSE)
# => year is a character vector.

## Converting year into an integer:
table4a %>%
  gather(key = year, value = cases, `1999`:`2000`, convert = TRUE)
# => year is a vector of integers. 
```


**Practice:** Save the following data as a tibble `de` and then turn it into tidy data (by using `gather` to create a single variable `share` and listing the election `year` as an additional variable).

```{r de_tibble, echo = FALSE, eval = TRUE}
## (a) Create a tibble with the data:
de <- tibble(
    party = c("CDU/CSU", "SPD", "Others"),
    share_2013 = c((.341 + .074), .257, (1 - (.341 + .074) - .257)), 
    share_2017 = c((.268 + .062), .205, (1 - (.268 + .062) - .205))
    )

## Check that columns add to 100:
# sum(de$share_2013)  # => 1 (qed)
# sum(de$share_2017)  # => 1 (qed)

de$party <- factor(de$party, levels = c("CDU/CSU", "SPD", "Others"))  # optional
knitr::kable(de)
```

```{r gather_separate_practice}
## (a) Data saved as a tibble (see above): 
de

## (b) Converting de into a tidy data table:
de_2 <- de %>%
  gather(share_2013:share_2017, key = "election", value = "share") %>%
  separate(col = election, into = c("dummy", "year")) %>%
  select(year, party, share)

de_2
```


### 4. `spread` makes long data wider 

Spreading is the opposite of gathering and used when an observation that should be in 1 row is distributed over multiple rows (in 1 column). More specifically, `spread` puts the values of several cases (rows) into different variables (columns) of 1 row. When spreading more than 2 rows per case, this decreases the number of rows by increasing the number of columns (i.e., makes a long data set wider).^[Again, the length and width of data sets are relative terms.] 

Using `spread` requires the following arguments: 

- `data` is a data frame or tibble;  
- `key` is the name of the variable that describes the values of the gathered columns (or the names of the _independent_ variables which become the _names_ of the new columns);  
- `value` is the name of the variable whose values should be spread over multiple columns (or the name of the _dependent_ variable);

Note that we do not need to specify a range of new columns. The number of new columns is determined by the number of different values in the `key` variable. 

```{r spread_example_1}
# ?spread # provides documentation

## Data to use: 
table2
# Note that count contains 2 DVs which are described by the values of type. 

## Basics: -----

# spread 2 rows into 2 columns of 1 row:
spread(data = table2, 
       key = type, value = count)

# The same command using the pipe:
table2 %>% 
  spread(key = type, value = count)

# The same shorter: 
table2 %>% 
  spread(type, count)


## Variants: -----

# Use <key><sep><value> to create new column names:
table2 %>% 
  spread(key = type, value = count, sep = ":")
```

**Practice:** Take the 6 x 3 tibble `de_2` (from above) and use `spread` to create a 3 x 3 tibble `de_3` that re-creates the original tibble `de` from it.

```{r spread_practice}
## (a) Data from above: 
de_2

## (b) Using spread to put share by year into 2 columns/variables:
de_3 <- de_2 %>% 
  spread(key = year, value = share) %>%
  rename(share_2013 = `2013`,  # restore original variable names
         share_2017 = `2017`)

de_3

## (c) Comparing de_3 to de: 
de
all.equal(de_3, de)
```

**Practice:** Moving stocks from wide to long to wide. 

```{r stock_data_definition, echo = FALSE, eval = TRUE}
# Define the stock data (to be shown below) as a tibble: 
st <- tribble(
  ~stock, ~d1_start, ~d1_end, ~d2_start, ~d2_end, ~d3_start, ~d3_end,  
  #-----|----------|--------|----------|--------|----------|--------|
  "Amada",   2.5,     3.6,    3.5,       4.2,      4.4,       2.8,            
  "Betix",   3.3,     2.9,    3.0,       2.1,      2.3,       2.5,  
  "Cevis",   4.2,     4.8,    4.6,       3.1,      3.2,       3.7     
)
```

The following table shows the start and end price of 3 stocks on 3 days (d1, d2, d3):

```{r stock_data_table, echo = FALSE, eval = TRUE}
knitr::kable(st, caption = "Stock data example showing the start and end prices of the shares of 3 companies on 3 days.")
```

<!-- Data as Rmd table in text: 
| stock  | d1_start | d1_end | d2_start | d2_end | d3_start | d3_end |  
|---------|---------|--------|----------|--------|----------|--------|
| "Amada" |   2.5  |   3.6   |   3.5    |  4.2   |   4.4    |   2.8  |            
| "Betix" |   3.3  |   2.9   |   3.0    |  2.1   |   2.3    |   2.5  |  
| "Cevis" |   4.2  |   4.8   |   4.6    |  3.1   |   3.2    |   3.7  |
--> 

**a.** Create a tibble `st` that contains this data in this (wide) format.

**b.** Transform `st` into a longer table `st_long` that contains 18 rows and only 1 numeric variable for all stock prices. Adjust this table so that the `day` and `time` appear as 2 separate columns. 

**c.** Create a (line) graph that shows the 3 stocks' `end` prices (on the y-axis) over the 3 days (on the x-axis). 

**d.** Spread  `st_long` into a wider table that contains `start` and `end` prices as 2 distinct variables (columns) for each stock and day. 

```{r stock_solution, echo = TRUE, fig.show = "hold"}
# library(tidyverse)

## (a) Enter stock data (in wide format) as a tibble:
st <- tribble(
  ~stock, ~d1_start, ~d1_end, ~d2_start, ~d2_end, ~d3_start, ~d3_end,  
  #-----|----------|--------|----------|--------|----------|--------|
  "Amada",   2.5,     3.6,    3.5,       4.2,      4.4,       2.8,            
  "Betix",   3.3,     2.9,    3.0,       2.1,      2.3,       2.5,  
  "Cevis",   4.2,     4.8,    4.6,       3.1,      3.2,       3.7     
)
dim(st)

## Note data structure: 
## 2 nested factors: day (1 to 3), type (start or end).

## (b) Change from wide to long format 
##     that contains the day (d1, d2, d3) and type (start vs. end) as separate columns:
st_long <- st %>%
  gather(d1_start:d3_end, key = "key", value = "val") %>%
  separate(key, into = c("day", "time")) %>%
  arrange(stock, day, time) # optional: arrange rows
st_long

## (c) Plot the end values (on the y-axis) of the 3 stocks over 3 days (x-axis):
st_long %>% 
  filter(time == "end") %>%
  ggplot(aes(x = day, y = val, color = stock, shape = stock)) +
  geom_point(size = 4) + 
  geom_line(aes(group = stock)) +
  ## Pimping plot: 
  labs(title = "End prices of stocks", 
       x = "Day", y = "End price", 
       shape = "Stock:", color = "Stock:") +
  theme_bw()

## (d) Change st_long into a wider format that lists start and end as 2 distinct variables (columns):
st_long %>%
  spread(key = time, value = val) %>%
  mutate(day_nr = parse_integer(str_sub(day, 2, 2))) # optional: get day_nr as integer variable
```

# Exercises (WPAxx)

## Exercise X:

- Using `reshape` to transform data (with multiple DVs and multiple measurements) from wide to long format:

A general problem and 2 solutions: 
Transform data (with multiple DVs and measurements per DV) from wide into long format:

```{r reshape_test_and_solutions, echo = TRUE, eval = TRUE}
## A very general problem: 

## Setting:  We have a dataset in _wide_ format that contains 
## - multiple DVs (as columns), 
## - each of which has multiple measurements (columns).

## Goal: We want the same data in _long_ format (i.e., each DV in 1 column, 
##       but with additional qualifying variables that uniquely identify each value). 

## (0) Generate test data:
set.seed(101)

p1 <- sample(x = c(0, 1), size = 5, replace = TRUE)
p2 = ((p1 - 1) * -1)

# 5 subjects with 3 DVs each 2 times:
test_data_wide <- data.frame("subj" = 1:5,
                             "c1" = sample(x = c(TRUE, FALSE), size = 5, replace = TRUE),
                             "c2" = sample(x = c(TRUE, FALSE), size = 5, replace = TRUE),
                             "t1" = round(runif(5, min = 0, max = 3000), 1),
                             "t2" = round(runif(5, min = 0, max = 3000), 1),
                             "p1" = p1,
                             "p2" = p2)

test_data_wide

## 2 alternative strategies: -----

# (1) Base R solution: ---- 

# Using stats::reshape
test_data_long <- reshape(test_data_wide, 
                          varying = list(c = c("c1", "c2"),
                                         t = paste0("t", 1:2),
                                         p = paste0("p", 1:2)),
                          direction = "long",
                          v.names = c("choice", "time", "position"),  # to rename variables
                          timevar = "position",    # if position Zeitpunkt angibt (!)
                          idvar = "subj"           # otherwise added as new variable
                          )      

solution_long_1 <- test_data_long %>% arrange(subj, position)
solution_long_1

# (2) tidyverse solution: ---- 

# Problem: We have 3 sets of DVs, but can only specify 1 in gather command.
# Thus, we proceed in 2 steps:
# (A) Use gather 3 times (on each set of DVs) to generate 3 long tibbles.
# (B) Combine the relevant DVs from the 3 tibbles into 1 tibble.

# (A) Using tidyr::gather 3 times:
#    1. DV = choice variables (12 variables: dec_01:dec_09)
#    2. DV = position         (12 variables: task_number_1:task_number_12)
#    3. DV = time             (12 variables: pg_time_1:pg_time_12)
# Use a pipe with gather, mutate (to determine i_num as integer), and arrange

# => 3 separate tibbles in long format, each sorted the same way!

test_data_wide

# (a) c => choice:
test_long_c <- test_data_wide %>%
  gather(c1:c2, key = "source_item", value = "choice") %>% 
  arrange(subj) %>%
  mutate(i_char = substr(source_item, (nchar("c") + 1), nchar(source_item)), # i_num as character   
         i_num = as.integer(i_char)  # i_num as integer
         ) %>% 
  arrange(subj, i_num)
test_long_c

# (b) t => time:
test_long_t <- test_data_wide %>%
  gather(t1:t2, key = "source_item", value = "time") %>% 
  arrange(subj) %>%
  mutate(i_char = substr(source_item, (nchar("c") + 1), nchar(source_item)), # i_num as character   
         i_num = as.integer(i_char)  # i_num as integer
         ) %>% 
  arrange(subj, i_num)
test_long_t

# (c) p => position:
test_long_p <- test_data_wide %>%
  gather(p1:p2, key = "source_item", value = "position") %>% 
  arrange(subj) %>%
  mutate(i_char = substr(source_item, (nchar("c") + 1), nchar(source_item)), # i_num as character   
         i_num = as.integer(i_char)  # i_num as integer
         ) %>% 
  arrange(subj, i_num)
test_long_p

# (B) Slicing and dicing:
# - Start with main tibble test_long_c (copied to solution_2); 
# - Add additional columns (key variables) from test_long_t and test_long_p to it;  
# - Select relevant columns from solution_2.

## Use cbind.data.frame to paste 2 new columns to existing df: 
# test_tbl_1 <- test_long_c          # basic tibble
# test_col_1 <- test_long_t$time     # key column from test_long_t
# test_col_2 <- test_long_p$position # key column from test_long_t
# test_all <- cbind.data.frame(test_tbl_1, test_col_1, test_col_2) 
## => Problem: Changes names of new columns!

# Simpler: Just assign 2 new columns to existing tibble: 
test_all <- test_long_c  # start with basic tibble
test_all$time     <- test_long_t$time      # key column from test_long_t
test_all$position <- test_long_p$position  # key column from test_long_t

# Solution 2 by re-sorting variable columns:
solution_long_2 <- test_all %>%
  select(subj, position, choice, time)

# Check equality of solutions:
s1 <- as_tibble(solution_long_1)  # turn into tibble (to adjust variable types)
s2 <- as_tibble(solution_long_2)
all.equal(s1, s2)  # TRUE (qed).
```

## Exercise Y:

- Plotting one DV against many others: See and explain how this works... 

```{r explain_gather_plot,  echo = TRUE, eval = TRUE}
# From https://www.r-bloggers.com/plot-some-variables-against-many-others-with-tidyr-and-ggplot2/ 

# Showing 1 DV (mpg) and 2 more factor variables (hp and cyl): 
mtcars %>%
  gather(-mpg, -hp, -cyl, key = "var", value = "value") %>% 
  ggplot(aes(x = value, y = mpg, color = hp, shape = factor(cyl))) +
    geom_point() +
    facet_wrap(~var, scales = "free") +
    theme_bw()

# variant with only 1 DV (mpg): 
mtcars %>%
  gather(-mpg, key = "var", value = "value") %>% 
  ggplot(aes(x = value, y = mpg)) +
    geom_point(alpha = 1/2) +
    geom_smooth(alpha = 1/4) +
    facet_wrap(~var, scales = "free") +
    theme_bw()

# Step by step: 
as_tibble(mtcars)  # 32 x 11

mtcars %>%
  gather(key = "var", value = "value")  # 32 x 11 single values

mtcars %>%
  gather(-mpg, key = "var", value = "value")  # 32 x 11 single values

mtcars %>%
  gather(-mpg, -hp, -cyl, key = "var", value = "value")
```

## More on tidy data

- Study the vignette on `vignette("tidy-data")` and the [RStudio cheatsheet](https://www.rstudio.com/resources/cheatsheets/) on _Data Import_ for essential `tidyr` commands. 

- Read [Chapter 12: Tidy data](http://r4ds.had.co.nz/tidy-data.html) and complete its exercises.

- For background information on the notion of tidy data, see  
Wickham, H. (2014). Tidy data. _Journal of Statistical Software_, _59_(10), 1--23.  
available at <http://www.jstatsoft.org/v59/i10/paper>. 

- Follow the links on <https://tidyr.tidyverse.org.> for additional information. 


# Conclusion

<!-- Table with links: -->

All [ds4psy](http://rpository.com/ds4psy/) essentials so far: 

Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | [Transforming data](http://rpository.com/ds4psy/essentials/transform.html) |
4.  | [Exploring data (EDA)](http://rpository.com/ds4psy/essentials/explore.html) | 
5.  | [Tibbles](http://rpository.com/ds4psy/essentials/tibbles.html) |
6.  | [Tidy data](http://rpository.com/ds4psy/essentials/tidy.html) | 
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 

<!--
Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | [Transforming data](http://rpository.com/ds4psy/essentials/transform.html) |
4.  | [Exploring data (EDA)](http://rpository.com/ds4psy/essentials/explore.html) | 
5.  | [Tibbles](http://rpository.com/ds4psy/essentials/tibbles.html) |
6.  | [Tidy data](http://rpository.com/ds4psy/essentials/tidy.html) |
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 
-->

[Last update on `r Sys.time()` by [hn](http://neth.de/).]  

<!-- eof. --> 