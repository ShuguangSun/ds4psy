---
title: "Importing files, with solutions (ds4psy)"
author: "Hansjörg Neth, SPDS, uni.kn"
date: "2019 01 10"
output:
   rmdformats::html_clean: # html_clean html_docco readthedown material #
     code_folding: show # hide
     toc_float: true
     toc_depth: 3
     highlight: default # textmate default kate haddock monochrome #
     lightbox: true # true by default
     fig_width: 7 # in inches
editor_options: 
  chunk_output_type: console # inline
---

<!-- Example of essential commands | ds4psy: Winter 2018 -->

```{r preamble, echo = FALSE, eval = TRUE, cache = FALSE, message = FALSE, warning = FALSE}
## (a) Housekeeping: -----
rm(list=ls()) # clean all.

## (b) Current file name and path: ----- 
# my_path <- dirname(rstudioapi::getActiveDocumentContext()$path)
# my_path
# setwd(my_path) # set to current directory
setwd("~/Desktop/stuff/Dropbox/_code/R/_teachR/ds4psy/_essentials") # set to current directory
# list.files() # all files + folders in current directory
fileName <- "import.Rmd"

## (c) Packages: ----- 
library(knitr)
library(rmdformats)
library(tidyverse)

## (d) Global options: ----- 
options(max.print = "75")
opts_chunk$set(echo = TRUE,
	             cache = TRUE,
               prompt = FALSE,
               tidy = FALSE,
               collapse = TRUE, # set TRUE in answers 
               comment = "#>",
               message = FALSE,
               warning = FALSE,
               ## Default figure options:
               fig.width = 7, 
               fig.asp = .618, # golden ratio
               out.width = "75%",
               fig.align = "center"
               )
opts_knit$set(width = 75)

## (e) Custom functions: ----- 
source(file = "~/Desktop/stuff/Dropbox/_code/R/_teachR/ds4psy/R/custom_functions.R")
```

# Introduction

This file contains **essential commands** from [Chapter 11: Data import](https://r4ds.had.co.nz/data-import.html) of the textbook [r4ds](http://r4ds.had.co.nz) and corresponding examples and exercises. A command is considered "essential" when you really need to _know_ it and need to know _how to use_ it to succeed in this course. 

<!-- Table with links: -->

All [ds4psy](http://rpository.com/ds4psy/) essentials so far: 

Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | [Transforming data](http://rpository.com/ds4psy/essentials/transform.html) |
4.  | [Exploring data (EDA)](http://rpository.com/ds4psy/essentials/explore.html) | 
5.  | [Tibbles](http://rpository.com/ds4psy/essentials/tibbles.html) |
6.  |  **Importing data** |
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 

<!--
Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | [Transforming data](http://rpository.com/ds4psy/essentials/transform.html) |
4.  | [Exploring data (EDA)](http://rpository.com/ds4psy/essentials/explore.html) | 
5.  | [Tibbles](http://rpository.com/ds4psy/essentials/tibbles.html) |
6.  | [Importing data](http://rpository.com/ds4psy/essentials/import.html) |
7.  | [Tidying data](http://rpository.com/ds4psy/essentials/tidy.html) |
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 
-->

## Course coordinates

<!-- uni.kn logo and link to SPDS: -->  
<!-- ![](./inst/pix/uniKn_logo.png) --> 
<a href="https://www.spds.uni-konstanz.de/">
<img src = "../inst/pix/uniKn_logo.png" alt = "spds.uni.kn" align = "right" width = "300" style = "width: 300px; float: right; border:20;"/>
<!-- <img src = "./inst/pix/uniKn_logo_s.png" alt = "spds.uni.kn" style = "float: right; border:20;"/> --> 
</a>

* Taught at the [University of Konstanz](https://www.uni-konstanz.de/) by [Hansjörg Neth](http://neth.de/) (<h.neth@uni.kn>,  [SPDS](https://www.spds.uni-konstanz.de/), office D507).
* Winter 2018/2019: Mondays, 13:30--15:00, C511. 
* Links to current [course syllabus](http://rpository.com/ds4psy/) | [ZeUS](https://zeus.uni-konstanz.de/hioserver/pages/startFlow.xhtml?_flowId=detailView-flow&unitId=5101&periodId=78&navigationPosition=hisinoneLehrorganisation,examEventOverviewOwn) |  [Ilias](https://ilias.uni-konstanz.de/ilias/goto_ilias_uni_crs_809936.html) 


## Preparations

Create an R script (`.R`) or an R-Markdown file (`.Rmd`) and load the R packages of the `tidyverse`. (**Hint:** Structure your script by inserting spaces, meaningful comments, and sections.) 

```{r layout_template, echo = TRUE, eval = FALSE}
## Importing data | ds4psy
## 2018 12 17
## ----------------------------

## Preparations: ----------

library(tidyverse)

## 1. Topic: ----------

# etc.

## End of file (eof). ----------  
```

To use [R Markdown](https://rmarkdown.rstudio.com), create a corresponding file and save it with the `.Rmd` extension (e.g., by selecting `File > New File > R Markdown`). 
For instructions on combining text and code, see [Chapter 27: R Markdown](https://r4ds.had.co.nz/r-markdown.html) of our textbook, or use one of the following templates:  

- minimal template:  `rmd_template_s` [in [.Rmd](http://rpository.com/down/temp/rmd_template_s.Rmd) | [.html](http://rpository.com/down/temp/rmd_template_s.html) format]

- medium template: `rmd_template_m` [in [.Rmd](http://rpository.com/down/temp/rmd_template_m.Rmd) | [.html](http://rpository.com/down/temp/rmd_template_m.html) format]

- explicit explanations: `Rmarkdown_basics` [in [.Rmd](http://rpository.com/down/temp/Rmarkdown_basics.Rmd) | [.html](http://rpository.com/down/temp/Rmarkdown_basics.html) format]

**Hint:** Try to _knit_ your `.Rmd` file immediately after saving it and marvel at the beauty of the resulting `.html`-file. If this works, keep doing this routinely from now on, putting all your R-code into code chunks, and any text (like headings or conclusions) that describes or explains what you are doing outside of them. From now on, you can share your `.html` output files, rather than your `.Rmd` source files when showing off your R and data science skills.


# Importing data

Where does data (e.g., a _data frame_ or _tibble_) come from? If we don't enter it ourselves (e.g., with the `tibble` or `tribble` commands (see our session on [Tibbles](http://rpository.com/ds4psy/essentials/tibbles.html)) we usually import it from an external source. The scope of such sources is vast and here we only cover the most common candidates: Data that is already stored in text form or other file formats that can easily be coerced into linear or rectangular data structures. 

This session discusses options and potential pitfalls when using the tidyverse package `readr` for data import. `readr` provides a fast and friendly way to read vectors and rectangular data files (like `csv`, `tsv`, and `fwf`).

## File names and paths

An important pre-requisite to loading data is that we are able to orient ourselves on our computer and can navigate or point to the location at which data files may be stored. Two important questions to ask and answer prior to reading or writing data is: 

- Where am I?  
- Where is my data?  

#### Working directory

The 1st questions ("Where am I?") addresses the notion of the current _working directory_. 
This is typically the directory on your computer in which you started your R environment, the location of your current R script, or -- if you're working with [RStudio](https://www.rstudio.com/) _projects_ -- the home directory of your current project. Use the function `getwd` to find out your current working directory:  

```{r getwd}
# Get current working directory (wd):
my_wd <- getwd()
my_wd 
```

Note that `getwd` function returns a character string and -- depending on your operating system -- uses either forward slashes (`/`) or backward slashes (`\`) to separate the hierarchy levels of different directories. This character string represents the address of your current working directory.

Corresponding to `getwd`, the function `setwd` (with its only argument `dir` specifying a string that points to an existing location on your computer) allows changing your current working directory to `dir`:

```{r setwd}
# Set current working directory:
setwd(dir = my_wd)  # set dir to my_wd (set above)  
getwd()             # same dir (as set to my_wd)
```

And `list.files()` provides a list of all files and directories in the current working directory:

```{r list.files, eval = FALSE}
# List files and directories: 
list.files()       # in current working directory
list.files(my_wd)  # in some specific directory
```

#### File paths

The 2nd question ("Where is my data?") implies that data doesn't necessarily need to be stored at the same location as our current working directory. Let's suppose that we want to load some data file (called `data_t1.csv`), which we  downloaded from an online source at <http://rpository.com/ds4psy/data/data_t1.csv>. But rather than saving it in our current working directory `my_wd`, the file `data_t1.csv` is stored in some parallel directory (called `data`). 
In this case, there are 2 principle ways to load our data file:

1. Change our current working directory to the data directory: 

```{r}
# (1) Changing working directory to load data: 

# Get working directory:
my_wd <- getwd()
my_wd  # prints the current wd:

# Change current working directory: 
setwd("/Users/hneth/Desktop/stuff/Dropbox/_code/R/_teachR/ds4psy/data")
getwd()

# Read data from the NEW working directory: 
t1 <- read_csv("data_t1.csv")  # read csv data file

# Return to the original working directory: 
setwd(my_wd)  # setwd to original directory
getwd()       # back in my_wd
```

2. Keep our current working directory, but read the data from a different directory:

```{r}
# (2) Reading data from another directory:

# (a) provide absolute/full path of the data file:
t2 <- read_csv("/Users/hneth/Desktop/stuff/Dropbox/_code/R/_teachR/ds4psy/data/data_t1.csv")

# (b) provide relative path of the data file:
t3 <- read_csv("./../data/data_t1.csv")

# (c) relative to (platform dependent) home directory:
t4 <- read_csv("~/Desktop/stuff/Dropbox/_code/R/_teachR/ds4psy/data/data_t1.csv")

# (d) provide path to an online source of the data file:
t0 <- read_csv("http://rpository.com/ds4psy/data/data_t1.csv")
```

We see that there are many different ways of pointing to the location of a data file. Due to this flexibility, it's typically best to not change our working directory to load data, but rather reading the file from a different directory. 
Let's verify that all of the above methods actually loaded the same data:

```{r}
# Check whether t0 to t4 are all equal:
all.equal(t0, t1) & 
all.equal(t1, t2) & 
all.equal(t2, t3) & 
all.equal(t3, t4)
```

### Sharing scripts and data files

To share your R scripts and data files with others it is best to work with an [RStudio](https://www.rstudio.com/) _project_ and store all scripts and files within this project. Alternatively, keep all your R scripts in a specific directory (e.g., called `R`), and read all data files from either the same or some dedicated data directory (e.g., `data`). Importantly, using only _relative_ file paths (i.e., relative to the current script or to the project's working directory) also allows transferring your scripts and data files. By archiving your entire project folder (e.g., as `my_project.zip`, or a folder that includes the subfolders `R` and `data`), you can transfer your archive to another person or computer and the scripts will keep working. 


## Parsing vectors

The process of reading some data structure is known as _parsing_. We usually want to parse entire files of data. However, as our data files typically consist of columns of variables, we also need to consider how individual vectors are parsed.

We only cover the most common `parse` commands here (see [11.3 Parsing a vector](https://r4ds.had.co.nz/data-import.html#parsing-a-vector) for details).  

The `parse_` functions provided by `readr` take a _character_ vector as their main input argument and return a more specialised vector (e.g., logical, integer, or date) as output vector. Some examples are: 

```{r}
# Parse logical values:
v1 <- parse_logical(c("TRUE", "FALSE", "NA", "TRUE"))
v1
str(v1)

# Parse integers:
v2 <- parse_integer(c("1", "2", "3", "NA", "5"))
v2
str(v2)

# Parse doubles:


# Parse dates: 
v3 <- parse_date(c("2018-12-17", "2018-12-24", "NA", "2018-12-31"))
v3
str(v3)
```

A uniform `na` argument allows specifying which string should be treated as missing data: 
  
```{r}
parse_integer(c("12", "34", "?", "78"), na = "?")
```

If the process of parsing fails for an element, a _warning_ is issued and the problematic element is missing (`NA`) in the output vector:

```{r}
v4 <- parse_integer(c("12", "34", "xy", "78"))
v4
```

We can use `problems()` on the parsed vector to see which problems occurred during parsing:

```{r}
problems(v4)
```

The range of important parsers matches the range of data types that we typically deal with. Important parsers include the following:

1. `parse_logical()` parses logical values (`TRUE` vs. `FALSE`); 

2. `parse_integer()` parses integer numbers (`r 1:3`, etc.); 

3. `parse_double()` is a strict numeric parser; 

```{r}
parse_double(as.character(1:3))
parse_double(c("1.23", "3.14"))
```

When using a _decimal mark_ different from "." (used in the U.S.) we need to specify this by providing the `locale` argument: 

```{r}
parse_double(c("1,23", "3,14"))  # issues a warning

parse_double(c("1,23", "3,14"), locale = locale(decimal_mark = ","))  # works
```

4. `parse_number()` is a more flexible numeric parser, which ignores prefixes and postfixes, but only reads the first number of a character string:

```{r}
parse_number(c("1%", "is less than 2%", "and 3% is less than 4%"))
```

In addition, `parse_number` allows specifying both a `decimal_mark` and `grouping_mark` in its `locale` argument for reading country-specific number formats: 

```{r}
# Used in the US: 
parse_number("$1,000.99")

# Used in Germany (and the EU): 
parse_number("EUR1.000,99", locale = locale(decimal_mark = ",", grouping_mark = "."))

# Used in Switzerland:
parse_number("CHF1'000,99", locale = locale(decimal_mark = ",", grouping_mark = "'"))
```

5. `parse_character()` seems trivial, but allows dealing with different character encodings:

```{r}
parse_character(c("très difficile", "mon chérie"), 
                locale = locale(encoding = "UTF-8"))
parse_character("\x82\xb1\x82\xf1\x82\xc9\x82\xbf\x82\xcd", 
                locale = locale(encoding = "Shift-JIS"))

french <- "très difficile"
parse_character(french, locale = locale(encoding = "UTF-8"))
guess_encoding(charToRaw("très difficile"))
```

6. `parse_factor()` creates factors, a data structure often used to represent categorical variables with fixed and known values (e.g., the different conditions or treatment levels of an experiment): 

```{r}
treatments <- c("therapy", "medication", "placebo")  # define factor levels

parse_factor(c("medication", "placebo", "therapy", "medication"), levels = treatments)
```

7. `parse_datetime()`, `parse_date()`, and `parse_time()` allow parsing various date and time specifications.

```{r}
# Current date and time:
Sys.Date()
Sys.time()

parse_date(c("2018-12-17", "2018-12-24", "2018-12-31"))
parse_datetime("2018-12-17 07:38:01", locale = locale("de"))
```

Reading dates and times often requires specifying the details of the current date-time `format` (see the documentation to `?parse_datetime` for details). 

In R, _dates_ are typically represented by a 4-digit year (`%Y`), a 2-digit month (`%m`), and a 2-digit day (`%d`), all separated by either "-" or "/":

```{r}
parse_date("2018/12/10")
parse_date("2018-12-10")
```

Note the ambiguity of a date string like `"2018-12-10"` (in which month and day could be confused) or even `"08/10/12"` (in which even the year is unclear):

```{r}
# When was "2018-12-10"?
parse_date("2018-12-10", format = "%Y-%m-%d")
parse_date("2018-12-10", format = "%Y-%d-%m")

# When was "08/10/12"?
parse_date(c("08/10/12"), "%d/%m/%y")
parse_date(c("08/10/12"), "%m/%d/%y")
parse_date(c("08/10/12"), "%y/%m/%d")
parse_date(c("08/10/12"), "%y/%d/%m")
```

## Parsing files

The difficulty of loading a data file depends on the sensibility of whoever saved it. 
If the originator of the file used a file format that is universal and easily exchanged (e.g., a `csv` file in a common encoding format), reading the data into R -- or any other data analysis software -- should be no problem. Unfortunately, however, many people still insist on saving and sending specialized or proprietary file formats (e.g., `xls` or `sav` files). 

In the following, we outline some basic methods of reading files that should cover 95% of all cases and provide pointers to resources that allow dealing with the remaining 5%. 

### 1. `read_csv`

A common and sensible file format for data separates variables (columns) by commas, which is why it is called a _comma separated value_ (or `csv`) file. The best way to read such files within the `tidyverse` is by using the command `read_csv`. 
We have used this command many times before (e.g., to read in <http://rpository.com/ds4psy/data/data_t1.csv> above):

```{r read_csv}
## Read a csv file: 

# 1. From a different directory:

# (a) provide absolute/full path:
dt <- read_csv("/Users/hneth/Desktop/stuff/Dropbox/_code/R/_teachR/ds4psy/data/data_t1.csv")

# (b) provide relative path of the data file:
dt <- read_csv("./../data/data_t1.csv")

# (c) relative to (platform dependent) home directory:
dt <- read_csv("~/Desktop/stuff/Dropbox/_code/R/_teachR/ds4psy/data/data_t1.csv")

# 2. From an online source:

# (d) provide path to an online source of the data file:
dt <- read_csv("http://rpository.com/ds4psy/data/data_t1.csv")
```

Actually, base R also provides a function `read.csv()` to achieve the same thing:

```{r}
df <- read.csv("./../data/data_t1.csv")
```

However, note that the objects resulting from our calls of `read_csv` and `read.csv` (i.e., `dt` and `df`, respectively) are similar, but not identical:

```{r}
# Differences: 
class(dt)  # read_csv yields a tibble 
class(df)  # read.csv yields a data.frame 

all.equal(dt, df)  

# => df converted chracter to factors, unless: 
df <- read.csv("./../data/data_t1.csv", stringsAsFactors = FALSE)

all.equal(dt, df) 
```

### 2. Variants (`read_csv2` and `read_tsv`): 

```{r, eval = FALSE, echo = FALSE}
write_delim(x = dt, 
            path = "./../data/data_t1_de.csv", 
            delim = "; ")

write_delim(x = dt, 
            path = "./../data/data_t1_tab.csv", 
            delim = "\t")

read_csv2("./../data/data_t1_de.csv")
read.csv2("./../data/data_t1_de.csv")
```

In many countries (e.g., European countries like Germany), commas (`,`) are used as a _decimal mark_ (e.g., "pi is close to 3,1416.") and hence are not a good separator for variables (columns). In these locations, variables are typically separated by semi-colons (`;`). For such files, both `readr` and base R provide variants of the above commands that follow this convention. For instance, to read in the file <http://rpository.com/ds4psy/data/data_t1_de.csv> we can use: 

```{r}
read_csv2("http://rpository.com/ds4psy/data/data_t1_de.csv")
read.csv2("http://rpository.com/ds4psy/data/data_t1_de.csv")
```

Sometimes, the variables (columns) of a data file are separated by tabs (`\t`), which prompts the use of `read_tsv`. 
To read in <http://rpository.com/ds4psy/data/data_t1_tab.csv> we use: 

```{r}
read_tsv("http://rpository.com/ds4psy/data/data_t1_tab.csv")
```

### 3. `read_delim`

All the `read_` commands encountered so far are special instances of the more general `read_delim()` function, which reads delimited files into a tibble and allows specifying various additional arguments. 

```{r create_data_delim, echo = FALSE, eval = FALSE}
# (1) Create data (with NA values): 
set.seed(2)
n <- 100
v1 <- random_symbols(n = n, set = LETTERS, len = 2)
v2 <- round(runif(n = n, min = 18, max = 88), 0)
v3 <- add_whats(vec = random_symbols(n = n, set = as.character(0:9), len = 8), 
                amount = .05, what = -99)  # add -99 as NA values

v4 <- add_whats(vec = random_symbols(n = n, set = c(letters, LETTERS), len = 6), 
                amount = .10, what = -77)  # add -77 as NA values

tbl_1 <- tibble(initials = v1,
                age = v2,
                tel = as.numeric(v3),
                pwd = v4)
tbl_1

# Writing out: 
write_delim(tbl_1, path = "../data/data_1.dat", delim = ".", na = "NA", col_names = FALSE)


# (2) Create data (without NA values): 
set.seed(3)
n <- 100
v1 <- random_symbols(n = n, set = LETTERS, len = 2)
v2 <- round(runif(n = n, min = 18, max = 80), 0)
v3 <- random_symbols(n = n, set = as.character(0:9), len = 4)
v4 <- random_symbols(n = n, set = c(letters, LETTERS), len = 6)

tbl_2 <- tibble(ini = v1,
                age = v2,
                tel = v3,
                pwd = v4)
tbl_2

# Writing out: 
write_delim(tbl_2, path = "../data/data_2.dat", delim = "$", na = "NA", col_names = FALSE)
```

Suppose we want to read a file like <http://rpository.com/ds4psy/data/data_1.dat>, which is known to include 4 variables:

- the `initials` of participants; 
- their `age`; 
- their `telephone` number; 
- their `pwd` to some account. 

Inspecting the file shows the following:

1. The data is delimited, but by a full stop (aka. point or period, i.e., `.`) rather than by a comma or semi-colon. 
As a consequence, we need to use `read_delim` and explicitly specify the delimiting symbol as `"."`.

2. As the file does not include variable names (in the first row), we provide them with the `col_names` argument (which accepts a vector of characters).

3. Some lines are shorter than most others.  Close inspection reveals that they include either `-99` or `-77`. As these symbols are frequently used to express missing values, we supply them to the `na` argument (again as a vector of characters).


```{r read_data_delim}
# Path to file:
my_file <- "../data/data_1.dat"                           # from local directory
my_file <- "http://rpository.com/ds4psy/data/data_1.dat"  # from online source

# read_delim: 
data_1 <- read_delim(my_file, delim = ".", 
                     col_names = c("initials", "age", "tel", "pwd"), 
                     na = c("-77", "-99"))

dim(data_1)  # 100 observations, 4 variables
glimpse(data_1)
sum(is.na(data_1))  # 15 NA values
```

### 4. `read_fwf`

Sometimes we know the positions of variables in a data file. 
If this is the case, we can use the command `read_fwf` (with "fwf" standing for _fixed-width files_) and specify the positions of the variables (provided that they are the same for all rows). For instance, the file at 
<http://rpository.com/ds4psy/data/data_2.dat> contains the same variables as the previous file (`data_1`), but does not include missing values and can therefore be read in the following way:

```{r create_data_fwf}
# Path to file:
my_file_path <- "../data/data_2.dat"                           # from local directory
my_file_path <- "http://rpository.com/ds4psy/data/data_2.dat"  # from online source

# read_fwf: 
data_2 <- read_fwf(my_file_path, 
                   fwf_cols(initials = c(1, 2), 
                            age = c(4, 5), 
                            tel = c(7, 10), 
                            pwd = c(12, 17)))

dim(data_2)  # 100 4
glimpse(data_2)
```

```{r check_equality, echo = FALSE, eval = FALSE}
# (1) Check equality: 
all.equal(tbl_1, data_1)

# Hypothesis: Differences come from different NA encodings.

# Recode -99 and -77 in tbl_1 as NA:
tbl_1[tbl_1 == -99] <- NA
tbl_1[tbl_1 == "-77"] <- NA
sum(is.na(tbl_1))

# Check equality: 
all.equal(tbl_1, data_1)  # TRUE (qed).

# (2) Check equality: 
all.equal(tbl_2, data_2)
```

## Writing files

To write a data file to a local directory, use one of the following `readr` commands (from more general to more specific): 

```{r}
write_csv(data_1, path = "../data/data_1a.csv")
write_tsv(data_1, path = "../data/data_1a.tsv")
write_delim(data_1, path = "../data/data_1a.txt", delim = " ", na = "NA", col_names = TRUE)
```

Alternatively, base R provides the following options (and note that the `path` argument from above is named `file` here):

```{r}
write.csv(data_1, file = "../data/data_1b.csv")
write.csv2(data_1, file = "../data/data_1b.csv2")
write.table(data_1, file = "../data/data_1b.txt", sep = "<>", na = "-777", col.names = TRUE) 
```

## Importing data from other programs

Sometimes it is necessary to import files stored in the proprietary format of other software packages.  

### For _rectangular_ data: 

#### From Excel (`xls`)

- The package `readxl` allows reading MS Excel files (both .xls and .xlsx).

#### From SPSS (`sav`)

- The package `haven` allows reading SPSS, Stata, and SAS files.

### For _hierarchical_ data: 

Use `jsonlite` for json, and `xml2` for XML. 



# Exercises (WPA06)

The solutions on these exercises are due on Thursday, January 10, 2019 (i.e., `2019-01-10`).

<!-- 

## Agenda

**ToDo:**

- Import the same table from different data formats (e.g., US vs. EU)

- Import a table with corrupt variables and values (e.g., "ten" as a number)

- Realize the limitations of rectangular data (e.g., multiple entries per cell, multiple dependent variables, etc.)

--> 

## Exercise 1

#### Navigating directories

1. Find out your current working directory and list all files and folders contained in it. 

```{r ex1_getwd, echo = TRUE, eval = FALSE}
my_wd <- getwd()   # store current working directory in my_wd
my_wd              # show (absolute) path to my_wd

list.files(my_wd)  # list files in this directory
```

2. Change your working directory to a different directory (e.g., a parallel directory `data` that is located on the same level as your current working directory) and list all the files and folders in the other directory.

```{r ex1_setwd, echo = TRUE, eval = FALSE}
other_dir <- "./../data"  # (relative) path to the other directory
setwd(other_dir)
getwd()       # verify new location
list.files()  # list all files here
```

3. Return to your original working directory, but list all files in the other (`data`) directory.

```{r ex1_setwd_back, echo = TRUE, eval = FALSE}
setwd(my_wd)  # return to previous my_wd
getwd()       # verify new location

list.files(my_wd)      # list files in my_wd  
list.files(other_dir)  # list files in other dir (using relative path)
```


## Exercise 2

#### Parsing dates and numbers

Look at your ID card and type your birthday as a string as it's written on the card (including any spaces or punctuation symbols). For instance, if you were Erika Mustermann (see <https://de.wikipedia.org/wiki/Personalausweis_(Deutschland)>) you would write the character string "12.08.1964". 

1. Use an appropriate `parse_` command to read this character string into R. 

2. Now read out the date in German (i.e., "12. August 1964") and use another command to parse this string into R. 

3. Use [Google Translate](https://translate.google.com/) to translate this character string into French, Italian, and Spanish and use appropriate R commands to parse these strings into R. 

**Hint:** Consult `vignette("locales")` for specifying languages. 

```{r birthday, echo = TRUE, eval = TRUE}
parse_date("12.08.1964", "%d.%m.%Y")

parse_date("12. August 1964", "%d. %B %Y", locale = locale("de"))

parse_date("12. août 1964", "%d. %B %Y", locale = locale("fr"))
parse_date("12. Agosto 1964", "%d. %B %Y", locale = locale("it"))
parse_date("12 de agosto de 1964.", "%d de %B de %Y.", locale = locale("es"))
```

4. Use a `parse_` command (with an appropriate `locale`) to parse the following character strings into the desired data format: 

- `"US$1,099.95"` as a number;
- `"EUR1.099,95"` as a number;

```{r ex2_4, echo = TRUE, eval = TRUE}
parse_number("US$1,099.95") 
parse_number("EUR1.099,95", locale = locale(grouping_mark = "."))
```


## Exercise 3

#### A read-write-read cycle

1. Read in the data in file <http://rpository.com/ds4psy/data/data_2.dat> into an R object `data_2`, but by using the command `read_delim` rather than by using `read_fwf` (as above). (**Hint:** The variable names should be the same as above, but inspect the file to see its delimiter.)

```{r ex3_1, echo = TRUE, eval = TRUE}
# Path to file:
my_file <- "../data/data_2.dat"                           # from local directory
my_file <- "http://rpository.com/ds4psy/data/data_2.dat"  # from online source

# read_delim: 
data_2 <- read_delim(my_file, delim = "$", 
                     col_names = c("initials", "age", "tel", "pwd")
                     )

dim(data_2)  # 100 observations, 4 variables
glimpse(data_2)
sum(is.na(data_2))  # 0 NA values
```

2. Store the data file as `data_2.csv` (a `csv` file that includes variable names) into a directory that is _not_ your current working directory.

```{r ex3_2, echo = TRUE, eval = TRUE}
write_csv(x = data_2, path = "../data/data_2.csv")
```

3. Now use a command to re-read the file `data_2.csv` back into an object `data_2b` and verify that `data_2` and `data_2b` are equal.

```{r ex3_3, echo = TRUE, eval = TRUE}
data_2b <- read_csv("../data/data_2.csv")

# Verify equality: 
all.equal(data_2, data_2b)
```


## Exercise 4

#### Reading data 

The following data files are variants of the data at <http://rpository.com/ds4psy/data/falsePosPsy_all.csv>:

- <http://rpository.com/ds4psy/data/ex1.dat>   
- <http://rpository.com/ds4psy/data/ex2.dat>  
- <http://rpository.com/ds4psy/data/ex3.dat>  
- <http://rpository.com/ds4psy/data/ex4.dat>  

See [Datasets: False positive psychology](http://rpository.com/ds4psy/essentials/datasets.html#false-positive-psychology) for details of this data. 

```{r ex4_file_paths}
# Relative paths to my local copies of the 4 data files:
ex1 <- "./../data/falsePosPsy/ex1.dat"
ex2 <- "./../data/falsePosPsy/ex2.dat"
ex3 <- "./../data/falsePosPsy/ex3.dat"
ex4 <- "./../data/falsePosPsy/ex4.dat"

# Online paths to all 4 data files:
ex1 <- "http://rpository.com/ds4psy/data/ex1.dat"  
ex2 <- "http://rpository.com/ds4psy/data/ex2.dat"  
ex3 <- "http://rpository.com/ds4psy/data/ex3.dat"  
ex4 <- "http://rpository.com/ds4psy/data/ex4.dat" 
```

1. Inspect file `ex1.dat` and read it in 2 ways (by using either the generic `read.csv` or the appropriate variant of `read_csv`). How do the data read differ from each other?

#### Inspection

The file `ex1.dat` uses a comma `,` as variable separator and point `.` as a decimal mark. Thus, it uses the data format common in North America (e.g., U.S.A.).

```{r ex4_ex1, echo = TRUE, eval = TRUE}
# a: ex1 is comma-separated: 
a_1 <- read.csv(ex1)
a_2 <- read_csv(ex1)

## Check:
# head(a_1)
# a_2

class(a_1)  # is a data frame
class(a_2)  # is a tibble

all.equal(as_tibble(a_1), a_2) # data is equal, 
# but variable types differ (integer vs. numeric; factor vs. character)
```


#### Notes

- `read.csv` is available without loading any extra packages (base R) and imports comma-separated data into a data.frame.

- `read_csv` belongs to the package `readr` which is part of the `tidyverse` and imports comma-separated data into a tibble. 


2. Inspect and import the dataset `ex2.dat` using appropriate command(s).


#### Inspection

The file `ex2.dat` uses a semi-colon `;` as variable separator and a comma `,` as decimal mark. Thus, it uses the data format common in many European countries (e.g., Germany).

```{r ex4_ex2, echo = TRUE, eval = TRUE}
# b: ex2 is separated by semi-colons (csv2):
b_1 <- read.csv(ex2, sep = ";", dec = ",")
b_2 <- read_csv2(ex2)

## Check:
# head(b_1)
# b_2

class(b_1)  # is a data frame
class(b_2)  # is a tibble

all.equal(as_tibble(b_1), b_2) # data is equal, 
# but variable types differ (integer vs. numeric; factor vs. character)

all.equal(a_1, b_1)  # data.frames are equal
all.equal(a_2, b_2)  # tibbles are equal
```


#### Notes 

- `read.csv` assumes by default that the symbol used to separate variables is a comma (`,`) and the symbol used as a decimal mark is a point/period/full stop (`.`). If different symbols (e.g., a semi-colon `;` and a comma `,`) are used as variable separator and decimal mark, respectively, this must be specified by providing the `sep` and `dec` arguments. 
- We cannot use the `readr` command `read_csv` here, as it assumes the same default symbols as `read.csv` and does not allow re-defining these symbols. However, its variant `read_csv2` is appropriate, as it assumes the symbols used here (i.e., `;` between variables and `,` as decimal mark) as its defaults. 

- Warnings when loading files, strange variable types, and errors in arithmetical operations often indicate that files have been read erroneously.

3. Inspect and import the dataset `ex3.dat` using appropriate command(s).

#### Inspection

The file `ex3.dat` uses `|` as variable delimiter/separator and `,` as decimal mark/separator. 

```{r ex4_ex3, echo = TRUE, eval = TRUE}
# With read.csv
c_1 <- read.csv(ex3, sep = "|", dec = ",")

# With readr: 
c_2 <- read_delim(ex3, delim = "|", locale = locale(decimal_mark = ","))

## Check:
# head(c_1)
# c_2

class(c_1)  # is a data frame
class(c_2)  # is a tibble

all.equal(as_tibble(c_1), c_2) # data is equal, 
# but variable types differ (integer vs. numeric; factor vs. character) 

all.equal(a_1, c_1)  # data.frames are equal
all.equal(a_2, c_2)  # tibbles are equal
```


#### Notes 

- The base R command `read.csv` -- by virtue of providing explicit `sep` and `dec` arguments -- is quite flexible to read in other character-delimited files. (However, the decimal mark must be either a comma or a point.)  

- By contrast, the `readr` commands `read_csv` and `read_csv2` expect specific defaults. When these are not met, `read_delim` can be used to read a wider range of character-delimited files. Specific decimal marks and grouping marks can be defined in the `locale` argument.  

4. Inspect and import the dataset `ex4.dat` using appropriate command(s). Specifically, note the encoding of the age variable (`aged365`) and check whether you can compute participants' average age (in years) after importing the data. 

#### Inspection

- The file `ex4.dat` uses a comma `,` as variable separator and point `.` as a decimal mark (i.e., U.S. style).  

- However, the columns `aged365` and `female` in `ex4.dat` are encoded as _character_ variables (as indicated by the quotation marks). 

```{r ex4_ex4, echo = TRUE, eval = TRUE}
# With read.csv:
d_1 <- read.csv(ex4)

# With read_csv:
d_2 <- read_csv(ex4)

## Check:
head(d_1)
d_2

class(d_1)  # is a data frame
class(d_2)  # is a tibble

all.equal(as_tibble(d_1), d_2) # data is equal, 
# but variable types differ (integer vs. numeric; factor vs. character) 

all.equal(a_1, d_1)  # data.frames differ in "female" variable: numeric vs. factor variable
all.equal(a_2, d_2)  # tibbles differ in "female" variable: numeric vs. character variable

# Compute the mean age of all participants
mean(d_1$aged365)  # works: 20.8 years
mean(d_2$aged365)  # works: 20.8 years
```

#### Notes 

- Despite being a character variable in `ex4.dat`, the variable `aged365` is _numeric_ in the data read in. This illustrates that both `read.csv` and `read_csv` aim to convert data into its appropriate type. This often works well, but can also lead to unexpected or undesired results. Here, the `female` variable cannot be converted into a numeric column (as it contains the word "female" in `ex4.dat`). This leads to its interpretation as a factor in the data.frame (when using `read.csv`) and as a character variable in the tibble (when using `read_csv`).

- To further control the class of variables when reading in the data, we can use the following variants of both commands:

```{r ex4_add, echo = TRUE, eval = TRUE}
# with read.csv:
e_1 <- read.csv(ex4, stringsAsFactors = FALSE)
as_tibble(e_1)  # => female is now a character variable.

# with read_csv: 
e_2 <- read_csv(ex4,
                col_types = cols(
                  study = col_integer(),
                  ID = col_integer(),
                  aged = col_integer(),
                  aged365 = col_double(),   # integer not possible
                  female = col_character(),
                  dad = col_integer(),
                  mom = col_integer(),
                  potato = col_integer(),
                  when64 = col_integer(),
                  kalimba = col_integer(),
                  cond = col_character(),
                  root = col_integer(),
                  bird = col_integer(),
                  political = col_integer(),
                  quarterback = col_integer(),
                  olddays = col_integer(),
                  feelold = col_integer(),
                  computer = col_integer(),
                  diner = col_integer()
                ))

all.equal(as_tibble(e_1), e_2)  # TRUE
```

## Exercise 5

#### Writing data

```{r ex5_create_data, echo = FALSE, eval = TRUE, message = FALSE, warning = FALSE}
## Re-create data tibble (in 3 ways):

# (a) Using tibble: ---- 
tbl_1 <- tibble(
  cond = c("64", "control", "potato"),  
  n = c(25, 22, 31), 
  mean_age = c(21.09, 20.80, 20.60), 
  youngest = c(18.30, 18.53, 18.18), 
  oldest = c(38.24, 27.23, 27.37), 
  feel_vyoung = c(0, 3, 1),
  feel_young = c(13, 15, 17),
  feel_neither = c(10, 3, 11),
  feel_old = c(2, 1, 2),
  feel_vold = c(0, 0, 0) )

# knitr::kable(tbl_1, caption = "Data entered (by using tibble).")

# (b) Using tribble: ---- 
tbl_2 <- tribble(~cond, ~n, ~mean_age, ~youngest, ~oldest,	
                 ~feel_vyoung, ~feel_young, ~feel_neither, ~feel_old,	~feel_vold,
                 #--------|----|------|------|------|---|---|---|---|---|
                 "64",	    25, 21.09, 18.30,	38.24,	0, 13, 10,  2,  0,
                 "control",	22,	20.80, 18.53,	27.23,	3, 15,  3,  1,  0,
                 "potato",	31,	20.60, 18.18,	27.37,	1, 17, 11,  2,  0 )

# knitr::kable(tbl_2, caption = "Data entered (by using tribble).")

# (c) Re-creating the data in tbl_1 from the original data: ---- 

# Import the dataset:
falsePosPsy_all <- read_csv(file = "http://rpository.com/ds4psy/data/falsePosPsy_all.csv")

# Create summary table:
tbl_org <- falsePosPsy_all %>%
  group_by(cond) %>%
  summarise(n = n(),
            mean_age = round(mean(aged365, na.rm = TRUE), digits = 2), 
            youngest = round(min(aged365, na.rm = TRUE), digits = 2),
            oldest = round(max(aged365, na.rm = TRUE), digits = 2),
            feel_vyoung = sum(feelold == 1),
            feel_young = sum(feelold == 2),
            feel_neither = sum(feelold == 3),
            feel_old = sum(feelold == 4),
            feel_vold = sum(feelold == 5)
            )
# knitr::kable(tbl_org, caption = "Same data re-created from raw data.")

## Verify identity:
# all.equal(tbl_1,  tbl_org)  # TRUE, except for different column types (numeric vs. integer).

## Check identity: 
# all.equal(tbl_1, tbl_org)   # same, except for type differences
# all.equal(tbl_1,  tbl_2)  # TRUE

summary <- tbl_1  # copy data
readr::write_csv(x = summary, path = "./../data/summary.csv")
```

In our previous session on [Tibbles: Exercise 4](http://rpository.com/ds4psy/essentials/tibbles.html#exercise-4) we created the following `summary` tibble in different ways (either directly by using `tibble` or `tribble`, or as a `dplyr` summary table from raw data): 

```{r show_summary_table}
knitr::kable(summary, caption = "Table: Age-related data from Simmons et al. (2011). [See Exercise 4 of our session on tibbles.]")
```

See [Datasets: False positive psychology](http://rpository.com/ds4psy/essentials/datasets.html#false-positive-psychology) for details of the underlying raw data. 

Imagine that you are trying to send this file to a friend who -- due to excessive demand for our course -- was unable to secure a spot in this course and ended up in a course on the "History of data science", whose members are encouraged to experiment with software products like MS Excel and SPSS.

1. Assuming that your friend is currently located in Troy, NY (i.e., in the USA), export the `summary` as a file that your friend can read with her software. 


#### Notes 

- Since our friend is supposed to be in the US, we use a `csv` file that adheres to the convention that variables are separated by commas (`,`) and the decimal mark is a point (`.`) -- which is the default setting of `readr::write_csv`.

- We write out the `csv` file to a separate `data` directory and specify its path and name relative to our current working directory. 

```{r ex5_1, echo = TRUE, eval = TRUE}
# (a) write_csv:
readr::write_csv(x = summary, path = "./../data/summary_a.csv")

# (b) write.csv:
write.csv(x = summary, file = "./../data/summary_b.csv", row.names = FALSE)

# (c) write.table:
write.table(x = summary, file = "./../data/summary_c.csv", row.names = FALSE, sep = ",", dec = ".")
```

2. Read back your file and verify that it contains the same information as your original `summary`.

```{r ex5_2, echo = TRUE, eval = TRUE}
summary_2a <- readr::read_csv(file = "./../data/summary_a.csv")
all.equal(summary, summary_2a)  # TRUE (except for numeric data types)

summary_2b <- read.csv(file = "./../data/summary_b.csv", stringsAsFactors = FALSE)
all.equal(summary, summary_2b)  # TRUE (except for numeric data types)

summary_2c <- read.csv(file = "./../data/summary_c.csv", stringsAsFactors = FALSE)
all.equal(summary, summary_2c)  # TRUE (except for numeric data types)
```

3. Now repeat both steps (i.e., writing and re-reading the `summary` data) under the assumption that your friend is located in Berlin, Germany.


#### Notes 

- Using a comma-separated value (`csv`) file is still the best choice. However, since our friend is supposed to be in Germany, we use a `csv2` file that adheres to the European convention that variables are separated by semi-colons (`;`) and the decimal mark is a comma (`,`) -- which is the default setting of `readr::write_csv2`.

- To signal the different file format to our friend, we'll use the file extension `.csv2`. 

```{r ex5_3, echo = TRUE, eval = TRUE}
## Writing data in csv2 format: ---- 

# (a) write_csv:
readr::write_delim(x = summary, path = "./../data/summary_a.csv2", delim = ";")

# (b) write.csv:
write.csv2(x = summary, file = "./../data/summary_b.csv2", row.names = FALSE)

# (c) write.table:
write.table(x = summary, file = "./../data/summary_c.csv2", row.names = FALSE, sep = ";", dec = ",")


## Reading data in csv2 format: ----

summary_3a <- readr::read_csv2(file = "./../data/summary_a.csv2")
all.equal(summary, summary_2a)     # TRUE (except numeric data types)

summary_3b <- read.csv2(file = "./../data/summary_b.csv2", stringsAsFactors = FALSE)
all.equal(summary, summary_3b)     # TRUE (except numeric data types)
all.equal(summary_2b, summary_3b)  # TRUE

summary_3c <- read.csv2(file = "./../data/summary_c.csv2", stringsAsFactors = FALSE)
all.equal(summary, summary_3c)     # TRUE (except numeric data types)
all.equal(summary_2c, summary_3c)  # TRUE
```

#### Notes 

- As it is simple and functional, the `readr` function `write_csv` provides good and safe options for exchanging files. 

- For more flexibility and potential complexity, it may be indicated to use `write_delim` or `write.table` (or one of many other functions).

- For the base R functions `write.csv` and `write.table` the default of the argument `row.names = TRUE`.  As we only want to use column names here, we specified `row.names = FALSE`. If we left this out, we would get an extra column that counts the rows from 1 to `nrow` (on normally does not hurt either). 

- Even though our friend can now read our data without problems, she should try to enroll into a real data science course at some point.


## Exercise 6

#### Variants of p_info 

In this exercise, we re-visit the participant data of [Datasets: Positive psychology](http://rpository.com/ds4psy/essentials/datasets.html#positive-psychology) that we have analyzed before. 

```{r ex6_create_data, echo = FALSE, eval = FALSE, cache = FALSE, message = FALSE, warning = FALSE}
## import data:
p_info <- read_csv(file = "http://rpository.com/ds4psy/data/posPsy_participants.csv")  # online
# dim(p_info)  # 295 x 6 

# p_info

# manipulate data file:
p_info$id[100] <- 99.9

p_info$intervention[p_info$intervention == 1] <- "signature strengths"
p_info$intervention[p_info$intervention == 2] <- "3 good things"
p_info$intervention[p_info$intervention == 3] <- "gratitude visit"
p_info$intervention[p_info$intervention == 4] <- "early memories (control)"

p_info$sex[p_info$sex == 2] <- "male"
p_info$sex[p_info$sex == 1] <- "female"

p_info$educ[p_info$educ == 1] <- "below year 12"
p_info$educ[p_info$educ == 2] <- "year 12"
p_info$educ[p_info$educ == 3] <- "vocational training"
p_info$educ[p_info$educ == 4] <- "BSc degree"
p_info$educ[p_info$educ == 5] <- "MSc/PhD degree"

# p_info

write.table(p_info, "./../p_info_2.dat", row.names = FALSE, sep = "|", dec = ",")
```

1. Load the data at <http://rpository.com/ds4psy/data/posPsy_participants.csv> into an R object `p_info` and compute participants' mean `age` by `intervention`, by `sex`, and by level of education (`educ`).

```{r ex6_p_info_1, echo = TRUE, eval = TRUE}
# Load data:
p_info <- read_csv(file = "http://rpository.com/ds4psy/data/posPsy_participants.csv")  # online

# Mean age by intervention:
p_info %>% 
  group_by(intervention) %>% 
  summarise(n = n(),
            mn_age = mean(age))

# Mean age by sex:
p_info %>% 
  group_by(sex) %>% 
  summarise(n = n(),
            mn_age = mean(age))

# Mean age by educ:
p_info %>% 
  group_by(educ) %>% 
  summarise(n = n(),
            mn_age = mean(age))
```

2. Download the file `p_info_2.dat` (located at <http://rpository.com/ds4psy/data/p_info_2.dat>) into a local directory (called `data`) and import it from there into an R object `p_info_2`.  (**Hint:** Inspect the file prior to loading it: What is different in this file?) 

#### Inspection

- The variables `intervention`, `sex` and `educ` were encoded as _integers_ before, but are now encoded as _character_ variables (or factors).  

- The variable `id` is encoded as a _double_, due to the value `100` being erroneously saved as `99,9` (with a comma as the decimal mark).  

```{r ex6_p_info_2, echo = TRUE, eval = TRUE}
# Downloaded http://rpository.com/ds4psy/data/p_info_2.dat into 
my_file <- "./../data/p_info_2.dat"

p_info_2 <- read_delim(file = my_file, delim = "|", locale = locale(decimal_mark = ","))
dim(p_info_2)

# Note: 
mean(p_info_2$id)  # => 147.999 [i.e., almost (295 + 1)/2]

# Note: If we omitted the locale = locale(decimal_mark = ","): 
p_info_2b <- read_delim(file = my_file, delim = "|")
mean(p_info_2b$id)  # => 151.0475, due to
p_info_2b$id[100]   # => 999 (rather than 100)
```

3. Recompute the mean `age` by `intervention`, by `sex`, and by level of education (`educ`). Are they the same as before? 

```{r ex6_p_info_3, echo = TRUE, eval = TRUE}
# Mean age by intervention:
p_info_2 %>% 
  group_by(intervention) %>% 
  summarise(n = n(),
            mn_age = mean(age))

# Mean age by sex:
p_info_2 %>% 
  group_by(sex) %>% 
  summarise(n = n(),
            mn_age = mean(age))

# Mean age by educ:
p_info_2 %>% 
  group_by(educ) %>% 
  summarise(n = n(),
            mn_age = mean(age))
```

#### Answer

The means are the same as before, but their order (in the resulting tibbles) is different, as character variables are listed in alphabetical order (unless the labels are defined as an ordered factor). 


# More on data import

For more details on importing data, 

- study the `vignette("readr")` and `vignette("locales")`;
- study <https://readr.tidyverse.org/> and its examples; 
- read [Chapter 11: Data import](https://r4ds.had.co.nz/data-import.html) and complete its exercises. 

See the R package [Datapasta](https://CRAN.R-project.org/package=datapasta) and its [vignette](https://cran.r-project.org/web/packages/datapasta/vignettes/how-to-datapasta.html) for a clipboard-based solution for cut-and-pasting data into [RStudio](https://www.rstudio.com/). 


# Conclusion

<!-- Table with links: -->

All [ds4psy](http://rpository.com/ds4psy/) essentials so far: 

Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | [Transforming data](http://rpository.com/ds4psy/essentials/transform.html) |
4.  | [Exploring data (EDA)](http://rpository.com/ds4psy/essentials/explore.html) | 
5.  | [Tibbles](http://rpository.com/ds4psy/essentials/tibbles.html) |
6.  |  **Importing data** |
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 


<!--
Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | [Transforming data](http://rpository.com/ds4psy/essentials/transform.html) |
4.  | [Exploring data (EDA)](http://rpository.com/ds4psy/essentials/explore.html) | 
5.  | [Tibbles](http://rpository.com/ds4psy/essentials/tibbles.html) |
6.  | [Importing data](http://rpository.com/ds4psy/essentials/import.html) |
7.  | [Tidying data](http://rpository.com/ds4psy/essentials/tidy.html) |
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 
-->

[Last update on `r Sys.time()` by [hn](http://neth.de/).]  

<!-- eof. --> 