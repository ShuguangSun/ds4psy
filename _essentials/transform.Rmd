---
title: "Transforming data, with solutions (ds4psy)"
author: "Hansjörg Neth, SPDS, uni.kn"
date: "2018 12 02"
output:
   rmdformats::html_clean: # html_clean html_docco readthedown material #
     code_folding: show # hide
     toc_float: true
     toc_depth: 3
     highlight: default # textmate default kate haddock monochrome #
     lightbox: true # true by default
     fig_width: 7 # in inches
editor_options: 
  chunk_output_type: console # inline
---

<!-- Example of essential commands | ds4psy: Winter 2018 -->

```{r preamble, echo = FALSE, eval = TRUE, cache = FALSE, message = FALSE, warning = FALSE}
## (a) Housekeeping: -----
rm(list=ls()) # clean all.

## (b) Current file name and path: ----- 
# cur.path <- dirname(rstudioapi::getActiveDocumentContext()$path)
# cur.path
# setwd(cur.path) # set to current directory
setwd("~/Desktop/stuff/Dropbox/_code/R/_teachR/ds4psy/_essentials") # set to current directory
# list.files() # all files + folders in current directory
fileName <- "transform.Rmd"

## (c) Packages: ----- 
library(knitr)
library(rmdformats)
library(tidyverse)

## (d) Global options: ----- 
options(max.print = "75")
opts_chunk$set(echo = TRUE,
	             cache = TRUE,
               prompt = FALSE,
               tidy = FALSE,
               collapse = TRUE, # set TRUE in answers 
               comment = "#>",
               message = FALSE,
               warning = FALSE,
               ## Default figure options:
               fig.width = 7, 
               fig.asp = .618, # golden ratio
               out.width = "75%",
               fig.align = "center"
               )
opts_knit$set(width = 75)

## (e) Custom functions: ----- 
source(file = "~/Desktop/stuff/Dropbox/_code/R/_teachR/ds4psy/R/custom_functions.R")
```


# Introduction

This file contains **essential commands** from [Chapter 5: Data transformation](https://r4ds.had.co.nz/transform.html) of the textbook [r4ds](http://r4ds.had.co.nz) and corresponding examples and exercises. 
A command is considered "essential" when you really need to _know_ it and need to know _how to use_ it to succeed in this course. 

<!-- Table with links: -->

All [ds4psy](http://rpository.com/ds4psy/) essentials so far: 

Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | **Transforming data** |
4.  | [Exploring data (EDA)](http://rpository.com/ds4psy/essentials/explore.html) | 
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 


<!--
Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | [Transforming data](http://rpository.com/ds4psy/essentials/transform.html) |
4.  | [Exploring data (EDA)](http://rpository.com/ds4psy/essentials/explore.html) | 
5.  | [Creating and using tibbles](http://rpository.com/ds4psy/essentials/tibble.html) |
6.  | [Tidying data](http://rpository.com/ds4psy/essentials/tidy.html) |
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 
-->

## Course coordinates

<!-- uni.kn logo and link to SPDS: -->  
<!-- ![](./inst/pix/uniKn_logo.png) --> 
<a href="https://www.spds.uni-konstanz.de/">
<img src = "../inst/pix/uniKn_logo.png" alt = "spds.uni.kn" align = "right" width = "300" style = "width: 300px; float: right; border:20;"/>
<!-- <img src = "./inst/pix/uniKn_logo_s.png" alt = "spds.uni.kn" style = "float: right; border:20;"/> --> 
</a>

* Taught at the [University of Konstanz](https://www.uni-konstanz.de/) by [Hansjörg Neth](http://neth.de/) (<h.neth@uni.kn>,  [SPDS](https://www.spds.uni-konstanz.de/), office D507).
* Winter 2018/2019: Mondays, 13:30--15:00, C511. 
* Links to current [course syllabus](http://rpository.com/ds4psy/) | [ZeUS](https://zeus.uni-konstanz.de/hioserver/pages/startFlow.xhtml?_flowId=detailView-flow&unitId=5101&periodId=78&navigationPosition=hisinoneLehrorganisation,examEventOverviewOwn) |  [Ilias](https://ilias.uni-konstanz.de/ilias/goto_ilias_uni_crs_809936.html) 

## Preparations

Create an R script (`.R`) or an R-Markdown file (`.Rmd`) and load the R packages of the `tidyverse`. (Hint: Structure your script by inserting spaces, meaningful comments, and sections.) 

```{r layout_template, echo = TRUE, eval = FALSE}
## Transforming data | ds4psy
## 2018 11 19
## ----------------------------

## Preparations: ----------

library(tidyverse)

## 1. Topic: ----------

# etc.

## End of file (eof). ----------  
```


# Transforming data

In the following, we assume that you have read and worked through [Chapter 5: Data transformation](https://r4ds.had.co.nz/transform.html).  
Based on this background, we examine some essential commands of `dplyr` in the context of examples. However, the `dplyr` package extends beyond this introduction -- and will appear again later (e.g., in [Chapter 13: Relational data](https://r4ds.had.co.nz/relational-data.html)). 


# Essential commands and examples 

Data transformation includes re-arranging, selecting, changing, or aggregating data. 

## Overview

When we have data in the form of a tibble or data frame, `dplyr` provides a range of simple tools to transform this data. Six essential `dplyr` commands are: 

1. `arrange` sorts cases (rows); 
2. `filter` selects cases (rows) by logical conditions; 
3. `select` selects and reorders variables (columns); 
4. `mutate` computes new variables (columns) and adds them to existing ones; 
5. `summarise` collapses multiple values of a variable (rows of a column) to a single one;  
6. `group_by` changes the unit of aggregation (in combination with `mutate` and `summarise`).  

Not quite as essential but still useful `dplyr` commands include:

- `slice` selects (ranges of) cases (rows) by number; 
- `rename` renames variables (columns) and keeps others; 
- `transmute` computes new variables (columns) and drops existing ones;
- `sample_n` and `sample_frac` draw random samples of cases (rows).

## Data

We save the `dplyr::starwars` data as a tibble `sw` and use it to illustrate the essential `dplyr` commands.

```{r starwars_data}
library(tidyverse)
sw <- dplyr::starwars

sw  # => A tibble: 87 rows (individuals) x 13 columns (variables)
```

Standard questions to ask of every new data file include:

- What are the _dimensions_ of the data file?

- How many _variables_ (columns) are there in `sw` and of which _type_ are they? 

- How many _missing_ (`NA`) values are there? 

```{r check_data}
## Data:
# sw

## Standard checks: ------ 
dim(sw)     # 87 x 13 variables
names(sw)   # variable names
glimpse(sw) #    

## Missing (NA) values: ------ 
sum(is.na(sw))      # 101 missing values
colSums(is.na(sw))  # missing by column (variable) 
```


### 1. `arrange` to sort rows

Using `arrange` sorts cases (rows) by putting specific variables (columns) in specific orders (e.g., ascending or descending):

```{r dplyr_arrange}
# Sort rows alphabetically (by name):
arrange(sw, name)

# The same command using the pipe:
sw %>%           # Note: %>% is NOT + (used in ggplot) 
  arrange(name) 

# Sort rows in descending order:
sw %>% 
  arrange(desc(name)) 

# Sort by multiple variables:
sw %>% 
  arrange(eye_color, gender, desc(height))

## Note: See 
# ?dplyr::arrange  # for more help and examples.
```

Note some details: 

- All basic `dplyr` commands can be called as `verb(data, ...)` or -- using the pipe from `magrittr` -- as `data %>% verb(...)` (see `vignette("magrittr")` for details).

- Variable names are unquoted. 

- The order of variable names (`x, y, ...`) specifies the _order_ or _priority_ of operations (first by `x`, then by `y`, etc.). 

**Practice:** Arrange the `sw` data in different ways, combining multiple variables and (ascending and descending) orders. 
Where are cases containing `NA` values in sorted variables placed?


### 2. `filter` to select rows

Using `filter` selects cases (rows) by logical conditions. It keeps all rows for which the conditions are `TRUE` and drops all rows for which the conditions are `FALSE` or `NA`.

```{r dplyr_filter}
# Filter to keep all humans:
filter(sw, species == "Human")

# The same command using the pipe:
sw %>%           # Note: %>% is NOT + (used in ggplot) 
  filter(species == "Human")

# Filter by multiple (additive) conditions: 
sw %>%
  filter(height > 180, mass <= 75)  # tall and light individuals

# The same command using the logical operator (&): 
sw %>%
  filter(height > 180 & mass <= 75)  # tall and light individuals

# Filter for a range of a specific variable:
sw %>%
  filter(height >= 150, height <= 165)  # (a) using height twice

sw %>%
  filter(between(height, 150, 165))     # (b) using between(...)

# Filter by multiple (alternative) conditions: 
sw %>%
  filter(homeworld == "Kashyyyk" | skin_color == "green")

# Filter cases with missing (NA) values on specific variables:
sw %>%
  filter(is.na(gender))

# Filter cases with existing (non-NA) values on specific variables:
sw %>%
  filter(!is.na(mass), !is.na(birth_year))

## Note: See 
# ?dplyr::filter  # for more help and examples.
```

Note some details:

- Separating multiple conditions by commas is the same as the logical AND (`&`). 

- Variable names are unquoted.

- The comma between conditions or tests (`x, y, ...`) means the same as `&` (logical AND), as each test results in a vector of Boolean values. 

- Unlike in base R, rows for which the condition evaluates to `NA` are dropped. 

- Additional filter functions include `near()` for testing numerical (near-)identity. 


**Practice:** Use `filter` on the `dplyr::starwars` data (`sw`) to select very diverse or narrow subsets of individuals. 
For instance, 

- which individual with blond hair and blue eyes has an unknown mass? 
- of which species are individuals that are over 2m tall and have brown hair?
- which individuals from Tatooine are not male (but may be `NA`)? 
- which individuals are neither male nor female OR heavier than 130kg? 

```{r dplyr_filter_ex, echo = FALSE, eval = FALSE}
sw %>%
  filter(hair_color == "blond", eye_color == "blue")

sw %>%
  filter(height > 200, hair_color == "brown")

sw %>%
  filter(homeworld == "Tatooine", (gender != "male" | is.na(gender)))

sw %>%
  filter((gender != "male" & gender != "female") | mass > 130)
```


### 3. `select` to select columns 

Using `select` selects variables (columns) by their names or numbers: 

```{r dplyr_select}
# Select 4 specific variables (columns) of sw:
select(sw, name, species, birth_year, gender)

# The same when using the pipe:
sw %>%           # Note: %>% is NOT + (used in ggplot) 
  select(name, species, birth_year, gender)

# The same when providing a vector of variable names: 
sw %>%
  select(c(name, species, birth_year, gender)) 

# The same when providing column numbers:
sw %>%
  select(1, 10, 7, 8) 

# The same when providing a vector of column numbers: 
sw %>%
  select(c(1, 10, 7, 8)) 

# Select ranges of variables with ":":
sw %>%
  select(name:mass, films:starships)

# Select to re-order variables (columns) with everything():
sw %>%
  select(species, name, gender, everything())

# Select variables with helper functions:
sw %>%
  select(starts_with("s"))

sw %>%
  select(ends_with("s"))

sw %>%
  select(contains("_"))

sw %>%
  select(matches("or"))

# Renaming variables:
sw %>%
  rename(creature = name, from_planet = homeworld)

## Note: See 
# ?dplyr::select  # for more help and examples. 
?dplyr::select_if  # for more help and examples. 
```

Note some details:

- `select` works both by specifying variable (column) _names_ and by specifying column _numbers_.

- Variable names are unquoted. 

- The sequence of variable names (separated by commas) specifies the _order_ of columns in the resulting tibble.

- Selecting and adding `everything()` allows re-ordering. 

- Various helper functions (e.g., `starts_with`, `ends_with`, `contains`, `matches`, `num_range`) refer to (parts of) variable names. 

- `rename` renames specified variables (without quotes) and keeps all other variables.

**Practice:** Use `select` on the `dplyr::starwars` data (`sw`) to select and re-order specific subsets of variables (e.g., all variables starting with "h", all even columns, all character variables, etc.).


### 4. `mutate` to compute new variables

Using `mutate` computes new variables (columns) from scratch or existing ones: 

```{r dplyr_mutate}
# Preparation: Save only a subset variables of sw as sws:   
sws <- select(sw, name:mass, birth_year:species) 
sws    # => 87 cases (rows), but only 7 variables (columns)

# Compute 2 new variables and add them to existing ones:
mutate(sws, id = 1:nrow(sw), height_feet = .032808399 * height)

# The same using the pipe:
sws %>%
  mutate(id = 1:nrow(sw), height_feet = .032808399 * height)

# Transmute commputes and only keeps new variables:
sws %>%
  transmute(id = 1:nrow(sw), height_feet = .032808399 * height)

# Compute variables based on multiple others (including computed ones):
sws %>%
  mutate(BMI = mass / ((height / 100)  ^ 2),  # compute body mass index (kg/m^2)
         BMI_low  = BMI < 18.5,               # classify low BMI values
         BMI_high = BMI > 30,                 # classify high BMI values
         BMI_norm = !BMI_low & !BMI_high      # classify normal BMI values 
         )

## Note: See 
# ?dplyr::mutate  # for more help and examples. 
```

Note some details:

- `mutate` computes new variables (columns) and adds them to existing ones, while `transmute` drops existing ones.

- Each `mutate` command specifies a new variable name (without quotes), followed by `=` and a _rule_ for computing the new variable from existing ones. 

- Variable names are unquoted. 

- Multiple `mutate` steps are separated by commas, each of which creates a new variable.

- See <http://r4ds.had.co.nz/transform.html#mutate-funs> for useful functions for creating new variables. 

**Practice:** Compute a new variable `mass_pound` from `mass` (in kg) and the age of each individual in `sw` relative to Yoda's age. (Note that the variable `birth_year` is provided in years BBY, i.e., Before Battle of Yavin.) 

```{r mutate_ex, echo = FALSE, eval = FALSE}
# sws

age_yoda <- sws %>%
  filter(name == "Yoda") %>%
  .$birth_year
age_yoda

sws %>% 
  mutate(mass_pound = mass/.45,
         age_since_yoda = age_yoda - birth_year) %>%
  select(name, mass, mass_pound, birth_year, age_since_yoda)
```

### 5. `summarise` to compute summaries

`summarise` computes a function for a specified variable and collapses the values of the specified variable (i.e., the rows of a specified columns) to a single value. It provides many different summary statistics by itself, but is even more useful in combination with `group_by` (discussed next). 

```{r dplyr_summarise}
# Summarise allows computing a function for a variable (column): 
summarise(sw, mn_mass = mean(mass, na.rm = TRUE))  # => 97.31 kg 

# The same using the pipe: 
sw %>%
  summarise(mn_mass = mean(mass, na.rm = TRUE))  # => 97.31 kg 

# Multiple summarise steps allow applying 
# different functions for 1 dependent variable: 
sw %>%
  summarise(n_mass = sum(!is.na(mass)), 
            mn_mass = mean(mass, na.rm = TRUE),
            md_mass = median(mass, na.rm = TRUE),
            sd_mass = sd(mass, na.rm = TRUE),
            max_mass = max(mass, na.rm = TRUE),
            big_mass = any(mass > 1000)
            )
            
# Multiple summarise steps also allow applying 
# different functions to different dependent variables: 
sw %>%
  summarise(# Descriptives of height:  
            n_height = sum(!is.na(height)), 
            mn_height = mean(height, na.rm = TRUE),
            sd_height = sd(height, na.rm = TRUE), 
            # Descriptives of mass:
            n_mass = sum(!is.na(mass)), 
            mn_mass = mean(mass, na.rm = TRUE),
            sd_mass = sd(mass, na.rm = TRUE),
            # Counts of character variables:
            n_names = n(), 
            n_species = n_distinct(species),
            n_worlds = n_distinct(homeworld)
            )

## Note: See 
# ?dplyr::summarise  # for more help and examples. 
```

Note some details:

- `summarise` collapses multiple values into one value and returns a new tibble with as many rows as values computed.

- Each `summarise` step specifies a new variable name (without quotes), followed by `=`, and a _function_ for computing the new variable from existing ones. 

- Multiple `summarise` steps are separated by commas. 

- Variable names are unquoted. 

- See <https://dplyr.tidyverse.org/reference/summarise.html> for examples and useful functions in combination with `summarise`. 


**Practice:** Apply _all_ summary functions mentioned in `?dplyr::summarise` to the `sw` dataset. 


### 6. `group_by` to aggregate variables

Using `group_by` does not change the data, but the _unit of aggregation_ for other commands, which is very useful in combination with `mutate` and `summarise`. 

```{r dplyr_group_by}
# Grouping does not change the data, but lists its groups: 
group_by(sws, species)  # => 38 groups of species

# The same using the pipe: 
sws %>%
  group_by(species)  # => 38 groups of species

# group_by is ineffective by itself, but very powerful 
# (a) in combination with `mutate` and 
# (b) in combination with `summarise`. 

# ad (a):
# In combination with mutate and an aggregation function, 
# group_by changes the unit of aggregation:

sws %>%
  mutate(mn_height_1 = mean(height, na.rm = TRUE)) %>%  # aggregates over ALL cases
  group_by(species) %>%
  mutate(mn_height_2 = mean(height, na.rm = TRUE)) %>%  # aggregates over current group (species)
  group_by(gender) %>%
  mutate(mn_height_3 = mean(height, na.rm = TRUE)) %>%  # aggregates over current group (gender)
  group_by(name) %>%
  mutate(mn_height_4 = mean(height, na.rm = TRUE))      # aggregates over current group (name)

# ad (b):
# group_by is particularly useful in combination 
# with summarise:

sws %>%
  group_by(homeworld) %>%
  summarise(count = n(),
            mn_height = mean(height, na.rm = TRUE),
            mn_mass = mean(mass, na.rm = TRUE)
            )

# Note that this pipe returns a new tibble, 
# with 49 rows (= different levels of homeworld) and 
# - 1 column of the group variable (homeworld) and 
# - 3 columns of the 3 newly summarised variables.


# group_by used with multiple variables yields a tibble 
# containing the combination of all variable levels: 
sw %>%
  group_by(hair_color, eye_color)  # => 35 groups (combinations)

# Counting the frequency of cases in groups:
sw %>%
  group_by(hair_color, eye_color) %>%
  count() %>%
  arrange(desc(n))  

# The same using summarise:
sw %>%
  group_by(hair_color, eye_color) %>%
  summarise(n = n()) %>%
  arrange(desc(n))  

## Note: See 
# ?dplyr::group_by  # for more help and examples. 
```

Note some details:

- `group_by` changes the unit of aggregation for other commands (`mutate` and `summarise`). 

- Variable names are unquoted.

- When using `group_by` with multiple variables, they are separated by commas. 

- Using `group_by` with `mutate` results in a tibble that has the same number of cases (rows) as the original tibble.  By contrast, using `group_by` with `summarise` results in a new tibble with all combinations of variable levels as its cases (rows). 

## Powerful pipes 

The essential `dplyr` commands are quite simple by themselves, but form the verbs of a language for basic data manipulation. These commands become particularly powerful when they are combined into _pipes_ (by using the `%>%` operator, as in the examples above). Stringing together several `dplyr` commands allows slicing and dicing data (tibbles or data frames) in a step-wise fashion to run non-trivial data analyses on the fly. For instance, pipes allow selecting and sorting sub-groups of data, computing descriptive statistics (n, mean, median, standard deviation, etc.), and answering detailed questions about specific variables. 

#### Examples 

Each of the following questions can be answered by a pipe of `dplyr` commands:

- What is the number and mean height and mass of individuals from Tatooine by species and gender? 

- Which humans are more than 5cm taller then the average human overall?

- Which humans are more than 5cm taller than the average human of their own gender?

```{r group_by_ex, echo = FALSE, eval = FALSE}
sws %>%
  filter(homeworld == "Tatooine") %>%
  group_by(species, gender) %>%
  summarise(count = n(),
            mn_height = mean(height),
            mn_mass = mean(mass, na.rm = TRUE)
            )

sws %>% 
  filter(species == "Human") %>%
  mutate(mn_height = mean(height, na.rm = TRUE),
         taller = height > mn_height + 5) %>%
  filter(taller == TRUE)

sws %>% 
  filter(species == "Human") %>%
  group_by(gender) %>% 
  mutate(mn_height_2 = mean(height, na.rm = TRUE),
         taller_2 = height > mn_height_2 + 5) %>%
  filter(taller_2 == TRUE)
```


# Exercises (WPA03)

The following exercises practice the essential `dplyr` commands and aim to show that show that simple pipes of them can solve quite intriguing puzzles about data. 

## Exercise 1

#### Star and R wars

Let's tackle the universe/tidyverse by uncovering even more facts about the `dplyr::starwars` dataset. Answer the following questions by using pipes of basic `dplyr` commands (i.e., arranging, filtering, selecting, grouping, counting, summarizing). 

- Save the tibble `dplyr::starwars` as `sw` and report its dimensions. 

```{r, starwars_transformations_1, include = TRUE}
## Data: ----- 
# ?dplyr::starwars

## (a) Basic data properties: ---- 
sw <- dplyr::starwars
dim(sw)  # => 87 rows (denoting individuals) x 13 columns (variables) 
```

#### Known unknowns

- How many missing (`NA`) values does `sw` contain?

- Which variable (column) has the most missing values?

- Which individuals come from an unknown (missing) `homeworld` but have a known `birth_year` or known `mass`? 

<!-- Replace all missing values of `hair_color` (in the variable `sw$hair_color`) by "bald".  -->


```{r, starwars_transformations_2, include = TRUE}
## Missing data: ----- 

# How many missing data points?
sum(is.na(sw))  # => 101 missing values.

# Which individuals come from an unknown (missing) homeworld 
# but have a known birth_year or mass? 
sw %>% 
  filter(is.na(homeworld), !is.na(mass) | !is.na(birth_year))

# Which variable (column) has the most missing values?
colSums(is.na(sw))  # => birth_year has 44 missing values
colMeans(is.na(sw)) #    (amounting to 50.1% of all cases). 

## (x) Replace all missing values of `hair_color` (in the variable `sw$hair_color`) by "bald": 
# sw$hair_color[is.na(sw$hair_color)] <- "bald"
```

#### Gender issues 

- How many humans are contained in `sw` overall and by gender?

- How many and which individuals in `sw` are neither male nor female?

- Of which species in `sw` exist at least 2 different gender values?

```{r, starwars_transformations_3, include = TRUE}
## (c) Gender issues: ----- 

# (+) How many humans are there of each gender?
sw %>% 
  filter(species == "Human") %>%
  group_by(gender) %>%
  count()

## Answer: 35 Humans in total: 9 females, 26 male.

# (+) How many and which individuals are neither male nor female?
sw %>% 
  filter(gender != "male", gender != "female")

# (+) Of which species are there at least 2 different gender values?
sw %>%
  group_by(species, gender) %>%
  count() %>%  # table shows species by gender: 
  group_by(species) %>%  # Which species appear more than once in this table? 
  count() %>%
  filter(nn > 1)

# alternative (and shorter) solution:
sw %>%
  group_by(species)%>%
  summarise(n_gender_vals = n_distinct(gender)) %>%
  filter(n_gender_vals >= 2)
```

#### Popular homes and heights 

- From which `homeworld` do the most indidividuals (rows) come from? 

- What is the mean `height` of all individuals with orange eyes from the most popular homeworld? 

```{r, starwars_transformations_4, include = TRUE}
## (d) Homeworld issues: ----- 

# (+) Popular homes: From which homeworld do the most indidividuals (rows) come from? 
sw %>%
  group_by(homeworld) %>%
  count() %>%
  arrange(desc(n))
# => Naboo (with 11 individuals)

# (+) What is the mean height of all individuals with orange eyes from the most popular homeworld? 
sw %>% 
  filter(homeworld == "Naboo", eye_color == "orange") %>%
  summarise(n = n(),
            mn_height = mean(height))

## Note: 
sw %>% 
  filter(eye_color == "orange") # => 8 individuals


# (+) What is the mass and homeworld of the smallest droid?
sw %>% 
  filter(species == "Droid") %>%
  arrange(height)
```

#### Size and mass issues

- Compute the median, mean, and standard deviation of `height` for all droids. 

- Compute the average height and mass by species and save the result as `h_m`. 

- Sort `h_m` to list the 3 species with the smallest individuals (in terms of mean height). 

- Sort `h_m` to list the 3 species with the heaviest individuals (in terms of median mass).

```{r, starwars_transformations_5, include = TRUE}
## Size and mass issues (group summaries): ----- 

# (+) Compute the median, mean, and standard deviation of `height` for all droids.
sw %>%
  filter(species == "Droid") %>%
  summarise(n = n(),
            not_NA_h = sum(!is.na(height)),
            md_height = median(height, na.rm = TRUE),
            mn_height = mean(height, na.rm = TRUE),
            sd_height = sd(height, na.rm = TRUE))

# (+) Compute the average height and mass by species and save the result as `h_m`:
h_m <- sw %>%
  group_by(species) %>%
  summarise(n = n(),
            not_NA_h = sum(!is.na(height)),
            mn_height = mean(height, na.rm = TRUE),
            not_NA_m = sum(!is.na(mass)),
            md_mass = median(mass, na.rm = TRUE)
            )
h_m

# (+) Use `h_m` to list the 3 species with the smallest individuals (in terms of mean height)?
h_m %>% arrange(mn_height) %>% slice(1:3)

# (+) Use `h_m` to list the 3 species with the heaviest individuals (in terms of median mass)?
h_m %>% arrange(desc(md_mass)) %>%  slice(1:3)
```

#### Bonus tasks

- How many individuals come from the 3 most frequent (known) species?

- Which individuals are more than 20% lighter (in terms of mass) than the average mass of individuals of their own homeworld?

```{r, starwars_transformations_6, include = TRUE}
## Bonus questions: ----- 

# How many individuals come from the 3 most frequent (known) species?
sw %>%
  group_by(species) %>%
  count %>%
  arrange(desc(n)) %>%
  filter(n > 1)

# Which individuals are more than 20% lighter (in terms of mass) 
# than the average mass of individuals of their own homeworld?
sw %>%
  select(name, homeworld, mass) %>%
  group_by(homeworld) %>%
  mutate(n_notNA_mass = sum(!is.na(mass)),  
         mn_mass = mean(mass, na.rm = TRUE),
         lighter = mass < (mn_mass - (.20 * mn_mass))
         ) %>%
  filter(lighter == TRUE)
```

## Exercise 2

#### Sleeping mammals

The dataset `ggplot2::msleep` contains a mammals sleep dataset (see `?msleep` for details and the definition of variables). 

- Save the data as `sp` and check the dimensions, variable types, and number of missing values in the dataset.

```{r ex_msleep_data, echo = TRUE, eval = TRUE}
## Data: 
# ?msleep  # check variables     
sp <- ggplot2::msleep
```

```{r ex_msleep_check, echo = TRUE, eval = TRUE}
# Check: 
dim(sp)        # 83 x 11 variables
glimpse(sp)    # 5 <chr> and 6 <dbl>
sum(is.na(sp)) # 136 missing values
```

#### Arranging and filtering data

Use the `dplyr`-verbs `arrange`, `group_by`, and `filter` to answer the following questions by creating ordered subsets of the data:

- Arrange the rows (alphabetically) by `vore`, `order`, and `name`, and report the `genus` of the top 3 mammals. 

- What is the most common type of `vore` in the data? How many omnivores are there?  

- What is the most common `order` in the dataset? Are there more exemplars of the `order` "Carnivora" or "Primates"? 

- Which 2 mammals of the order "Primates" have the longest and shortest `sleep_total` times?

```{r ex_msleep_subsets, echo = TRUE, eval = TRUE}
# Arranging rows:
sp1 <- sp %>%
  arrange(vore, order, name)
sp1$genus[1:3]  # => top 3: "Vulpes"   "Phoca"    "Acinonyx"

# Counting common vores:
# (a) short solution:
sp %>%
  count(vore) %>%
  arrange(desc(n))  

# (a) is the same as (b): 
sp %>% 
  group_by(vore) %>%
  tally() %>%
  arrange(desc(n))

# (b) is the same as (c):  
sp %>% 
  group_by(vore) %>%
  summarise(n = n()) %>%
  arrange(desc(n))

# => 32 herbivores, 20 omnivores

# Counting common orders: 
sp %>% 
  count(order) %>%
  arrange(desc(n)) 

# OR: 
sp %>% 
  group_by(order) %>%
  count() %>%
  arrange(desc(n)) 
# => 22 Rodentia, 12 Carnivora = 12 Primates

# Primates with longest and shortest sleep_total times:
sp %>% 
  filter(order == "Primates") %>%
  arrange(desc(sleep_total)) 
# => max: Owl monkey: 17 hours, min: Human 8 hours.
```

#### Computing new variables

Solve the following tasks by `mutate`, `group_by`, and `summarise`: 

- Compute a variable `sleep_awake_sum` that adds the `sleep_total` time and the `awake` time of each mammal. What result do you expect and get? 

- Which animals have the smallest and largest brain to body ratio (in terms of weight)? How many mammals have a larger ratio than humans?

- What is the minimum, average (mean), and maximum sleep cycle length for each `vore`? (Hint: First group the data by `group_by`, then use `summarise` on the `sleep_cycle` variable, but also count the number of `NA` values for each `vore`. When computing grouped summaries, `NA` values can be removed by `na.rm = TRUE`.)

- Replace your `summarise` verb in the previous task by `mutate`. What do you get as a result? (Hint: The last two tasks illustrate the difference between `mutate` and _grouped_ `mutate` commands.)

```{r ex_msleep_mutate, echo = TRUE, eval = TRUE}
# Computing `sleep_awake_sum`: 
sp2 <- sp %>%
  mutate(sleep_awake_sum = sleep_total + awake)
sp2$sleep_awake_sum  # => all 24 hours 

# Computing brain to body ratios:
sp3 <- sp %>%
  mutate(brain_to_body_wt = brainwt / bodywt) %>%
  arrange(brain_to_body_wt)

sp3$name[1] # => smallest ratio: Cow

sp3 %>% 
  arrange(desc(brain_to_body_wt))
# => largest ratio: Thirteen-lined ground squirrel, 
#    9 mammals have larger brain_to_body_wt than Human.

# Computing sleep cycle length for each `vore`: 
sp %>%
  group_by(vore) %>%
  summarise(n = n(),
            n_NA = sum(is.na(sleep_cycle)), 
            non_NA = sum(!is.na(sleep_cycle)),
            min_cyc = min(sleep_cycle, na.rm = TRUE),
            mn_cyc = mean(sleep_cycle, na.rm = TRUE),
            max_cyc = max(sleep_cycle, na.rm = TRUE)
            )

# Replacing summarise by mutate: 
sp4 <- sp %>%
  group_by(vore) %>%
  mutate(n = n(),
         n_NA = sum(is.na(sleep_cycle)), 
         non_NA = sum(!is.na(sleep_cycle)),
         min_cyc = min(sleep_cycle, na.rm = TRUE),
         mn_cyc = mean(sleep_cycle, na.rm = TRUE),
         max_cyc = max(sleep_cycle, na.rm = TRUE)
  )

# => A tibble that contains grouped summaries as 6 new variables: 
sp4 %>% 
  select(vore, name, sleep_cycle, n:max_cyc) %>%
  arrange(vore)
```

## Exercise 3

#### Outliers

This exercise examines different possibilities for defining _outliers_ and uses a generated dataset (entitled `out.csv` and available at <http://rpository.com/ds4psy/data/out.csv>) to illustate and compare them. It also helps to further disentangle the difference between `mutate` and _grouped_ `mutate` commands.

#### Data on `outliers`

Use the following `read_csv()` command to obtain and load the data into an R object entitled `outliers`: 

```{r outlier_load_data, echo = TRUE, eval = TRUE}
## Load data (as comma-separated file): 
outliers <- read_csv("http://rpository.com/ds4psy/data/out.csv")  # from online source

## Alternatively (from local source): 
# outliers <- read_csv("out.csv")  # from current directory
```

```{r outlier_create_data, echo = FALSE, eval = FALSE}
# library(tidyverse)

## Creating a suitable data set: 
set.seed(123)
n <- 1000
id <- paste0("nr.", 1:n) # paste0(sample(LETTERS, 1), sample(LETTERS, 1))
sex <- sample(x = c(0, 1), size = n, replace = TRUE)
height <- rep(NA, n)
noise_0 <- round(rnorm(n, mean = 0, sd = 8), 0)
noise_1 <- round(rnorm(n, mean = 0, sd = 11), 0)
height[sex == 0] <- 169 + noise_0[sex == 0]
height[sex == 1] <- 181 + noise_1[sex == 1]

## Modify data:
height <- add_NAs(height, amount = 18)  # 1.8% NA values in height
height[sex == 0] <- add_whats(vec = height[sex == 0], amount = 1, what = 202) # add a tall woman
# sex <- add_NAs(sex, amount = 3)          # 2  NA values in sex

## Save data as tibble: 
data <- as_tibble(data_frame(id, sex, height))
data$sex <- factor(data$sex, labels = c("female", "male"))
names(data) <- c("id", "sex", "height")

## Check data:
mean(data$sex == "female", na.rm = TRUE)  # => .507
mean(data$height, na.rm = TRUE)           # => 174.7006 (with seed 123)

## Writing out data:
write_csv(data, "out.csv")

## Reading in again (from csv-file):
outliers <- read_csv("out.csv")
outliers
```

#### Not all outliers are alike

An _outlier_ can be defined as an individual whose value in some variable deviates by more than a given criterion (e.g., 2 standard deviations) from the mean of the variable. However, this definition is incomplete unless it also specifies the _reference group_ over which the means and deviations are computed. In the following, we explore the implications of different reference groups. 

#### Basic tasks

- Save the data into a tibble `outliers` and report its number of observations and variables, and their types.

- How many missing data values are there in `outliers`?

- What is the gender (or `sex`) distribution in this sample? 

- Create a plot that shows the distribution of `height` values for each gender. 

<!-- fig.show options: "asis", "hide", "hold", "animate" --> 

```{r outlier_solution_1, include = TRUE, fig.show = "asis"}
# Load and inspect data:
# outliers <- read_csv("out.csv") # read in csv-file
# outliers <- as_tibble(data)   # if data is not already a tibble
dim(outliers)  # => 1000 observations (rows) x 3 variables (columns)

# Missing data points: 
sum(is.na(outliers))  # => 18 missing values

# Gender distribution: 
outliers %>% 
  group_by(sex) %>% 
  count()
# => 50.7% females, 49.3% males.

# Distributions of `height` as density plot: 
ggplot(outliers, aes(x = height)) +
  geom_density(fill = "gold", alpha = 2/3) +
  geom_density(aes(fill = sex), alpha = 2/5) +
  labs(title = "Distribution of heights overall and by gender", 
       fill = "Gender") + 
  # scale_fill_manual(values = c("firebrick", "steelblue3")) +
  scale_fill_brewer(palette = "Set1") +  # using Brewer palette
  theme_bw()

# Note: To avoid the warning about removing 18 cases with NA-values, 
#       we could first filter out those cases:
# non_NA_data <- filter(outliers, !is.na(height))

# Alternative solution as 2 histograms: 
ggplot(outliers) +
  facet_wrap(~sex) + 
  geom_histogram(aes(x = height, fill = sex), binwidth = 5, color = "grey10") +
  labs(title = "Distribution of heights by gender",
       x = "Height", y = "Frequency") +
  scale_fill_brewer(name = "Gender:", palette = "Set1") +  # using Brewer palette
  # scale_fill_manual(name = "Gender:", values = c("firebrick", "steelblue3")) + 
  theme_bw()
```

#### Defining different outliers

Compute 2 new variables that signal and distinguish between 2 types of outliers in terms of `height`: 

1. outliers relative to the `height` of the _overall sample_ (i.e., individuals with `height` values deviating more than 2 SD from the overall mean of `height`); 

2. outliers relative to the `height` of _some subgroup_'s mean and SD. Here, a suitable subgroup to consider is every person's gender (i.e., individuals with `height` values deviating more than 2 SD from the mean `height` of their own gender). 

**Hints:** As both variable signal whether or not someone is an outlier they should be defined as logicals (being either `TRUE` or `FALSE`) and added as new columns to `data` (via appropriate `mutate` commands). While the 1st variable can be computed based on the mean and SD of the overall sample, the 2nd variable can be computed after grouping `outliers` by gender and then computing and using the corresponding mean and SD values. The absolute difference between 2 numeric values `x` and `y` is provided by `abs(x - y)`. 

#### Relative outliers

Now use the 2 new outlier variables to define (or `filter`) 2 subsets of the data that contain 2 subgroups of people: 

1. `out_1`: Individuals (females and males) with `height` values that are outliers relative to _both_ the entire sample _and_ the sample of their own gender. How many such individuals are in `outliers`?

2. `out_2`: Individuals (females and males) with `height` values that are _not_ outliers relative to the entire population, but _are_ outliers relative to their own gender. How many such individuals are in `outliers`?

```{r outlier_solution_2, include = TRUE, fig.show = "asis"}
## Defining different outliers: ----- 

# Included in data_out (below), but also possible to do separately:  
# Compute the number, means and SD of height values in 2 ways: 

# 1. overall: 
outliers %>%
  summarise(n = n(),
            n_not_NA = sum(!is.na(height)),
            mn_height = mean(height, na.rm = TRUE),
            sd_height = sd(height, na.rm = TRUE))

# 2. by gender:
outliers %>%
  group_by(sex) %>%
  summarise(n = n(),
            n_not_NA = sum(!is.na(height)),
            mn_height = mean(height, na.rm = TRUE),
            sd_height = sd(height, na.rm = TRUE))


# Detecting and marking outliers (by logical variables): 
# Compute the means, SDs, and corresponding outliers in 2 ways:
crit <- 2  # criterion value for detecting outliers (in SD units)

data_out <- outliers %>%      
  # 1. Compute means, SD, and outliers for overall sample: 
  mutate(mn_height  = mean(height, na.rm = TRUE),  
         sd_height  = sd(height, na.rm = TRUE),
         out_height = abs(height - mn_height) > (crit * sd_height)) %>%
  group_by(sex) %>%       
  # 2. Compute same metrics for subgroups (by sex):
  mutate(mn_sex_height  = mean(height, na.rm = TRUE), 
         sd_sex_height  = sd(height, na.rm = TRUE),
         out_sex_height = abs(height - mn_sex_height) > (crit * sd_sex_height))

knitr::kable(head(data_out))

## Relative outliers: ----- 

# Filter specific combinations of outliers:

# 1. Outliers relative to the entire population AND to their own gender: 
out_1 <- data_out %>%
  filter(out_height & out_sex_height) %>%
  arrange(sex, height)

nrow(out_1) # => 21 individuals. 

# 2. Outliers relative to their own gender, but NOT relative to the entire population:
out_2 <- data_out %>%
  filter(!out_height & out_sex_height) %>%
  arrange(sex, height)  

nrow(out_2) # => 24 individuals.
```

#### Bonus plots

- Visualize the raw values and distributions of `height` for both types of outliers (`out_1` and `out_2`) in 2 separate plots. 

- Interpret both plots by describing the `height` and `sex` combination of the individuals shown in each plot. 

<!-- fig.show options: "asis", "hide", "hold", "animate" --> 
 
```{r outlier_solution_3, include = TRUE, fig.show = "asis"}
# Visualization and interpretation of both types of outliers: 

# 1. Showing out_1: 
ggplot(out_1, aes(x = sex, y = height)) +
  geom_violin(aes(fill = sex)) + 
  geom_jitter(size = 4, alpha = 2/3) + 
  scale_fill_manual(values = c("firebrick", "steelblue3")) +
  labs(title = "Outliers relative to both overall sample and gender", 
       x = "Gender", y = "Height (in cm)", 
       fill = "Gender:") +
  theme_bw()

# Interpretation: 
# `out_1` contains mostly short women (except for 1 tall woman) 
#  and mostly tall men (except for 2 short men). 

# 2. Showing out_2: 
ggplot(out_2, aes(x = sex, y = height)) +
  geom_violin(aes(fill = sex)) + 
  geom_jitter(size = 4, alpha = 2/3) + 
  scale_fill_manual(values = c("firebrick", "steelblue3")) +
  labs(title = "Outliers relative to gender but not overall sample", 
       x = "Gender", y = "Height (in cm)", 
       fill = "Gender:") +
  theme_bw()

# Interpretation: 
# `out_2` contains individuals which are either tall women or short men.
```


## Exercise 4

In [Exercise 6 of WPA01](http://rpository.com/ds4psy/essentials/basics.html#exercise-6) and 
[Exercise 5 of WPA02](http://rpository.com/ds4psy/essentials/visualize.html#exercise-5) 
you used the `p_info` data (available at <http://rpository.com/ds4psy/data/posPsy_participants.csv>) from 

- Woodworth, R. J., O’Brien-Malone, A., Diamond, M. R. and Schüz, B. (2018). 
Data from, ‘Web-based positive psychology interventions: A reexamination of effectiveness’. 
_Journal of Open Psychology Data_, _6_: 1. 
DOI: <https://doi.org/10.5334/jopd.35> 

to explore the participant information and create some corresponding plots. 

```{r ex4_read_posPsy_data, echo = TRUE, eval = TRUE}
library(readr)

# Read data (from online source):
p_info <- read_csv(file = "http://rpository.com/ds4psy/data/posPsy_participants.csv")

# p_info
dim(p_info)      # 295 rows, 6 columns
```

Answer the same questions as in those exercises by transforming your earlier base R commands and graphs (created by using `ggplot2` commands) into pipes of `dplyr` commands that provide the same information. 

#### From WPA01: Exercise 6

Questions from [Exercise 6 of WPA01](http://rpository.com/ds4psy/essentials/basics.html#exercise-6):  

Examine the participant information in `p_info` by describing each of its variables: 

1. How many individuals are contained in the dataset? 
2. What percentage of them is female (i.e., has a `sex` value of 1)?
3. How many participants were in one of the 3 treatment groups (i.e., have an `intervention` value of 1, 2, or 3)? 
4. What is the participants' mean education level? What percentage has a university degree (i.e., an `educ` value of at least 4)?
5. What is the age range (`min` to `max`) of participants? What is the average (mean and median) age?
6. Describe the range of `income` levels present in this sample of participants. What percentage of participants self-identifies as a below-average income (i.e., an `income` value of 1)?

```{r ex4_WPA01_ex6, include = TRUE}
# 1. How many individuals are contained in the dataset? 
N <- nrow(p_info) # OR 
N  # 295

# Note: 
p_info %>% count()
# would yield a tibble (with only 1 element: 295).

# 2. What percentage of them is female (i.e., has a `sex` value of 1)?
p_info %>%
  group_by(sex) %>% 
  summarise(n_sex = n(),            # number 
            pc_sex = n_sex/N * 100  # percentage
            )

# 3. How many participants were in one of the 3 treatment groups (i.e., have an `intervention` value of 1, 2, or 3)? 
p_info %>%
  filter(intervention < 4) %>%
  count()  
# => 222 individuals

# OR: 
t_iv <- p_info %>%
  group_by(intervention) %>% 
  summarise(n_iv = n(),           # number 
            pc_iv = n_iv/N * 100  # percentage
            ) 
t_iv
sum(t_iv$n_iv[1:3]) 
# => 222 in elements 1:3 of vector n_iv 


# 4. What is the participants' mean education level? 
p_info %>%
  summarise(mn_edu = mean(educ))

# What percentage has a university degree (i.e., an `educ` value of at least 4)?
p_info %>%
  group_by(educ) %>% 
  summarise(n_edu = n(),            # number 
            pc_edu = n_edu/N * 100  # percentage
            ) 

# 5. What is the age range (`min` to `max`) of participants? 
#    What is the average (mean and median) age?
p_info %>%
  summarise(n = n(),
            min_age = min(age),
            mn_age = mean(age),
            max_age = max(age)) 

# 6. Describe the range of `income` levels present in this sample of participants. 
#    What percentage of participants self-identifies as a below-average income 
#    (i.e., an `income` value of 1)?
p_info %>%
  group_by(income) %>%
  summarise(n_income = n(),
            pc_income = n_income/N * 100) 
```

#### From WPA02: Exercise 5

Questions from [Exercise 5 of WPA02](http://rpository.com/ds4psy/essentials/visualize.html#exercise-5)

Use the `p_info` data to create some plots that descripte the sample of participants: 

- A _histogram_ that shows the distribution of participant `age` in 3 ways:  
    - overall, 
    - separately for each `sex`, and 
    - separately for each `intervention`. 

When using `dplyr` instead of `ggplot2`, we can replace the information contained in the histogram by a table of descriptives:     

```{r p_info_WPA02_ex5_age, include = TRUE}
# Age distribution (as a table): 
age_overall <- p_info %>%
  summarise(n = n(),              # number 
            min_age = min(age),   # minimum
            mn_age = mean(age),   # mean
            md_age = median(age), # median           
            sd_age = sd(age),     # standard deviation
            max_age = max(age)    # maximum
  )
age_overall

# Age distribution by sex (as a table): 
age_by_sex <- p_info %>%
  group_by(sex) %>% 
  summarise(n = n(),              # number 
            min_age = min(age),   # minimum
            mn_age = mean(age),   # mean
            md_age = median(age), # median           
            sd_age = sd(age),     # standard deviation
            max_age = max(age)    # maximum
  )
age_by_sex

# Age distribution by intervention (as a table): 
age_by_iv <- p_info %>%
  group_by(intervention) %>% 
  summarise(n = n(),              # number 
            min_age = min(age),   # minimum
            mn_age = mean(age),   # mean
            md_age = median(age), # median           
            sd_age = sd(age),     # standard deviation
            max_age = max(age)    # maximum
  )
age_by_iv
```

- A _bar plot_ that 
    - shows how many participants took part in each `intervention`; or 
    - shows how many participants of each `sex` took part in each `intervention`.

Using `dplyr` instead of `ggplot2`: 

```{r p_info_WPA02_ex5_iv, include = TRUE}
# Number of participants per intervention:
# (was contained in age_by_iv above): 
age_by_iv %>%
  select(intervention, n)

# N and percentage by intervention and sex:
p_info %>%
  group_by(intervention, sex) %>% 
  summarise(n_iv_sex  = n(),              # number 
            pc_iv_sex = n_iv_sex/N * 100  # percentage 
            ) 
```


# More on data transformation 

For more details on `dplyr`, 

- study `vignette("dplyr")` and the documentation for `?arrange`, `?filter`, `?select`, etc. 
- study <https://dplyr.tidyverse.org/> and its examples; 
- see the [cheat sheet on data transformation](https://www.rstudio.com/resources/cheatsheets/); 
- read [Chapter 5: Data transformation](http://r4ds.had.co.nz/transform.html) and complete its exercises. 


# Conclusion

<!-- Table with links: -->

All [ds4psy](http://rpository.com/ds4psy/) essentials so far: 

Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | **Transforming data** |
4.  | [Exploring data (EDA)](http://rpository.com/ds4psy/essentials/explore.html) | 
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 

<!--
Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | [Transforming data](http://rpository.com/ds4psy/essentials/transform.html) |
4.  | [Exploring data (EDA)](http://rpository.com/ds4psy/essentials/explore.html) | 
5.  | [Creating and using tibbles](http://rpository.com/ds4psy/essentials/tibble.html) |
6.  | [Tidying data](http://rpository.com/ds4psy/essentials/tidy.html) | 
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 
-->


[Last update on `r Sys.time()` by [hn](http://neth.de/).]  

<!-- eof. --> 