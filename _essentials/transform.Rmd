---
title: "Transforming data, with solutions (ds4psy)"
author: "Hansjörg Neth, SPDS, uni.kn"
date: "2018 11 16"
output:
   rmdformats::html_clean: # html_clean html_docco readthedown material #
     code_folding: show # hide
     toc_float: true
     toc_depth: 3
     highlight: default # textmate default kate haddock monochrome #
     lightbox: true # true by default
     fig_width: 7 # in inches
editor_options: 
  chunk_output_type: console # inline
---

<!-- Example of essential commands | ds4psy: Winter 2018 -->

```{r preamble, echo = FALSE, eval = TRUE, cache = FALSE, message = FALSE, warning = FALSE}
## (a) Housekeeping: -----
rm(list=ls()) # clean all.

## (b) Current file name and path: ----- 
# cur.path <- dirname(rstudioapi::getActiveDocumentContext()$path)
# cur.path
# setwd(cur.path) # set to current directory
setwd("~/Desktop/stuff/Dropbox/_code/R/_teachR/ds4psy/_essentials") # set to current directory
# list.files() # all files + folders in current directory
fileName <- "transform.Rmd"

## (c) Packages: ----- 
library(knitr)
library(rmdformats)
library(tidyverse)

## (d) Global options: ----- 
options(max.print = "75")
opts_chunk$set(echo = TRUE,
	             cache = TRUE,
               prompt = FALSE,
               tidy = FALSE,
               collapse = TRUE, # set TRUE in answers 
               comment = "#>",
               message = FALSE,
               warning = FALSE,
               ## Default figure options:
               fig.width = 7, 
               fig.asp = .618, # golden ratio
               out.width = "75%",
               fig.align = "center"
               )
opts_knit$set(width = 75)

## (e) Graphics: ----- 

# Defining colors:
seeblau <- rgb(0, 169, 224, names = "seeblau", maxColorValue = 255) # seeblau.4 (non-transparent)

seeblau.colors <- c(rgb(204, 238, 249, maxColorValue = 255), # seeblau.1
                    rgb(166, 225, 244, maxColorValue = 255), # seeblau.2 
                    rgb(89, 199, 235, maxColorValue = 255),  # seeblau.3
                    rgb(0, 169, 224, maxColorValue = 255),   # seeblau.4 
                    rgb(0, 0, 0, maxColorValue = 255),       #  5. black
                    gray(level = 0, alpha = .6),             #  6. gray 60% transparent
                    gray(level = 0, alpha = .4),             #  7. gray 40% transparent
                    gray(level = 0, alpha = .2),             #  8. gray 20% transparent
                    gray(level = 0, alpha = .1),             #  9. gray 10% transparent
                    rgb(255, 255, 255, maxColorValue = 255)  # 10. white
                    )

unikn.pal = data.frame(                             ## in one df (for the yarrr package): 
  "seeblau1" = rgb(204, 238, 249, maxColorValue = 255), #  1. seeblau1 (non-transparent)
  "seeblau2" = rgb(166, 225, 244, maxColorValue = 255), #  2. seeblau2 (non-transparent)
  "seeblau3" = rgb( 89, 199, 235, maxColorValue = 255), #  3. seeblau3 (non-transparent)
  "seeblau4" = rgb(  0, 169, 224, maxColorValue = 255), #  4. seeblau4 (= seeblau base color)
  "black"    = rgb(  0,   0,   0, maxColorValue = 255), #  5. black
  "seegrau4" = rgb(102, 102, 102, maxColorValue = 255), #  6. grey40 (non-transparent)
  "seegrau3" = rgb(153, 153, 153, maxColorValue = 255), #  7. grey60 (non-transparent)
  "seegrau2" = rgb(204, 204, 204, maxColorValue = 255), #  8. grey80 (non-transparent)
  "seegrau1" = rgb(229, 229, 229, maxColorValue = 255), #  9. grey90 (non-transparent)
  "white"    = rgb(255, 255, 255, maxColorValue = 255), # 10. white
  stringsAsFactors = FALSE)

## (f) Counters: ----- 
nr <- 0  # task number
pt <- 0  # point total
```

```{r utility_add_random_NA_values, echo = FALSE, eval = TRUE}
# Adding a random amount (number or proportion) of NA or other values to a vector:

## Function to replace a random amount of vector elements by NA values:  
add_NAs <- function(vec, amount){
  
  stopifnot((is.vector(vec)) & (amount >= 0) & (amount <= length(vec)))

  out <- vec
  n <- length(vec)
  
  amount2 <- ifelse(amount < 1, round(n * amount, 0), amount) # turn amount prop into n
  
  out[sample(x = 1:n, size = amount2, replace = FALSE)] <- NA
  
  return(out)

}

## Check:
# add_NAs(1:10, 0)
# add_NAs(1:10, 3)
# add_NAs(1:10, .5)
# add_NAs(letters[1:10], 3)

## Generalization: Replace a random amount of vector elements by what: 
add_whats <- function(vec, amount, what = NA){
  
  stopifnot((is.vector(vec)) & (amount >= 0) & (amount <= length(vec)))

  out <- vec
  n <- length(vec)
  
  amount2 <- ifelse(amount < 1, round(n * amount, 0), amount) # turn amount prop into n
  
  out[sample(x = 1:n, size = amount2, replace = FALSE)] <- what
  
  return(out)

}

## Check:
# add_whats(1:10, 3) # default: what = NA
# add_whats(1:10, 3, what = 99)
# add_whats(1:10, .5, what = "ABC")
```

# Introduction

This file contains **essential commands** from [Chapter 5: Data transformation](https://r4ds.had.co.nz/transform.html) of the textbook [r4ds](http://r4ds.had.co.nz) and corresponding examples and exercises. 
A command is considered "essential" when you really need to _know_ it and need to know _how to use_ it to succeed in this course. 

<!-- Table with links: -->

All [ds4psy](http://rpository.com/ds4psy/) essentials so far: 

Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | **Transforming data** |
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 

<!--
Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | [Transforming data](http://rpository.com/ds4psy/essentials/transform.html) |
4.  | [Exploring data (EDA)](http://rpository.com/ds4psy/essentials/EDA.html) | 
5.  | [Creating and using tibbles](http://rpository.com/ds4psy/essentials/tibble.html) |
6.  | [Tidying data](http://rpository.com/ds4psy/essentials/tidy.html) |
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 
-->

## Course coordinates

<!-- uni.kn logo and link to SPDS: -->  
<!-- ![](./inst/pix/uniKn_logo.png) --> 
<a href="https://www.spds.uni-konstanz.de/">
<img src = "../inst/pix/uniKn_logo.png" alt = "spds.uni.kn" align = "right" width = "300" style = "width: 300px; float: right; border:20;"/>
<!-- <img src = "./inst/pix/uniKn_logo_s.png" alt = "spds.uni.kn" style = "float: right; border:20;"/> --> 
</a>

* Taught at the [University of Konstanz](https://www.uni-konstanz.de/) by [Hansjörg Neth](http://neth.de/) (<h.neth@uni.kn>,  [SPDS](https://www.spds.uni-konstanz.de/), office D507).
* Winter 2018/2019: Mondays, 13:30--15:00, C511. 
* Links to current [course syllabus](http://rpository.com/ds4psy/) | [ZeUS](https://zeus.uni-konstanz.de/hioserver/pages/startFlow.xhtml?_flowId=detailView-flow&unitId=5101&periodId=78&navigationPosition=hisinoneLehrorganisation,examEventOverviewOwn) |  [Ilias](https://ilias.uni-konstanz.de/ilias/goto_ilias_uni_crs_809936.html) 

## Preparations

Create an R script (`.R`) or an R-Markdown file (`.Rmd`) and load the R packages of the `tidyverse`. (Hint: Structure your script by inserting spaces, meaningful comments, and sections.) 

```{r layout_template, echo = TRUE, eval = FALSE}
## Transforming data | ds4psy
## 2018 11 19
## ----------------------------

## Preparations: ----------

library(tidyverse)

## 1. Topic: ----------

# etc.

## End of file (eof). ----------  
```


# Visualizing data

In the following, we assume that you have read and worked through [Chapter 5: Data transformation](https://r4ds.had.co.nz/transform.html).  
Based on this background, we examine some essential commands of `dplyr` in the context of examples. However, the `dplyr` package extends beyond this introduction -- and will appear again later (e.g., in [Chapter 13: Relational data](https://r4ds.had.co.nz/relational-data.html)). 


# Essential commands and examples 

Data transformation includes re-arranging, selecting, changing, or aggregating data. 

## Overview

When we have data in the form of a tibble or data frame, `dplyr` provides a range of simple tools to transform this data. Six essential `dplyr` commands are: 

1. `arrange` sorts cases (rows); 
2. `filter` selects cases (rows) by logical conditions; 
3. `select` selects and reorders variables (columns); 
4. `mutate` computes new variables (columns) and adds them to existing ones; 
5. `summarise` collapses multiple values of a variable (rows of a column) to a single one;  
6. `group_by` changes the unit of aggregation (in combination with `mutate` and `summarise`).  

Not quite as essential but still useful `dplyr` commands include:

- `slice` selects (ranges of) cases (rows) by number; 
- `rename` renames variables (columns) and keeps others; 
- `transmute` computes new variables (columns) and drops existing ones;
- `sample_n` and `sample_frac` draw random samples of cases (rows).

## Data

We save the `dplyr::starwars` data as a tibble `sw` and use it to illustrate the essential `dplyr` commands.

```{r starwars_data}
library(tidyverse)
sw <- dplyr::starwars

sw  # => A tibble: 87 rows (individuals) x 13 columns (variables)
```

Standard questions to ask of every new data file include:

- What are the _dimensions_ of the data file?

- How many _variables_ (columns) are there in `sw` and of which _type_ are they? 

- How many _missing_ (`NA`) values are there? 

```{r check_data}
## Data:
# sw

## Standard checks: ------ 
dim(sw)     # 87 x 13 variables
names(sw)   # variable names
glimpse(sw) #    

## Missing (NA) values: ------ 
sum(is.na(sw))      # 101 missing values
colSums(is.na(sw))  # missing by column (variable) 
```


### 1. `arrange` to sort rows

Using `arrange` sorts cases (rows) by putting specific variables (columns) in specific orders (e.g., ascending or descending):

```{r dplyr_arrange}
# Sort rows alphabetically (by name):
arrange(sw, name)

# The same command using the pipe:
sw %>%           # Note: %>% is NOT + (used in ggplot) 
  arrange(name) 

# Sort rows in descending order:
sw %>% 
  arrange(desc(name)) 

# Sort by multiple variables:
sw %>% 
  arrange(eye_color, gender, desc(height))

## Note: See 
# ?dplyr::arrange  # for more help and examples.
```

Note some details: 

- All basic `dplyr` commands can be called as `verb(data, ...)` or -- using the pipe from `magrittr` -- as `data %>% verb(...)` (see `vignette("magrittr")` for details).

- Variable names are unquoted. 

- The order of variable names (`x, y, ...`) specifies the _order_ or _priority_ of operations (first by `x`, then by `y`, etc.). 

**Practice:** Arrange the `sw` data in different ways, combining multiple variables and (ascending and descending) orders. 
Where are cases containing `NA` values in sorted variables placed?


### 2. `filter` to select rows

Using `filter` selects cases (rows) by logical conditions. It keeps all rows for which the conditions are `TRUE` and drops all rows for which the conditions are `FALSE` or `NA`.

```{r dplyr_filter}
# Filter to keep all humans:
filter(sw, species == "Human")

# The same command using the pipe:
sw %>%           # Note: %>% is NOT + (used in ggplot) 
  filter(species == "Human")

# Filter by multiple (additive) conditions: 
sw %>%
  filter(height > 180, mass <= 75)  # tall and light individuals

# The same command using the logical operator (&): 
sw %>%
  filter(height > 180 & mass <= 75)  # tall and light individuals

# Filter for a range of a specific variable:
sw %>%
  filter(height >= 150, height <= 165)  # (a) using height twice

sw %>%
  filter(between(height, 150, 165))     # (b) using between(...)

# Filter by multiple (alternative) conditions: 
sw %>%
  filter(homeworld == "Kashyyyk" | skin_color == "green")

# Filter cases with missing (NA) values on specific variables:
sw %>%
  filter(is.na(gender))

# Filter cases with existing (non-NA) values on specific variables:
sw %>%
  filter(!is.na(mass), !is.na(birth_year))

## Note: See 
# ?dplyr::filter  # for more help and examples.
```

Note some details:

- Separating multiple conditions by commas is the same as the logical AND (`&`). 

- Variable names are unquoted.

- The comma between conditions or tests (`x, y, ...`) means the same as `&` (logical AND), as each test results in a vector of Boolean values. 

- Unlike in base R, rows for which the condition evaluates to `NA` are dropped. 

- Additional filter functions include `near()` for testing numerical (near-)identity. 


**Practice:** Use `filter` on the `dplyr::starwars` data (`sw`) to select very diverse or narrow subsets of individuals. 
For instance, 

- which individual with blond hair and blue eyes has an unknown mass? 
- of which species are individuals that are over 2m tall and have brown hair?
- which individuals from Tatooine are not male (but may be `NA`)? 
- which individuals are neither male nor female OR heavier than 130kg? 

```{r dplyr_filter_ex, echo = FALSE, eval = FALSE}
sw %>%
  filter(hair_color == "blond", eye_color == "blue")

sw %>%
  filter(height > 200, hair_color == "brown")

sw %>%
  filter(homeworld == "Tatooine", (gender != "male" | is.na(gender)))

sw %>%
  filter((gender != "male" & gender != "female") | mass > 130)
```


### 3. `select` to select columns 

Using `select` selects variables (columns) by their names or numbers: 

```{r dplyr_select}
# Select 4 specific variables (columns) of sw:
select(sw, name, species, birth_year, gender)

# The same when using the pipe:
sw %>%           # Note: %>% is NOT + (used in ggplot) 
  select(name, species, birth_year, gender)

# The same when providing a vector of variable names: 
sw %>%
  select(c(name, species, birth_year, gender)) 

# The same when providing column numbers:
sw %>%
  select(1, 10, 7, 8) 

# The same when providing a vector of column numbers: 
sw %>%
  select(c(1, 10, 7, 8)) 

# Select ranges of variables with ":":
sw %>%
  select(name:mass, films:starships)

# Select to re-order variables (columns) with everything():
sw %>%
  select(species, name, gender, everything())

# Select variables with helper functions:
sw %>%
  select(starts_with("s"))

sw %>%
  select(ends_with("s"))

sw %>%
  select(contains("_"))

sw %>%
  select(matches("or"))

# Renaming variables:
sw %>%
  rename(creature = name, from_planet = homeworld)

## Note: See 
# ?dplyr::select  # for more help and examples. 
?dplyr::select_if  # for more help and examples. 
```

Note some details:

- `select` works both by specifying variable (column) _names_ and by specifying column _numbers_.

- Variable names are unquoted. 

- The sequence of variable names (separated by commas) specifies the _order_ of columns in the resulting tibble.

- Selecting and adding `everything()` allows re-ordering. 

- Various helper functions (e.g., `starts_with`, `ends_with`, `contains`, `matches`, `num_range`) refer to (parts of) variable names. 

- `rename` renames specified variables (without quotes) and keeps all other variables.

**Practice:** Use `select` on the `dplyr::starwars` data (`sw`) to select and re-order specific subsets of variables (e.g., all variables starting with "h", all even columns, all character variables, etc.).


### 4. `mutate` to compute new variables

Using `mutate` computes new variables (columns) from scratch or existing ones: 

```{r dplyr_mutate}
# Preparation: Save only a subset variables of sw as sws:   
sws <- select(sw, name:mass, birth_year:species) 
sws    # => 87 cases (rows), but only 7 variables (columns)

# Compute 2 new variables and add them to existing ones:
mutate(sws, id = 1:nrow(sw), height_feet = .032808399 * height)

# The same using the pipe:
sws %>%
  mutate(id = 1:nrow(sw), height_feet = .032808399 * height)

# Transmute commputes and only keeps new variables:
sws %>%
  transmute(id = 1:nrow(sw), height_feet = .032808399 * height)

# Compute variables based on multiple others (including computed ones):
sws %>%
  mutate(BMI = mass / ((height / 100)  ^ 2),  # compute body mass index (kg/m^2)
         BMI_low  = BMI < 18.5,               # classify low BMI values
         BMI_high = BMI > 30,                 # classify high BMI values
         BMI_norm = !BMI_low & !BMI_high      # classify normal BMI values 
         )

## Note: See 
# ?dplyr::mutate  # for more help and examples. 
```

Note some details:

- `mutate` computes new variables (columns) and adds them to existing ones, while `transmute` drops existing ones.

- Each `mutate` command specifies a new variable name (without quotes), followed by `=` and a _rule_ for computing the new variable from existing ones. 

- Variable names are unquoted. 

- Multiple `mutate` steps are separated by commas, each of which creates a new variable.

- See <http://r4ds.had.co.nz/transform.html#mutate-funs> for useful functions for creating new variables. 

**Practice:** Compute a new variable `mass_pound` from `mass` (in kg) and the age of each individual in `sw` relative to Yoda's age. (Note that the variable `birth_year` is provided in years BBY, i.e., Before Battle of Yavin.) 

```{r mutate_ex, echo = FALSE, eval = FALSE}
# sws

age_yoda <- sws %>%
  filter(name == "Yoda") %>%
  .$birth_year
age_yoda

sws %>% 
  mutate(mass_pound = mass/.45,
         age_since_yoda = age_yoda - birth_year) %>%
  select(name, mass, mass_pound, birth_year, age_since_yoda)
```

### 5. `summarise` to compute summaries

`summarise` computes a function for a specified variable and collapses the values of the specified variable (i.e., the rows of a specified columns) to a single value. It provides many different summary statistics by itself, but is even more useful in combination with `group_by` (discussed next). 

```{r dplyr_summarise}
# Summarise allows computing a function for a variable (column): 
summarise(sw, mn_mass = mean(mass, na.rm = TRUE))  # => 97.31 kg 

# The same using the pipe: 
sw %>%
  summarise(mn_mass = mean(mass, na.rm = TRUE))  # => 97.31 kg 

# Multiple summarise steps allow applying 
# different functions for 1 dependent variable: 
sw %>%
  summarise(n_mass = sum(!is.na(mass)), 
            mn_mass = mean(mass, na.rm = TRUE),
            md_mass = median(mass, na.rm = TRUE),
            sd_mass = sd(mass, na.rm = TRUE),
            max_mass = max(mass, na.rm = TRUE),
            big_mass = any(mass > 1000)
            )
            
# Multiple summarise steps also allow applying 
# different functions to different dependent variables: 
sw %>%
  summarise(# Descriptives of height:  
            n_height = sum(!is.na(height)), 
            mn_height = mean(height, na.rm = TRUE),
            sd_height = sd(height, na.rm = TRUE), 
            # Descriptives of mass:
            n_mass = sum(!is.na(mass)), 
            mn_mass = mean(mass, na.rm = TRUE),
            sd_mass = sd(mass, na.rm = TRUE),
            # Counts of character variables:
            n_names = n(), 
            n_species = n_distinct(species),
            n_worlds = n_distinct(homeworld)
            )

## Note: See 
# ?dplyr::summarise  # for more help and examples. 
```

Note some details:

- `summarise` collapses multiple values into one value and returns a new tibble with as many rows as values computed.

- Each `summarise` step specifies a new variable name (without quotes), followed by `=`, and a _function_ for computing the new variable from existing ones. 

- Multiple `summarise` steps are separated by commas. 

- Variable names are unquoted. 

- See <https://dplyr.tidyverse.org/reference/summarise.html> for examples and useful functions in combination with `summarise`. 


**Practice:** Apply _all_ summary functions mentioned in `?dplyr::summarise` to the `sw` dataset. 


### 6. `group_by` to aggregate variables

Using `group_by` does not change the data, but the _unit of aggregation_ for other commands, which is very useful in combination with `mutate` and `summarise`. 

```{r dplyr_group_by}
# Grouping does not change the data, but lists its groups: 
group_by(sws, species)  # => 38 groups of species

# The same using the pipe: 
sws %>%
  group_by(species)  # => 38 groups of species

# group_by is ineffective by itself, but very powerful 
# (a) in combination with `mutate` and 
# (b) in combination with `summarise`. 

# ad (a):
# In combination with mutate and an aggregation function, 
# group_by changes the unit of aggregation:

sws %>%
  mutate(mn_height_1 = mean(height, na.rm = TRUE)) %>%  # aggregates over ALL cases
  group_by(species) %>%
  mutate(mn_height_2 = mean(height, na.rm = TRUE)) %>%  # aggregates over current group (species)
  group_by(gender) %>%
  mutate(mn_height_3 = mean(height, na.rm = TRUE)) %>%  # aggregates over current group (gender)
  group_by(name) %>%
  mutate(mn_height_4 = mean(height, na.rm = TRUE))      # aggregates over current group (name)

# ad (b):
# group_by is particularly useful in combination 
# with summarise:

sws %>%
  group_by(homeworld) %>%
  summarise(count = n(),
            mn_height = mean(height, na.rm = TRUE),
            mn_mass = mean(mass, na.rm = TRUE)
            )

# Note that this pipe returns a new tibble, 
# with 49 rows (= different levels of homeworld) and 
# - 1 column of the group variable (homeworld) and 
# - 3 columns of the 3 newly summarised variables.


# group_by used with multiple variables yields a tibble 
# containing the combination of all variable levels: 
sw %>%
  group_by(hair_color, eye_color)  # => 35 groups (combinations)

# Counting the frequency of cases in groups:
sw %>%
  group_by(hair_color, eye_color) %>%
  count() %>%
  arrange(desc(n))  

# The same using summarise:
sw %>%
  group_by(hair_color, eye_color) %>%
  summarise(n = n()) %>%
  arrange(desc(n))  

## Note: See 
# ?dplyr::group_by  # for more help and examples. 
```

Note some details:

- `group_by` changes the unit of aggregation for other commands (`mutate` and `summarise`). 

- Variable names are unquoted.

- When using `group_by` with multiple variables, they are separated by commas. 

- Using `group_by` with `mutate` results in a tibble that has the same number of cases (rows) as the original tibble.  By contrast, using `group_by` with `summarise` results in a new tibble with all combinations of variable levels as its cases (rows). 


**Practice:** Create some groups and compute descriptive statistics (n, mean, median, standard deviation, ...) for some variables. For instance, 

- What is the number and mean height and mass of individuals from Tatooine by species and gender? 

- Which humans are more than 5cm taller then the average human overall?

- Which humans are more than 5cm taller than the average human of their own gender?

```{r group_by_ex, echo = FALSE, eval = FALSE}
sws %>%
  filter(homeworld == "Tatooine") %>%
  group_by(species, gender) %>%
  summarise(count = n(),
            mn_height = mean(height),
            mn_mass = mean(mass, na.rm = TRUE)
            )

sws %>% 
  filter(species == "Human") %>%
  mutate(mn_height = mean(height, na.rm = TRUE),
         taller = height > mn_height + 5) %>%
  filter(taller == TRUE)

sws %>% 
  filter(species == "Human") %>%
  group_by(gender) %>% 
  mutate(mn_height_2 = mean(height, na.rm = TRUE),
         taller_2 = height > mn_height_2 + 5) %>%
  filter(taller_2 == TRUE)
```


## Combining commands

The essential `dplyr` commands are quite simple by themselves, but form the basic verbs of a language for data manipulation. The commands become particularly powerful when they are combined into pipes (by using `%>%`). Stringing together several `dplyr` commands allows slicing and dicing data (tibbles or data frames) in a step-wise fashion to run non-trivial data analyses on the fly. 

**Practice: Tidyverse meets universe**

Answer the following questions about the `dplyr::starwars` dataset by using pipes of essential `dplyr` commands:  

**a.** Basics: 

- Save the tibble `dplyr::starwars` as `sw` and report its dimensions. 

**b.** Missing values and known unknowns:

- How many missing (`NA`) values does `sw` contain?

- Which individuals come from an unknown (missing) `homeworld` but have a known `birth_year` or known `mass`?

<!-- Which variable (column) has the most missing values? --> 

<!-- Replace all missing values of `hair_color` (in the variable `sw$hair_color`) by "bald" (2). -->


**c.** Gender issues:

- How many humans are contained in `sw` overall and by gender?

- How many and which individuals in `sw` are neither male nor female?

- Of which species in `sw` exist at least 2 different gender values?


**d.** Popular homes and heights:

- From which `homeworld` do the most indidividuals (rows) come from?

- What is the mean `height` of all individuals with orange eyes from the most popular homeworld?


**e.** Size and mass issues: 

- Compute the median, mean, and standard deviation of `height` for all droids.

- Compute the average height and mass by species and save the result as `h_m`.

- Sort `h_m` to list the 3 species with the smallest individuals (in terms of mean height).

- Sort `h_m` to list the 3 species with the heaviest individuals (in terms of median mass).


**f.** Counting and arranging: 

How many individuals exist of the three most frequent (known) species?


**g.** Grouped mutates: 

- Which individuals are more than 20% lighter than the average mass of individuals of their own homeworld? 


```{r starwars_practice}
# library(tidyverse)
# ?dplyr::starwars

## (a) Basic data properties: ---- 
sw <- dplyr::starwars
dim(sw)  # => 87 rows (denoting individuals) x 13 columns (variables) 

## (b) Missing data: ----- 

## (+) How many missing data points?
sum(is.na(sw))  # => 101 missing values.

# (+) Which individuals come from an unknown (missing) homeworld 
#     but have a known birth_year or mass? 
sw %>% 
  filter(is.na(homeworld), !is.na(mass) | !is.na(birth_year))


## (x) Which variable (column) has the most missing values?
colSums(is.na(sw))  # => birth_year has 44 missing values
colMeans(is.na(sw)) #    (amounting to 50.1% of all cases). 

## (x) Replace all missing values of `hair_color` (in the variable `sw$hair_color`) by "bald": 
# sw$hair_color[is.na(sw$hair_color)] <- "bald"


## (c) Gender issues: ----- 

# (+) How many humans are there of each gender?
sw %>% 
  filter(species == "Human") %>%
  group_by(gender) %>%
  count()

## Answer: 35 Humans in total: 9 females, 26 male.

# (+) How many and which individuals are neither male nor female?
sw %>% 
  filter(gender != "male", gender != "female")

# (+) Of which species are there at least 2 different gender values?
sw %>%
  group_by(species, gender) %>%
  count() %>%  # table shows species by gender: 
  group_by(species) %>%  # Which species appear more than once in this table? 
  count() %>%
  filter(nn > 1)

## (d) Homeworld issues: ----- 

# (+) Popular homes: From which homeworld do the most indidividuals (rows) come from? 
sw %>%
  group_by(homeworld) %>%
  count() %>%
  arrange(desc(n))
# => Naboo (with 11 individuals)

# (+) What is the mean height of all individuals with orange eyes from the most popular homeworld? 
sw %>% 
  filter(homeworld == "Naboo", eye_color == "orange") %>%
  summarise(n = n(),
            mn_height = mean(height))

## Note: 
sw %>% filter(eye_color == "orange") # => 8 individuals


# (+) What is the mass and homeworld of the smallest droid?
sw %>% 
  filter(species == "Droid") %>%
  arrange(height)

## (e) Size and mass: Group summaries: ----- 

# (+) Compute the median, mean, and standard deviation of `height` for all droids.
sw %>%
  filter(species == "Droid") %>%
  summarise(n = n(),
            not_NA_h = sum(!is.na(height)),
            md_height = median(height, na.rm = TRUE),
            mn_height = mean(height, na.rm = TRUE),
            sd_height = sd(height, na.rm = TRUE))

# (+) Compute the average height and mass by species and save the result as `h_m`:
h_m <- sw %>%
  group_by(species) %>%
  summarise(n = n(),
            not_NA_h = sum(!is.na(height)),
            mn_height = mean(height, na.rm = TRUE),
            not_NA_m = sum(!is.na(mass)),
            md_mass = median(mass, na.rm = TRUE)
            )
h_m

# (+) Use `h_m` to list the 3 species with the smallest individuals (in terms of mean height)?
h_m %>% arrange(mn_height) %>% slice(1:3)

# (+) Use `h_m` to list the 3 species with the heaviest individuals (in terms of median mass)?
h_m %>% arrange(desc(md_mass)) %>%  slice(1:3)


## (+) Other questions: ----- 

# (f) How many individuals come from the 3 most frequent (known) species?
sw %>%
  group_by(species) %>%
  count %>%
  arrange(desc(n)) %>%
  filter(n > 1)

# (g) Which individuals are more than 20% lighter (in terms of mass) 
#     than the average mass of individuals of their own homeworld?
sw %>%
  select(name, homeworld, mass) %>%
  group_by(homeworld) %>%
  mutate(n_notNA_mass = sum(!is.na(mass)),  
         mn_mass = mean(mass, na.rm = TRUE),
         lighter = mass < (mn_mass - (.20 * mn_mass))
         ) %>%
  filter(lighter == TRUE)
```

# Exercises (WPA03)

Ideas:

1. Distinguish between mutate and grouped mutate. 

2. Plot same plot from raw data and aggregated data.
    - Plot raw data
    - Then aggregate into table and plot aggregated data.

## Exercise X

#### Star and R wars

Let's tackle the universe with the tidyverse by uncovering even more facts about the `dplyr::starwars` dataset. Answer the following questions by using pipes of basic `dplyr` commands (i.e., arranging, filtering, selecting, grouping, counting, summarizing). 

- Save the tibble `dplyr::starwars` as `sw` and report its dimensions. 


```{r, starwars_transformations_1, include = TRUE}
# library(tidyverse)
# ?dplyr::starwars

## (a) Basic data properties: ---- 
sw <- dplyr::starwars
dim(sw)  # => 87 rows (denoting individuals) x 13 columns (variables) 
```

#### Known unknowns

- How many missing (`NA`) values does `sw` contain?

- Which variable (column) has the most missing values?

- Which individuals come from an unknown (missing) `homeworld` but have a known `birth_year` or known `mass`? 

<!-- Replace all missing values of `hair_color` (in the variable `sw$hair_color`) by "bald".  -->


```{r, starwars_transformations_2, include = TRUE}
## Missing data:

## (+) How many missing data points?
sum(is.na(sw))  # => 101 missing values.

# (+) Which individuals come from an unknown (missing) homeworld 
#     but have a known birth_year or mass? 
sw %>% 
  filter(is.na(homeworld), !is.na(mass) | !is.na(birth_year))

## (x) Which variable (column) has the most missing values?
colSums(is.na(sw))  # => birth_year has 44 missing values
colMeans(is.na(sw)) #    (amounting to 50.1% of all cases). 

## (x) Replace all missing values of `hair_color` (in the variable `sw$hair_color`) by "bald": 
# sw$hair_color[is.na(sw$hair_color)] <- "bald"
```

#### Gender issues 

- How many humans are contained in `sw` overall and by gender?

- How many and which individuals in `sw` are neither male nor female?

- Of which species in `sw` exist at least 2 different gender values?

```{r, starwars_transformations_3, include = TRUE}
## (c) Gender issues: ----- 

# (+) How many humans are there of each gender?
sw %>% 
  filter(species == "Human") %>%
  group_by(gender) %>%
  count()

## Answer: 35 Humans in total: 9 females, 26 male.

# (+) How many and which individuals are neither male nor female?
sw %>% 
  filter(gender != "male", gender != "female")

# (+) Of which species are there at least 2 different gender values?
sw %>%
  group_by(species, gender) %>%
  count() %>%  # table shows species by gender: 
  group_by(species) %>%  # Which species appear more than once in this table? 
  count() %>%
  filter(nn > 1)

# alternative (and shorter) solution:
sw %>%
  group_by(species)%>%
  summarise(n_gender_vals = n_distinct(gender)) %>%
  filter(n_gender_vals >= 2)
```

#### Popular homes and heights 

- From which `homeworld` do the most indidividuals (rows) come from? 

- What is the mean `height` of all individuals with orange eyes from the most popular homeworld? 

```{r, starwars_transformations_4, include = TRUE}
## (d) Homeworld issues: ----- 

# (+) Popular homes: From which homeworld do the most indidividuals (rows) come from? 
sw %>%
  group_by(homeworld) %>%
  count() %>%
  arrange(desc(n))
# => Naboo (with 11 individuals)

# (+) What is the mean height of all individuals with orange eyes from the most popular homeworld? 
sw %>% 
  filter(homeworld == "Naboo", eye_color == "orange") %>%
  summarise(n = n(),
            mn_height = mean(height))

## Note: 
sw %>% 
  filter(eye_color == "orange") # => 8 individuals


# (+) What is the mass and homeworld of the smallest droid?
sw %>% 
  filter(species == "Droid") %>%
  arrange(height)
```

#### Size and mass issues

- Compute the median, mean, and standard deviation of `height` for all droids. 

- Compute the average height and mass by species and save the result as `h_m`. 

- Sort `h_m` to list the 3 species with the smallest individuals (in terms of mean height). 

- Sort `h_m` to list the 3 species with the heaviest individuals (in terms of median mass).

```{r, starwars_transformations_5, include = TRUE}
## Size and mass issues (group summaries): ----- 

# (+) Compute the median, mean, and standard deviation of `height` for all droids.
sw %>%
  filter(species == "Droid") %>%
  summarise(n = n(),
            not_NA_h = sum(!is.na(height)),
            md_height = median(height, na.rm = TRUE),
            mn_height = mean(height, na.rm = TRUE),
            sd_height = sd(height, na.rm = TRUE))

# (+) Compute the average height and mass by species and save the result as `h_m`:
h_m <- sw %>%
  group_by(species) %>%
  summarise(n = n(),
            not_NA_h = sum(!is.na(height)),
            mn_height = mean(height, na.rm = TRUE),
            not_NA_m = sum(!is.na(mass)),
            md_mass = median(mass, na.rm = TRUE)
            )
h_m

# (+) Use `h_m` to list the 3 species with the smallest individuals (in terms of mean height)?
h_m %>% arrange(mn_height) %>% slice(1:3)

# (+) Use `h_m` to list the 3 species with the heaviest individuals (in terms of median mass)?
h_m %>% arrange(desc(md_mass)) %>%  slice(1:3)
```


## Exercise Y

#### Not all outliers are alike 

This task examines the statistical definition of outliers and uses a generated dataset (entitled `out.csv` and available at <http://rpository.com/ds4psy/data/out.csv>). Use the following `read_csv()` command to obtain and load it into R: 

```{r outlier_load_data, echo = TRUE, eval = TRUE}
## Load data (as comma-separated file): 
outliers <- read_csv("http://rpository.com/ds4psy/data/out.csv")  # from online source

## Alternatively (from local source): 
# outliers <- read_csv("out.csv")  # from current directory
```

An _outlier_ can be defined as an individual whose value in some metric deviates by more than a given criterion (e.g., 2 standard deviations) from the mean. But this definition is incomplete unless it also specifies an appropriate reference group. This task explores the implications of different reference groups. 

```{r outlier_create_data, echo = FALSE, eval = FALSE}
# library(tidyverse)

## Creating a suitable data set: 
set.seed(123)
n <- 1000
id <- paste0("nr.", 1:n) # paste0(sample(LETTERS, 1), sample(LETTERS, 1))
sex <- sample(x = c(0, 1), size = n, replace = TRUE)
height <- rep(NA, n)
noise_0 <- round(rnorm(n, mean = 0, sd = 8), 0)
noise_1 <- round(rnorm(n, mean = 0, sd = 11), 0)
height[sex == 0] <- 169 + noise_0[sex == 0]
height[sex == 1] <- 181 + noise_1[sex == 1]

## Modify data:
height <- add_NAs(height, amount = 18)  # 1.8% NA values in height
height[sex == 0] <- add_whats(vec = height[sex == 0], amount = 1, what = 202) # add a tall woman
# sex <- add_NAs(sex, amount = 3)          # 2  NA values in sex

## Save data as tibble: 
data <- as_tibble(data_frame(id, sex, height))
data$sex <- factor(data$sex, labels = c("female", "male"))
names(data) <- c("id", "sex", "height")

## Check data:
mean(data$sex == "female", na.rm = TRUE)  # => .507
mean(data$height, na.rm = TRUE)           # => 174.7006 (with seed 123)

## Writing out data:
write_csv(data, "out.csv")

## Reading in again (from csv-file):
outliers <- read_csv("out.csv")
outliers
```

#### Basics

- Save the data into a tibble `outliers` and report its number of observations and variables, and their types.

- How many missing data values are there in `outliers`?

- What is the gender (or `sex`) distribution in this sample? 

- Create a plot that shows the distribution of `height` values for each gender. 

<!-- fig.show options: "asis", "hide", "hold", "animate" --> 

```{r outlier_solution_1, include = TRUE, fig.show = "asis"}
## Basics: ----- 

## (a) Load and inspect data:
# outliers <- read_csv("out.csv") # read in csv-file
# outliers <- as_tibble(data)   # if data is not already a tibble
dim(outliers)  # => 1000 observations (rows) x 3 variables (columns)

## (b) Missing data points: 
sum(is.na(outliers))  # => 18 missing values

## (c) Gender distribution: 
outliers %>% 
  group_by(sex) %>% 
  count()
# => 50.7% females, 49.3% males.

## (d) Distributions of `height` as density plot: 
ggplot(outliers, aes(x = height)) +
  geom_density(fill = "gold", alpha = 2/3) +
  geom_density(aes(fill = sex), alpha = 2/5) +
  labs(title = "Distribution of heights overall and by gender", 
       fill = "Gender") + 
  scale_fill_manual(values = c("firebrick", "steelblue3")) +
  theme_bw()

# Note: To avoid the Warning about removing 18 cases with NA-values, 
#       we could first filter out those cases:
# non_NA_data <- filter(outliers, !is.na(height))

## Alternative solution as 2 histograms: 
ggplot(outliers) +
  facet_wrap(~sex) + 
  geom_histogram(aes(x = height, fill = sex), binwidth = 5, color = "grey10") +
  labs(title = "Distribution of heights by gender",
       fill = "Gender") +
  scale_fill_manual(values = c("firebrick", "steelblue3")) +
  theme_bw()
```

#### Outliers

Compute 2 new variables that signal and distinguish between 2 types of outliers in terms of `height`: 

1. outliers relative to the `height` of the _overall sample_ (i.e., individuals with `height` values deviating more than 2 SD from the overall mean of `height`);

2. outliers relative to the `height` of _some subgroup_'s mean and SD. Here, a suitable subgroup to consider is every person's gender 
(i.e., individuals with `height` values deviating more than 2 SD from the mean `height` of their own gender).

**Hints:** As both variable signal whether or not someone is an outlier they should be defined as logicals (being either `TRUE` or `FALSE`) and added as new columns to `data` (via appropriate `mutate` commands). While the 1st variable can be computed based on the mean and SD of the overall sample, the 2nd variable can be computed after grouping `outliers` by gender and then computing and using the corresponding mean and SD values. The absolute difference between 2 numeric values `x` and `y` is provided by `abs(x - y)`. 

Use the 2 new variables to define and identify 2 subgroups of people: 

1. `out_1`: Individuals (females and males) with `height` values that are outliers relative to _both_ the entire sample _and_ the sample of their own gender. How many such individuals are in `outliers`?

2. `out_2`: Individuals (females and males) with `height` values that are _not_ outliers relative to the entire population, but _are_ outliers relative to their own gender. How many such individuals are in `outliers`?


```{r outlier_solution_2, include = TRUE, fig.show = "asis"}
## Outliers: ----- 

## (+) Included in data_out (below), but also possible to do separately:  
##     Compute the number, means and SD of height values in 2 ways: 

## 1. overall: 
outliers %>%
  summarise(n = n(),
            n_not_NA = sum(!is.na(height)),
            mn_height = mean(height, na.rm = TRUE),
            sd_height = sd(height, na.rm = TRUE))

## 2. by gender:
outliers %>%
  group_by(sex) %>%
  summarise(n = n(),
            n_not_NA = sum(!is.na(height)),
            mn_height = mean(height, na.rm = TRUE),
            sd_height = sd(height, na.rm = TRUE))


## Detecting and marking outliers (by logical variables): 
## Compute the means, SDs, and corresponding outliers in 2 ways:
crit <- 2  # criterion value for detecting outliers (in SD units)

data_out <- outliers %>%      
  # 1. Compute means, SD, and outliers for overall sample: 
  mutate(mn_height  = mean(height, na.rm = TRUE),  
         sd_height  = sd(height, na.rm = TRUE),
         out_height = abs(height - mn_height) > (crit * sd_height)) %>%
  group_by(sex) %>%       
  # 2. Compute same metrics for subgroups (by sex):
  mutate(mn_sex_height  = mean(height, na.rm = TRUE), 
         sd_sex_height  = sd(height, na.rm = TRUE),
         out_sex_height = abs(height - mn_sex_height) > (crit * sd_sex_height))

knitr::kable(head(data_out))


## Identify 2 types of outliers:

## 1. Outliers relative to the entire population AND to their own gender: 
out_1 <- data_out %>%
  filter(out_height & out_sex_height) %>%
  arrange(sex, height)

nrow(out_1) # => 21 individuals. 

## 2. Outliers relative to their own gender, but NOT relative to the entire population:
out_2 <- data_out %>%
  filter(!out_height & out_sex_height) %>%
  arrange(sex, height)  

nrow(out_2) # => 24 individuals.
```

#### Bonus task

Visualize the raw values and distributions of `height` for both types of outliers (`out_1` and `out_2`) in 2 separate plots and describe the `height` and `sex` combination of the individuals shown in each plot. 

<!-- fig.show options: "asis", "hide", "hold", "animate" --> 
 
```{r outlier_solution_3, include = TRUE, fig.show = "asis"}
## Bonus task: -----   

## Visualization and interpretation of both types of outliers: 

## 1. Showing out_1: 
ggplot(out_1, aes(x = sex, y = height)) +
  geom_violin(aes(fill = sex)) + 
  geom_jitter(size = 4, alpha = 2/3) + 
  scale_fill_manual(values = c("firebrick", "steelblue3")) +
  labs(title = "Outliers relative to both overall sample and gender", 
       x = "Gender", y = "Height (in cm)", 
       fill = "Gender:") +
  theme_bw()

# Interpretation: 
# `out_1` contains mostly short women (except for 1 tall woman) 
#  and mostly tall men (except for 2 short men). 

## 2. Showing out_2: 
ggplot(out_2, aes(x = sex, y = height)) +
  geom_violin(aes(fill = sex)) + 
  geom_jitter(size = 4, alpha = 2/3) + 
  scale_fill_manual(values = c("firebrick", "steelblue3")) +
  labs(title = "Outliers relative to gender but not overall sample", 
       x = "Gender", y = "Height (in cm)", 
       fill = "Gender:") +
  theme_bw()

# Interpretation: 
# `out_2` contains individuals which are either tall women or short men.
```





# More on data transformation 

For more details on `dplyr`, 

- study `vignette("dplyr")` and the documentation for `?arrange`, `?filter`, `?select`, etc. 
- study <https://dplyr.tidyverse.org/> and its examples; 
- see the [cheat sheet on data transformation](https://www.rstudio.com/resources/cheatsheets/); 
- read [Chapter 5: Data transformation](http://r4ds.had.co.nz/transform.html) and complete its exercises. 


# Conclusion

<!-- Table with links: -->

All [ds4psy](http://rpository.com/ds4psy/) essentials so far: 

Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | **Transforming data** |
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 

<!--
Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | [Transforming data](http://rpository.com/ds4psy/essentials/transform.html) |
4.  | [Exploring data (EDA)](http://rpository.com/ds4psy/essentials/EDA.html) | 
5.  | [Creating and using tibbles](http://rpository.com/ds4psy/essentials/tibble.html) |
6.  | [Tidying data](http://rpository.com/ds4psy/essentials/tidy.html) | 
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 
-->


[Last update on `r Sys.time()` by [hn](http://neth.de/).]  

<!-- eof. --> 