---
title: "Joining data, with solutions (ds4psy)"
author: "Hansjörg Neth, SPDS, uni.kn"
date: "2019 05 22"
output:
   rmdformats::html_clean: # html_clean html_docco readthedown material #
     code_folding: show # hide
     toc_float: true
     toc_depth: 3
     highlight: default # textmate default kate haddock monochrome #
     lightbox: true # true by default
     fig_width: 7 # in inches
editor_options: 
  chunk_output_type: console # inline
---

<!-- Example of essential commands | ds4psy: Winter/Spring 2018/2019 -->

```{r preamble, echo = FALSE, eval = TRUE, cache = FALSE, message = FALSE, warning = FALSE}
## (a) Housekeeping: -----
rm(list=ls()) # clean all.

## (b) Current file name and path: ----- 
# my_path <- dirname(rstudioapi::getActiveDocumentContext()$path)
# my_path
# setwd(my_path) # set to current directory
setwd("~/Desktop/stuff/Dropbox/_code/R/_teachR/ds4psy/_essentials") # set to current directory
# list.files() # all files + folders in current directory
fileName <- "join.Rmd"

## (c) Packages: ----- 
library(knitr)
library(rmdformats)
library(tidyverse)

## (d) Global options: ----- 
options(max.print = "75")
opts_chunk$set(echo = TRUE,
	             cache = TRUE,
               prompt = FALSE,
               tidy = FALSE,
               collapse = TRUE, # set TRUE in answers 
               comment = "#>",
               message = FALSE,
               warning = FALSE,
               ## Default figure options:
               fig.width = 7, 
               fig.asp = .618, # golden ratio
               out.width = "75%",
               fig.align = "center"
               )
opts_knit$set(width = 75)

## (e) Custom functions: ----- 
source(file = "~/Desktop/stuff/Dropbox/_code/R/_teachR/ds4psy/R/custom_functions.R")
```

# Introduction

This file contains **essential commands** from [Chapter 13: Relational data](https://r4ds.had.co.nz/relational-data.html) of the textbook [r4ds](http://r4ds.had.co.nz) and corresponding examples and exercises. 
A command is considered "essential" when you really need to _know_ it and need to know _how to use_ it to succeed in this course. 

<!-- Table with links: -->

All [ds4psy](http://rpository.com/ds4psy/) essentials so far: 

<!-- ds4psy logo 1: -->
<a href="http://rpository.com/ds4psy/">
<img src = "./../images/logo/logo_200_bwg.png" alt = "ds4psy" width = "110px" align = "right" style = "width: 150px; float: right; border:11;"/>
</a>

Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | [Transforming data](http://rpository.com/ds4psy/essentials/transform.html) |
4.  | [Exploring data (EDA)](http://rpository.com/ds4psy/essentials/explore.html) | 
5.  | [Tibbles](http://rpository.com/ds4psy/essentials/tibbles.html) |
6.  | [Importing data](http://rpository.com/ds4psy/essentials/import.html) |
7.  | [Tidying data](http://rpository.com/ds4psy/essentials/tidy.html) |
8.  | **Joining data** [*](http://rpository.com/ds4psy/essentials/join.html) |
9.  | [Functions](http://rpository.com/ds4psy/essentials/function.html) |
10. | [Iteration](http://rpository.com/ds4psy/essentials/iteration.html) |
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 


<!--
Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | [Transforming data](http://rpository.com/ds4psy/essentials/transform.html) |
4.  | [Exploring data (EDA)](http://rpository.com/ds4psy/essentials/explore.html) | 
5.  | [Tibbles](http://rpository.com/ds4psy/essentials/tibbles.html) |
6.  | [Importing data](http://rpository.com/ds4psy/essentials/import.html) |
7.  | [Tidying data](http://rpository.com/ds4psy/essentials/tidy.html) |
8.  | [Joining data](http://rpository.com/ds4psy/essentials/join.html) |
9.  | [Functions](http://rpository.com/ds4psy/essentials/function.html) |
10. | [Iteration](http://rpository.com/ds4psy/essentials/iteration.html) |
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 
-->

## Course coordinates

<!-- uni.kn logo and link: -->  
<!-- ![](./inst/images/uniKn_logo.png) --> 
<a href="https://www.uni-konstanz.de/">
<img src = "../inst/images/uniKn_logo.png" alt = "uni.kn" align = "right" width = "300" style = "width: 300px; float: right; border:20;"/>
<!-- <img src = "./inst/images/uniKn_logo_s.png" alt = "uni.kn" style = "float: right; border:20;"/> --> 
</a>

* PSY-15150, at the [University of Konstanz](https://www.uni-konstanz.de/) by [Hansjörg Neth](http://neth.de/) (<h.neth@uni.kn>,  [SPDS](https://www.spds.uni-konstanz.de/), office D507).
* Summer 2019: Mondays, 15:15--16:45, D435.  
* Links to current [course syllabus](http://rpository.com/ds4psy/) | [ZeUS](https://zeus.uni-konstanz.de:443/hioserver/pages/startFlow.xhtml?_flowId=detailView-flow&unitId=5101&periodId=179&navigationPosition=hisinoneLehrorganisation,examEventOverviewOwn) |  [Ilias](https://ilias.uni-konstanz.de/ilias/goto_ilias_uni_crs_863036.html) 
* [ds4psy](https://bookdown.org/hneth/ds4psy/>) essentials and WPAs 


## Preparations

Create an R script (`.R`) or an R-Markdown file (`.Rmd`) and load the R packages of the `tidyverse`. (**Hint:** Structure your script by inserting spaces, meaningful comments, and sections.) 

```{r layout_template, echo = TRUE, eval = FALSE}
## Joining data | ds4psy
## 2019 01 21
## ----------------------------

## Preparations: ----------

library(tidyverse)

## 1. Topic: ----------

# etc.

## End of file (eof). ----------  
```

To use [R Markdown](https://rmarkdown.rstudio.com), create a corresponding file and save it with the `.Rmd` extension (e.g., by selecting `File > New File > R Markdown`). 
For instructions on combining text and code, see [Chapter 27: R Markdown](https://r4ds.had.co.nz/r-markdown.html) of our textbook, or use one of the following templates:  

- minimal template:  `rmd_template_s` [in [.Rmd](http://rpository.com/down/temp/rmd_template_s.Rmd) | [.html](http://rpository.com/down/temp/rmd_template_s.html) format]

- medium template: `rmd_template_m` [in [.Rmd](http://rpository.com/down/temp/rmd_template_m.Rmd) | [.html](http://rpository.com/down/temp/rmd_template_m.html) format]

- explicit explanations: `Rmarkdown_basics` [in [.Rmd](http://rpository.com/down/temp/Rmarkdown_basics.Rmd) | [.html](http://rpository.com/down/temp/Rmarkdown_basics.html) format]

**Hint:** Try to _knit_ your `.Rmd` file immediately after saving it and marvel at the beauty of the resulting `.html`-file. If this works, keep doing this routinely from now on, putting all your R-code into code chunks, and any text (like headings or conclusions) that describes or explains what you are doing outside of them. From now on, you can share your `.html` output files, rather than your `.Rmd` source files when showing off your R and data science skills.


# Joining data

All the data we considered so far appeared in the form of a single table (or multiple versions of the same table, some of which needed [transforming](http://rpository.com/ds4psy/essentials/transform.html) and [tidying](http://rpository.com/ds4psy/essentials/tidy.html) etc.). 
In reality, however, many datasets are distributed over multiple tables. To analyze such data, an important first step is to combine those tables without messing up their contents. To combine data from multiple tables, we need to specify how they are related (which is why this chapter is called "relational data"). A _relation_ between tables typically is a variable that occurs in both tables: Provided that this variable has the same meaning in both tables, it is called a _key_ (see [Chapter 13.3](https://r4ds.had.co.nz/relational-data.html#keys) for details) and allows linking the observations (rows) from one table to those of the other one. 

Joining 2 tables is simple and straightforward when variables have common variables (names and types) and both tables describe the same cases (rows). However, it's clear that we may encounter problems in which one table uses different names or types than the other one and that both tables can differ in the number of cases they contain (e.g., one may contain a sub-set of cases of the other one, or both contain some common but also some unique cases). In these instances, it's absolutely crucial that we first understand each table by itself (its dimensions, cases and variables, contents) and their relation to each other (e.g., which cases and variables occur in both tables) before trying to join them.[^1] 

[^1]: For this reason, most real-world joins are preceded by sequences of `select`, `mutate`, and `arrange` commands on one or both tables.

### Terminology 

The verb "join" and the term "relational data" comes from relational databases (see [in Wikipedia](https://en.wikipedia.org/wiki/Join_(SQL)) and relational algebra (see [in Wikipedia](https://en.wikipedia.org/wiki/Relational_algebra)). 

### Base R vs. tidyverse tools

When we are ready to join tables, base R offers basic `base::rbind` and `base::cbind` commands (to bind rows or columns of data), but these are intended for tables with identical variables or cases, respectively. Mutating joins of 2 data frames can be achieved by using `base::merge` (see below). 

Alternatively, the `tidyverse` package `dplyr` (whose so-called 1-table verbs we have used for data [transformation](http://rpository.com/ds4psy/essentials/transform.html)) contains additional _2-table verbs_ 
that allow joining 2 tables of data with 3 different types of commands: 

1. _Mutating joins_ add new _variables_ (columns) to one table from matching cases (rows) of another table. 

2. _Filtering joins_ filter _observations_ (rows) from one table based on whether or not they match a case (row) in another table. 

3. _Set operations_ combine the observations in two tables as if they were set elements. 

In the following, we will briefly describe the essential commands for each type of join. 
(See [Chapter 13: Relational data](https://r4ds.had.co.nz/relational-data.html) and the `vignette("two-table")` for additional details.)


## 1. Mutating joins

Mutating joins combine the variables (columns) of 2 tables `x` and `y`. 
The term _mutating_ is used in analogy to the `dplyr::mutate` command: Just as `mutate` creates new variables (columns), 
a mutating join adds new variables (columns) to a table `x` from matching cases (rows) of another table `y`. 

### Commands

There are 4 types of mutating joins to combine the cases (rows) and variables (columns) of tables `x` and `y`: 

1. `left_join(x, y)`: Return all rows from `x`, and all columns from `x` and `y`. 
Rows in `x` with no match in `y` will have `NA` values in the new columns. 
If there are multiple matches between `x` and `y`, all combinations of the matches are returned.

2. `right_join(x, y)`: Same as `left_join(y, x)`, and hence redundant. 

3. `full_join(x, y)`: Return all rows and all columns that exist in `x` or in `y`. 
If there are non-matching values, return `NA` for the one missing. 

4. `inner_join(x, y)`: Return all rows from `x` where there are matching values in `y`, and all columns from `x` and `y`. 
If there are multiple matches between `x` and `y`, all combination of the matches are returned.

See Section 13.4 on [mutating joins](https://r4ds.had.co.nz/relational-data.html#mutating-joins) for graphical illustrations. 


#### Inner vs. outer joins

All 4 types of mutating joins combine variables (columns) from 2 tables, but differ in preserving in their cases (rows) in the output table. An _inner_ join only keeps the cases (or rows) that appear in _both_ tables. By contrast, the first three join commands keep cases (observations) that appear in at least one of the tables and are also called _outer_ joins. 
The 3 types of outer joins also differ with respect to the cases they preserve: 

1. `left_join` keeps all cases of `x`.
2. `right_join` keeps all cases of `y`.
3. `full_join` keeps all cases of `x` or `y`.

#### Key variables

Beyond specifying the 2 tables to join, all commands take a `by` argument:

- `by` specifies a character vector of variables by which we want to join the tables (so-called _keys_).  
(See Section 13.3 on [keys](https://r4ds.had.co.nz/relational-data.html#keys) for the distinction between _primary_ and _foreign_ keys.)

- If `by = NULL` (as by default) `*_join` will perform a _natural_ join, using _all variables with common names_ across the 2 tables. 
A message lists the variables that are used, so that we can verify that this is what we wanted. 

- To join by differently named variables on `x` and `y`, we can provide a named vector. For instance, `by = c("a" = "b")` will match a key variable `a` in table `x` to a key variable `b` in table `y`.


### Examples

To test these commands, we load the following data files:

- [data_t1](http://rpository.com/ds4psy/data/data_t1.csv)
- [data_t2](http://rpository.com/ds4psy/data/data_t2.csv)

```{r load_t1_t2}
# Load data:
data_t1 <- read_csv(file = "http://rpository.com/ds4psy/data/data_t1.csv")
data_t2 <- read_csv(file = "http://rpository.com/ds4psy/data/data_t2.csv")

# Copy data:
t1 <- data_t1
t2 <- data_t2

# Inspect data:
t1
t2
```

Note that `t1` and `t2` are both 20 x 4 tibbles and appear to contain the responses or test scores of people. 
This suggests that they may be 2 measurements of the same people. However, before jumping into joining the tables, we should check whether they really contain the same people:

```{r check_t1_t2}
# Do both tables contain common variables?
sum(names(t1) %in% names(t2))        # Number of common variables: 
names(t1)[names(t1) %in% names(t2)]  # Names of common variables: 

# Arrange the rows of tables by common variables:
t1 <- t1 %>% arrange(name, gender) 
t2 <- t2 %>% arrange(name, gender)

# Are they equal in both tables?
all.equal(t1$name, t2$name)
all.equal(t1$gender, t2$gender)
```

This confirms our intuition: `t1` and `t2` contain 2 variables of demographic information (`name` and `gender`) of 20 people and each table contains 2 additional variables (measurements or test scores). 

#### Joining 2 tables with identical cases

When both tables contain identical cases, the 4 mutating join commands all yield the same result:

```{r mutating_joins_1}
# 1. left_join:
m1 <- left_join(t1, t2)
m1

# 2. right_join:
m2 <- right_join(t1, t2)
m2

# 3. full_join:
m3 <- full_join(t1, t2)
m3

# 4. inner_join:
m4 <- inner_join(t1, t2)
m4

# Verify equality:
all.equal(m1, m2)
all.equal(m1, m3)
all.equal(m1, m4)
```

Note that the join commands automatically used the 2 common variables as `key` variables to join the tables (i.e., used 
`by = c("name", "gender")`). This raises the question: What would happen if we only specified one of them? Let's check:

```{r mutating_joins_duplicate_vars}
left_join(t1, t2, by = "name")   # => 2 gender columns, distinguished by suffixes .x and .y
left_join(t1, t2, by = "gender") # => 2 name columns, distinguished by suffixes .x and .y

# To control the suffix:
left_join(t1, t2, by = "name", suffix = c("_1", "_2"))
```

We see that common variables _not_ used for joining the tables get duplicated in the joint table and distinguished by a unique suffix. 

#### Joining 2 tables with different cases

To see and appreciate the differences between the 4 mutating joins, we need tables that contain different and repeated cases. 
We can easily create these by selecting and duplicating some cases in each of our tables:[^2]

[^2]: It's not crucial to understand the following code. It only serves to select some random cases from each table and create some duplicate cases in each.

```{r sample_and_copy_cases}
# Copy data (again): ------ 
t3 <- data_t1
t4 <- data_t2

# Modify both tables: ------ 
# (a) Draw n random rows (samples):
set.seed(12)  # for replicability
n <- 8
s1 <- sample(1:nrow(t3), size = n, replace = FALSE)  # n random values from 1 to nrow(t3)
s2 <- sample(1:nrow(t4), size = n, replace = FALSE)  # n random values from 1 to nrow(t4)

# Reduce rows and arrange both tables:
t3 <- t3[s1, ]
t4 <- t4[s2, ]

# (b) Duplicate m random rows:
set.seed(23)  # for replicability
m <- 2
d1 <- sample(1:nrow(t3), size = m, replace = FALSE)  # n random values from 1 to nrow(t3)
d2 <- sample(1:nrow(t4), size = m, replace = FALSE)  # n random values from 1 to nrow(t4)

# Duplicate sampled rows:
t3 <- rbind(t3, t3[d1, ])
t4 <- rbind(t4, t4[d2, ])

# Arrange tables:
t3 <- t3 %>% arrange(name, gender)
t4 <- t4 %>% arrange(name, gender)
```

The resulting tables `t3` and `t4` are both 10 x 4 tibbles and contain some common and some unique cases (people). 
In addition, each table contains 2 people twice: 

```{r inspect_t3_t4}
# Inspect resulting tables: ------ 
t3  # 10 x 4
t4  # 10 x 4

# Common cases:
t3$name[t3$name %in% t4$name]  # people in t3 that also appear in t4
t4$name[t4$name %in% t3$name]  # people in t4 that also appear in t3

# Unique cases:
t3$name[!t3$name %in% t4$name]  # people in t3 that are NOT in t4
t4$name[!t4$name %in% t3$name]  # people in t4 that are NOT in t3
```

Now let's re-do the 4 mutating joins with `t3` and `t4` and inspect the resulting tables:

```{r mutating_joins_2}
# 1. left_join:
m5 <- left_join(t3, t4)
m5  # => 12 x 6 table, containing all cases of t3, plus additional cases for duplicate cases.

# 2. right_join:
m6 <- right_join(t3, t4)
m6  # => 12 x 6 table, containing all cases of t4, plus additional cases for duplicate cases.

all.equal(m5, m6)  # shows differences, but 
all.equal(m5, right_join(t4, t3)) # is TRUE

# 3. full_join:
m7 <- full_join(t3, t4)
m7  # => 17 x 6 table, i.e. all cases of t3 and of t4

# 4. inner_join:
m8 <- inner_join(t3, t4)
m8  # => 7 x 6 table, i.e. all cases that were in both t3 and t4
```

Thus, when joining 2 tables with different cases, it really matters which join-command we're using. 

## B. Filtering joins

Filtering joins match cases (or observations) in the same way as mutating joins, 
but only affect the _cases_ (observations or rows), 
_not_ the variables (columns). There are 2 types of filtering joins:

1. `semi_join(x, y)` _keeps_ all observations in `x` that have a match in `y` 
(i.e., observations in `x` without a match in `y` are dropped). 

2. `anti_join(x, y)` _drops_ all observations in `x` that have a match in `y` 
(i.e., observations in `x` without a match in `y` are kept).

See Section 13.5 on [filtering joins](https://r4ds.had.co.nz/relational-data.html#filtering-joins) for graphical illustrations. 

#### Notes 

- `anti_join(x, y)` yields the _complement_ of `semi_join(x, y)` (with respect to `x`). 

- Both types of filtering joins concern only the cases of `x` and filter them by the cases of `y`. 

- The resulting table of a filtering join preserves the variables of `x`, not the variables of `y`. 

### Examples

```{r filtering_joins}
semi_join(t3, t4) # keeps cases in t3 that are also in t4

anti_join(t3, t4) # keeps cases in t3 that are NOT in t4

# Note: 
full_join(semi_join(t3, t4), anti_join(t3, t4))
# contains the same cases as t3.
```

### Use cases

Filtering joins typically reduce the cases of `x` to the cases contained in `y` (`semi_join`) or to the cases not contained in `y` (`anti_join`). Typical use cases include: 

- Semi-joins are useful for matching filtered summary tables back to the original rows: 

```{r use_semi}
## Data: 
sw <- dplyr::starwars
# sw  # 87 x 13

# Determine the top 3 homeworlds of Humans:
top_3_human_homes <- sw %>% 
  filter(species == "Human") %>%
  group_by(homeworld) %>%
  count() %>%
  arrange(desc(n)) %>%
  head(3)
top_3_human_homes

# Which individuals (human and non-human) are from these homeworlds?
semi_join(sw, top_3_human_homes, by = "homeworld")  # => 31 individuals
```

- Anti-joins are useful for diagnosing join mismatches: 

```{r use_anti}
left_join(t3, t4)  # adds variables (columns) of t4 to cases (rows) of t3

anti_join(t3, t4)  # shows cases in t3 NOT in t4 (with NA values in new variables)
anti_join(t4, t3)  # shows cases in t4 NOT in t3 (missing from joined table)
```

See Section 13.6 for common [join problems](https://r4ds.had.co.nz/relational-data.html#join-problems) and ways of dealing with them. 


## C. Set operations

Set operations on 2 tables `x` and `y` expect both tables to have the same variables. 
They always compare complete rows of `x` and `y`, and compare the values of every variable.
Treating the observations like sets yields 3 different commands: 

1. `intersect(x, y)` returns only observations that occur in both `x` and in `y`.

2. `union(x, y)` returns all unique observations in `x` and `y`.

3. `setdiff(x, y)` return those observations that occur in `x`, but not in `y`.

### Examples

```{r set_operations}
# Data: 
sw <- dplyr::starwars %>%
  select(name:species)  # only first 10 columns of starwars
sw  # 87 x 10

# Create 2 filtered sub-sets:
s1 <- sw %>% filter(species == "Human", height < 180)
s1  # 15 indivduals

s2 <- sw %>% filter(homeworld == "Naboo" | homeworld == "Tatooine")
s2  # 21 individuals

# Set operations:
intersect(s1, s2)  #  8 individuals are in both s1 and s2
union(s1, s2)      # 28 individuals are in the union of both sets
setdiff(s1, s2)    #  7 individuals in s1 and not in s2
setdiff(s2, s1)    # 13 individuals in s2 and not in s1
```

## Using `merge`

The base R command `base::merge()` can perform all 4 types of mutating join:
  
   `dplyr`:      |      `merge`:          | 
-----------------|------------------------|  
`inner_join(x, y)` |	`merge(x, y)` |
`left_join(x, y)`  |	`merge(x, y, all.x = TRUE)` | 
`right_join(x, y)` |	`merge(x, y, all.y = TRUE)` |
`full_join(x, y)`  |	`merge(x, y, all.x = TRUE, all.y = TRUE)` |
 
Note that `merge` also accepts various `by` commands (see `?merge` for documentation).  

The advantages of the `dplyr` verbs are:

1. they more clearly convey the intended join (by verbally expressing what is implied by the arguments of `merge`); 

2. they are faster and preserve the order of cases (rows). 

(See Section 13.4.7 for [other implementations](https://r4ds.had.co.nz/relational-data.html#other-implementations) of joins, e.g., in SQL.)


# Exercises (WPA08)

Here are the exercises of WPA08 and possible solutions for them.

<!-- Multiple choice questions (MC): ------ 

## Multiple choice [MC] questions: -----

# (+) Which of the following join types are _symmetrical_ (in the sense of yielding 
#     the same set of observations for join(x, y) and join(y, x), 
#     but may vary in the order of variables (columns)):

# - inner_join(x, y) (TRUE)
# - left_join(x, y)
# - right_join(x, y)
# - full_join(x, y)  (TRUE)
# - semi_join(x, y)
# - anti_join(x, y)
# - intersect(x, y)  (TRUE)
# - union(x, y)      (TRUE)
# - setdiff(x, y)


# (+) Which of the following join types is the default and most commonly used one, 
#     as it preserves original observations in x even when there is no match with y?

# - `full_join(x, y)`
# - `inner_join(x, y)` 
# - `semi_join(x, y)` 
# - `left_join(x, y)` (TRUE)
# - `right_join(x, y)`


# (+) Which of the following yields the same result (i.e., the same set of obervations) 
#     as left_join(x, y)?

# - anti_join(x, y)
# - anti_join(y, x)
# - semi_join(x, y)
# - semi_join(y, x)
# - right_join(x, y)
# - right_join(y, x)  (TRUE)
# - setdiff(x, y)
# - setdiff(y, x)


# (+) Which of the following is the _inverse_ (or _complement_) of an `anti-join`?

# - `full_join`
# - `inner_join` 
# - `semi_join` (TRUE)
# - `left_join`
# - `right_join`

End of multiple choice (MA) questions. -->


## Exercise 1

Given the definitions of [data_t1](http://rpository.com/ds4psy/data/data_t1.csv) and [data_t2](http://rpository.com/ds4psy/data/data_t2.csv), 
and `t3` and `t4` above, evaluate and explain the result of:  

1. `all.equal(left_join(data_t1, data_t2), right_join(data_t2, data_t1))`

2. `all.equal(full_join(data_t1, data_t2), inner_join(data_t2, data_t1))`

3. `all.equal(data_t1, semi_join(data_t1, data_t2))`

4. `all.equal(t1, full_join(semi_join(t1, t3), anti_join(t1, t3)))`

<!-- Solutions: --> 

#### Solutions

```{r ex1}
# Load data:
data_t1 <- read_csv(file = "http://rpository.com/ds4psy/data/data_t1.csv")
data_t2 <- read_csv(file = "http://rpository.com/ds4psy/data/data_t2.csv")

# 1. 
all.equal(left_join(data_t1, data_t2), right_join(data_t2, data_t1))  # => TRUE, 
# as left_join(x, y) is the same as right_join(y, x) irrespective of x and y. 

# 2. 
all.equal(full_join(data_t1, data_t2), inner_join(data_t2, data_t1))  # => TRUE, 
# as data_t1 and data_t2 contain the same cases (despite different orders).
# Proof: See comparison of arranged tables (from above):
all.equal(t1$name, t2$name)
all.equal(t1$gender, t2$gender)

# 3. 
all.equal(data_t1, semi_join(data_t1, data_t2))  # => TRUE, 
# as data_t1 and data_t2 contain the same cases (despite different orders).
# Hence, semi_join does not drop any cases of data_t1 and remains the same as data_t1.

# 4. 
all.equal(t1, full_join(semi_join(t1, t3), anti_join(t1, t3)))  # => TRUE, 
# Explanation:
# - semi_join(t1, t3) # contains  8 cases of t1 with a match in t3
# - anti_join(t1, t3) # contains 12 cases of t1 with NO match in t3
# - full_join() or rbind() combine both parts (rows) into the cases of t1 again.
```

## Exercise 2

In the previous session on [Tidying data](http://rpository.com/ds4psy/essentials/tidy.html) we encountered the `tidyr::table4a` and `tidyr::table4b`. 

1. Join these tables into one table that contains the same information as `tidyr::table1`.

2. Use `tidyr` and `dplyr` commands to transform the resulting join into `tidyr::table1`. 

<!-- Solutions: --> 

#### Solutions

```{r ex2}
# Data: 
t4a <- tidyr::table4a
t4b <- tidyr::table4b

# Inspection: 
t4a
t4b

# Analysis:  Both 3 x 3 tables contain the same 3 instances of "country".
# When we join them by "country", all 4 mutating joins will yield the same result. 
# However, we must make sure that only "country" is used as key, 
# as the other 2 matching variable names (`1999` and `2000`) denote different variables
# in different tables. 

# 1. Alternative solutions for joining both tables: ------  
j1 <- left_join(t4a, t4b, by = "country", suffix = c("_cases", "_population"))
j2 <- right_join(t4a, t4b, by = "country", suffix = c("_cases", "_population"))
j3 <- full_join(t4a, t4b, by = "country", suffix = c("_cases", "_population"))
j4 <- inner_join(t4a, t4b, by = "country", suffix = c("_cases", "_population"))

# Show equality:
all.equal(j1, j2)
all.equal(j1, j3)
all.equal(j1, j4)

# Print result:
knitr::kable(j1, caption = "Joined table of table4a and table4b.")


# 2. Tidying/transforming result table: ------ 
j1_trans <- j1 %>%
  tidyr::gather(key = "key", value = "count", `1999_cases`:`2000_population`) %>%
  tidyr::separate(col = key, into = c("year", "type")) %>%
  dplyr::arrange(country, year) %>%
  tidyr::spread(key = type, value = count)
j1_trans

# Change variable type of year:
j1_trans$year <- as.integer(j1_trans$year)  # from character to integer

# Show equality: 
all.equal(tidyr::table1, j1_trans)  # TRUE
```

## Exercise 3

This exercise uses the following data files:

- [data_t3](http://rpository.com/ds4psy/data/data_t3.csv)
- [data_t4](http://rpository.com/ds4psy/data/data_t4.csv)

1. Import both tables of data (as `data_t3` and `data_t4`) and check out each table individually, before comparing them to each other. 
Do both tables contain the same cases and variables?

<!-- Solutions: --> 

#### Solutions

```{r ex3_1}
# Load data: 
data_t3 <- read_csv(file = "http://rpository.com/ds4psy/data/data_t3.csv")
data_t4 <- read_csv(file = "http://rpository.com/ds4psy/data/data_t4.csv")

# Inspect tables:
data_t3  # 20 x 4
data_t4  # 20 x 4

# Both tables seem similar, but do not share variable names.
# Are names and initials identical?

# Arrange both tables by first 2 variables:
data_t3 <- data_t3 %>% arrange(name, gender)
data_t4 <- data_t4 %>% arrange(initials, sex)

all.equal(data_t3$name, data_t4$initials)  # TRUE
all.equal(data_t3$gender, data_t4$sex)     # TRUE
# => Both tables seem to contain the same people as cases!
```

2. Join both tables by using only the `name` variable of `data_t3` and `initials` variable of `data_t4` as keys.  
Why is this difficult or impossible? 

<!-- Solutions: --> 

#### Solutions

```{r ex3_2}
# Copy data: Make sure that cases are arranged in the same way:
t3 <- data_t3 %>% arrange(name, gender)
t4 <- data_t4 %>% arrange(initials, sex)

# Note 1:
# left_join(t3, t4)  # would yield an error:
# `by` required, because the data sources have no common variables

# Let's specify both primary and foreign key as:  
# by = c("name" = "initials")

# Note 2: Both of the following 
left_join(t3, t4, by = c("name" = "initials"))
full_join(t3, t4, by = c("name" = "initials"))
# yield 22 x 7 tables.

# Problem: The name/initials "A.V." appears TWICE data_t3 and data_t4:
length(unique(data_t3$name))            # => only 19 unique names
data_t3$name[duplicated(data_t3$name)]  # => "A.V." appears twice.
# ==> The combination lists 2x2 instances of "A.V.". 
```

3. Use a different command to join both tables into a 20 x 6 table that contains all data in 1 table.

<!-- Solutions: --> 

#### Solutions

The following solution first re-names 2 variables in one table (to have 2 matching key variables): 

```{r ex3_3a}
# Copy data: Make sure that cases are arranged in the same way:
t3 <- data_t3 %>% arrange(name, gender)
t4 <- data_t4 %>% arrange(initials, sex)

# Solution 1:
# (a) Rename both key variables in one table:
names(t4)[1:2] <- names(t3)[c(1, 2)] 

# (b) Join both tables using both key variables:
s1 <- left_join(t3,  t4, by = c("name", "gender"))  # => 20 x 6
s2 <- right_join(t3, t4, by = c("name", "gender"))  # => 20 x 6
s3 <- full_join(t3,  t4, by = c("name", "gender"))  # => 20 x 6
s4 <- inner_join(t3, t4, by = c("name", "gender"))  # => 20 x 6

# Show equality of solutions:
all.equal(s1, s2)
all.equal(s1, s3)
all.equal(s1, s4)

# Print solution:
s1
```

An alternative solution pre-supposes that both tables contain the same cases in the same order and introduces a temporary unique key variable (e.g., the row number) as key to link both tables:

```{r ex3_3b}
# Copy data: Make sure that cases are arranged in the same way:
t3 <- data_t3 %>% arrange(name, gender)
t4 <- data_t4 %>% arrange(initials, sex)

# Solution 2: When we know that 
# - both tables contain the same cases AND 
# - both tables have all cases arranged in the same way:
all.equal(t3$name, t4$initials)  # TRUE

# Add a new variable (with unique values) to both tables:
t3$nr <- 1:nrow(t3)  # add unique row number to each row
t4$nr <- 1:nrow(t4)  # add unique row number to each row

# Use this new and unambiguous variable as key:
s5 <- left_join(t3, t4, by = c("nr")) %>%  # use nr as key
  select(name:bnt_1, like_2, bnt_2)  # and drop some variables => 20 x 6 
s6 <- full_join(t3, t4, by = c("nr")) %>%  # use nr as key
  select(name:bnt_1, like_2, bnt_2)  # and drop some variables => 20 x 6 

# Show equality of solutions:
all.equal(s1, s5)
all.equal(s1, s6)
```


## Exercise 4

This exercise uses the datasets on web-based interventions in [positive psychology](http://rpository.com/ds4psy/essentials/datasets.html#positive-psychology). 

So far, we always distinguished between 3 main data files: 

- `posPsy_participants.csv`: Original participant data (295 x 6 variables):  
   <http://rpository.com/ds4psy/data/posPsy_participants.csv>.

- `posPsy_AHI_CESD_corrected.csv`: Corrected version of dependent measures in long format (990 x 50 variables):  
   <http://rpository.com/ds4psy/data/posPsy_AHI_CESD_corrected.csv>.

- `posPsy_data_wide.csv`: Corrected version of all data joined in wide format (295 x 294 variables):  
   <http://rpository.com/ds4psy/data/posPsy_data_wide.csv>.   
   Different measurement occasions are suffixed by .0, .1, ..., .5.

Given your knowledge of `dplyr` and `tidyr` you can now transform `posPsy_AHI_CESD_corrected.csv` and combine its parts with `posPsy_participants.csv` to obtain `posPsy_data_wide.csv`. Do this in the following steps:

1. **Preparation:** Import the data files `posPsy_participants.csv` as `p_info`, 
`posPsy_AHI_CESD_corrected.csv` as `AHI_CESD`, 
and `posPsy_data_wide.csv` as `data_wide`, and inspect the dimensions of these tables.

```{r ex4_1}
# Load data:
p_info    <- read_csv("http://rpository.com/ds4psy/data/posPsy_participants.csv")
AHI_CESD  <- read_csv("http://rpository.com/ds4psy/data/posPsy_AHI_CESD_corrected.csv") 
data_wide <- read_csv("http://rpository.com/ds4psy/data/posPsy_data_wide.csv") 

# Check: 
dim(p_info)     # 295 x   6 
dim(AHI_CESD)   # 990 x  50
dim(data_wide)  # 295 x 294
```

2. **Extracting occasions:** Create 6 individual tibbles that contains the data of each participant (1 row per `id`) seperately for each `occasion` (0 to 5).

<!-- Solutions: --> 

#### Solution

```{r ex4_2, echo = TRUE, eval = TRUE}
# Create 6 blocks 
# (for occasion 0 to 5):

occ_0 <- AHI_CESD %>%
  group_by(id, occasion) %>%
  filter(occasion == 0)
dim(occ_0)  # 295 x 50

occ_1 <- AHI_CESD %>%
  group_by(id, occasion) %>%
  filter(occasion == 1)
dim(occ_1)  # 148 x 50

occ_2 <- AHI_CESD %>%
  group_by(id, occasion) %>%
  filter(occasion == 2)
dim(occ_2)  # 156 x 50

occ_3 <- AHI_CESD %>%
  group_by(id, occasion) %>%
  filter(occasion == 3)
dim(occ_3)  # 138 x 50

occ_4 <- AHI_CESD %>%
  group_by(id, occasion) %>%
  filter(occasion == 4)
dim(occ_4)  # 133 x 50

occ_5 <- AHI_CESD %>%
  group_by(id, occasion) %>%
  filter(occasion == 5)
dim(occ_5)  # 120 x 50

# Do all blocks contain the same variable names? 
all.equal(names(occ_0), names(occ_5))  # TRUE
```

Note that only the first block (`occ_0`) contains the data of all 295 participants. 
The other 5 blocks of data (`occ_1` to `occ_5`) contain the same 50 variables, but were each reduced by drop-out cases. 

3. **Joining tables:** Combine the variables of the 6 tibbles into one wide block (in wide format) and compare your resulting table with 
[data_wide](http://rpository.com/ds4psy/data/posPsy_data_wide.csv).  

**Hint:** As you cannot combine all 6 blocks in one command, they have to be combined in a stepwise fashion. 

<!-- Solutions: --> 

#### Solution

```{r ex4_3}
# Join parts: 
occ_0_1 <- full_join(occ_0,   occ_1, by = "id", suffix = c(".0", ".1"))  # add occ_1 to occ_0
occ_0_2 <- full_join(occ_0_1, occ_2, by = "id", suffix = c(".1", ".2"))  # add occ_2 to this
occ_0_3 <- full_join(occ_0_2, occ_3, by = "id", suffix = c(".2", ".3"))  # add occ_3 to this
occ_0_4 <- full_join(occ_0_3, occ_4, by = "id", suffix = c(".3", ".4"))  # add occ_4 to this
occ_0_5 <- full_join(occ_0_4, occ_5, by = "id", suffix = c(".4", ".5"))  # add occ_5 to this

occ_all <- occ_0_5 # copy 

## Check: 
dim(occ_all)  # 295 x 295
# names(occ_all)
```

4. **Cleaning up:** As you might have noticed the number of columns of our newly created data set and the data in wide format (`data_wide`) are not the same. 
That is because:

  - information on each participants' intervention group is included 6 times in our created data; 

  - `data_wide` also includes the information on the participants (contained in `p_info`). 

Exclude any redundant variables on the `intervention` group (keeping this variable only once) and include the participant information from `p_info` to create a new table `complete_data`. Check if and ensure that `complete_data` is equal to `data_wide`. 

<!-- Solutions: --> 

#### Solution

```{r ex4_4}
# Delete redundant variables on intervention groups:
occ_all_clean <- occ_all %>%
  select(-intervention.1, 
         -intervention.2, 
         -intervention.3, 
         -intervention.4, 
         -intervention.5) %>%
  rename(intervention = intervention.0)

# Check: 
dim(occ_all_clean)  # 295 x 290

# Join with participant information:
dim(p_info)  # 295 x 6
complete_data <- full_join(p_info, occ_all_clean)  # same as: 
complete_data <- full_join(p_info, occ_all_clean,  by = c("id", "intervention"))

## Check:
# complete_data
dim(complete_data)  # 295 x 294  

## Compare with data_wide:
dim(data_wide) # 295 x 294

## In case of any differences:
## Which variables occur in complete_data but not in data_wide?
# names(complete_data)[!(names(complete_data) %in% names(data_wide))] # => intervention.x, intervention.y
#
## Are these variables all equal?
# all.equal(complete_data$intervention.x, complete_data$intervention.y)  # TRUE
#
## Delete intervention.y and rename intervention.x:
# my_data_wide <- complete_data %>%
#   select(-intervention.y) %>%
#   rename(intervention = intervention.x)

## Check:
all.equal(complete_data, data_wide)  # TRUE (qed).
```

5. **Alternative join:** How would you change the steps to join the 6 blocks (in 3.) if you only wanted to keep the participants who took part on all 6 possible occasions?  How many of them exist?

<!-- Solutions: --> 

#### Solution

```{r ex4_5}
# We would use multiple inner_join() commands instead of full_join():
# Join parts: 
in_occ_0_1 <- inner_join(occ_0,      occ_1, by = "id", suffix = c(".0", ".1"))  # add occ_1 to occ_0
in_occ_0_2 <- inner_join(in_occ_0_1, occ_2, by = "id", suffix = c(".1", ".2"))  # add occ_2 to this
in_occ_0_3 <- inner_join(in_occ_0_2, occ_3, by = "id", suffix = c(".2", ".3"))  # add occ_3 to this
in_occ_0_4 <- inner_join(in_occ_0_3, occ_4, by = "id", suffix = c(".3", ".4"))  # add occ_4 to this
in_occ_0_5 <- inner_join(in_occ_0_4, occ_5, by = "id", suffix = c(".4", ".5"))  # add occ_5 to this

dim(in_occ_0_5)         # 72 participants x 295 variables
sum(is.na(in_occ_0_5))  #  0 missing values
```

6. **Filter join:** Use a `dplyr` summary table on the data in `AHI_CESD` to determine the `id` of all participants that took part in all 6 occasions. 
Then use a filter join on `p_info` and on `AHI_CESD` to keep only the (rows of) data of these participants. 

<!-- Solutions: --> 

#### Solution

```{r ex5_6}
# Summary table of id values with 6 occasions:
id_6_occ <- AHI_CESD %>%
  group_by(id) %>%
  summarise(n = n()) %>%
  filter(n == 6)
id_6_occ

# Use id_6_occ$id to filter cases of p_info and AHI_CESD: 
semi_join(p_info,   id_6_occ, by = "id")  #  72 x  6
semi_join(AHI_CESD, id_6_occ, by = "id")  # 432 x 50
```

## Exercise 5: Bonus task

This exercise relies on the raw data for the [false positive psychology](http://rpository.com/ds4psy/essentials/datasets.html#false-positive-psychology) project, 
which can be obtained at <https://openpsychologydata.metajnl.com/articles/10.5334/jopd.aa/> or <https://zenodo.org/record/7664>. 

1. Download the 2 raw data files and load them into R as `study_1` and `study_2` (fixing any obvious errors).

<!-- Solutions: --> 

#### Solution

```{r ex6_1}
# Downloaded the archive `FalsePositive_Data_in_.txt_format.zip` and unzipped its contents  
# into a folder "/data/_falsePosPsy/raw_data/Study 1 .txt".

# Specify paths to 2 txt files:
wd <- "/Users/hneth/Desktop/stuff/Dropbox/_code/R/_teachR/ds4psy"
raw_1 <- paste0(wd, "/data/_falsePosPsy/raw_data/Study 1 .txt")  # Note weird spacing in file name!
raw_2 <- paste0(wd, "/data/_falsePosPsy/raw_data/Study 2.txt")

# Load data: 
study_1 <- read_tsv(raw_1)
study_2 <- read_tsv(raw_2)

# Inspect data:
dim(study_1)  # 44 x 17
dim(study_2)  # 34 x 17

## Are all variable names equal?
names(study_1) == names(study_2)  # => mostly TRUE, but 1 FALSE value

names(study_1)[names(study_1) != names(study_2)] # => "kalimba"
names(study_2)[names(study_1) != names(study_2)] # => "kaimba" !!!
# Correct name in study_2 to that of study_1:
names(study_2)[names(study_1) != names(study_2)] <- names(study_1)[names(study_1) != names(study_2)]

all.equal(names(study_1), names(study_2))  # TRUE
```

2. As both data files contain different participants, but the same variables about each participant, we want to save all data in one table. Combine the 2 datasets, but mark each dataset by a `study` variable (that has a value of either 1 or 2).

<!-- Solutions: --> 

#### Solution

```{r ex6_2, echo = TRUE, eval = TRUE}
# Mark each data set by a variable:
study_1$study <- 1
study_2$study <- 2

dim(study_1)  # 44 x 18
dim(study_2)  # 34 x 18

# (1) Use bind_rows(): 
fpositive_all <- bind_rows(study_1, study_2)
dim(fpositive_all)  # 78 x 18 variables
names(fpositive_all)

# (2) Use full_join() on all variables:
fpositive_all_2 <- full_join(study_1, study_2)
dim(fpositive_all_2)  # 78 x 18 variables
names(fpositive_all)

# Are both solutions equal? 
all.equal(fpositive_all, fpositive_all_2)  # TRUE
```

3. Identify individuals and arrange the dataset: Add a numeric `ID` variable identifying each individual participant and sort the dataset in an intuitive way.

<!-- Solutions: --> 

#### Solution

```{r Exercises 1c, echo = TRUE, eval = TRUE}
## Data: 
dim(fpositive_all)         # 78 x 18
sum(is.na(fpositive_all))  # No missing values.

# Add a factor variable ID to the dataset, 
# which runs from 1 to the total number of participants in the dataset: 
n_rows <- nrow(fpositive_all)

fpositive_all <- fpositive_all %>%
  mutate(ID = 1:n_rows) 

# Order columns for having ID and participant info first, followd by condition and the other items: 
fpositive_all <- fpositive_all %>%
  select(study, ID, aged, aged365, female, dad, mom, cond, potato, when64, kalimba, everything()) %>%
  arrange(study, ID)

# Check re-ordered tibble:
head(fpositive_all)
tail(fpositive_all)
```

4. Splitting and joining: 

The following code splits the data of `falsePosPsy` into 2 parts (`pt_1` and `pt_2`):

```{r ex6_4a}
# Import the Dataset
falsePosPsy <- read_csv(file = "http://rpository.com/ds4psy/data/falsePosPsy_all.csv")  # online

# Create 2 different datasets: 
pt_1 <- falsePosPsy %>%
  select(study, ID, aged, aged365, female, dad, mom)

pt_2 <- falsePosPsy %>%
  select(ID, potato, when64, kalimba, cond, root, bird, political, quarterback, olddays, feelold, computer, diner)
```

Re-create the full data set (from `pt_1` and `pt_2`) in at least 3 different ways (and verify that each of them yields the same data as `falsePosPsy`).

<!-- Solutions: --> 

#### Solution

```{r ex6_4b}
# Note that
all.equal(pt_1$ID, pt_2$ID)  # TRUE
# => pt_1 and pt_2 contain the same cases (observations).

# Thus, ALL 4 mutating joins yield the same result:
m_1 <-  left_join(pt_1, pt_2, by = "ID")
m_2 <- right_join(pt_1, pt_2, by = "ID")
m_3 <-  full_join(pt_1, pt_2, by = "ID")
m_4 <- inner_join(pt_1, pt_2, by = "ID")

# Also, different merges would yield the same result:
m_5 <- merge(pt_1, pt_2, by = "ID")  # as data.frame
m_5 <- as_tibble(m_5)                # convert to tibble
# m_5

# bind_cols(): 
m_6 <- bind_cols(pt_1, pt_2)
m_6 <- m_6 %>% select(-ID1)  # remove duplicate column ID1
# m_6

# Verify equality of all 6 solutions:
all.equal(m_1, falsePosPsy)
all.equal(m_2, falsePosPsy)
all.equal(m_3, falsePosPsy)
all.equal(m_4, falsePosPsy)
all.equal(m_5, falsePosPsy)
all.equal(m_6, falsePosPsy)
```


<!-- +++ here now +++ --> 


# More on joining data

- Study the vignette `vignette("two-table")` for 2-table verbs, and vignette("dplyr") for 1-table verbs of `dplyr`. 

- See the [RStudio cheatsheet](https://www.rstudio.com/resources/cheatsheets/) on _Data Transformation_ for essential `dplyr` commands. 

- Follow the links on <https://dplyr.tidyverse.org> and [Wikipedia:Join_SQL](https://en.wikipedia.org/wiki/Join_(SQL)) for additional information. 


# Conclusion

<!-- Table with links: -->

All [ds4psy](http://rpository.com/ds4psy/) essentials so far: 

Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | [Transforming data](http://rpository.com/ds4psy/essentials/transform.html) |
4.  | [Exploring data (EDA)](http://rpository.com/ds4psy/essentials/explore.html) | 
5.  | [Tibbles](http://rpository.com/ds4psy/essentials/tibbles.html) |
6.  | [Importing data](http://rpository.com/ds4psy/essentials/import.html) |
7.  | [Tidying data](http://rpository.com/ds4psy/essentials/tidy.html) |
8.  | **Joining data** [*](http://rpository.com/ds4psy/essentials/join.html) |
9.  | [Functions](http://rpository.com/ds4psy/essentials/function.html) |
10. | [Iteration](http://rpository.com/ds4psy/essentials/iteration.html) |
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 


<!--
Nr. | Topic       |
---:|:------------| 
0.  | [Syllabus](http://rpository.com/ds4psy/) | 
1.  | [Basic R concepts and commands](http://rpository.com/ds4psy/essentials/basics.html) | 
2.  | [Visualizing data](http://rpository.com/ds4psy/essentials/visualize.html) | 
3.  | [Transforming data](http://rpository.com/ds4psy/essentials/transform.html) |
4.  | [Exploring data (EDA)](http://rpository.com/ds4psy/essentials/explore.html) | 
5.  | [Tibbles](http://rpository.com/ds4psy/essentials/tibbles.html) |
6.  | [Importing data](http://rpository.com/ds4psy/essentials/import.html) |
7.  | [Tidying data](http://rpository.com/ds4psy/essentials/tidy.html) |
8.  | [Joining data](http://rpository.com/ds4psy/essentials/join.html) |
9.  | [Functions](http://rpository.com/ds4psy/essentials/function.html) |
10. | [Iteration](http://rpository.com/ds4psy/essentials/iteration.html) |
+.  | [Datasets](http://rpository.com/ds4psy/essentials/datasets.html) | 
-->

[Last update on `r Sys.time()` by [hn](http://neth.de/).]  

<!-- eof. --> 