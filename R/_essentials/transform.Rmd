---
title: "Essential data transformation (ds4psy)"
author: "Hansjörg Neth, SPDS, uni.kn"
date: "2018 07 05"
output:
   rmdformats::html_clean: # html_clean html_docco readthedown material #
     code_folding: show # hide
     toc_float: true
     toc_depth: 3
     highlight: kate # textmate default kate haddock monochrome #
     lightbox: true # true by default
     fig_width: 8 # in inches
editor_options: 
  chunk_output_type: console # inline
---

<!-- Example of essential commands | ds4psy: Summer 2018 -->

```{r preamble, echo = FALSE, eval = TRUE, cache = FALSE, message = FALSE, warning = FALSE}
## (a) Housekeeping: -----
rm(list=ls()) # clean all.

## (b) Current file name and path: ----- 
# cur.path <- dirname(rstudioapi::getActiveDocumentContext()$path)
# cur.path
# setwd(cur.path) # set to current directory
setwd("~/Desktop/stuff/Dropbox/_code/R/_teachR/ds4psy/R/_essentials") # set to current directory
# list.files() # all files + folders in current directory
fileName <- "transform.Rmd"

## (c) Packages: ----- 
library(knitr)
library(rmdformats)
library(tidyverse)

## (d) Global options: ----- 
options(max.print = "75")
opts_chunk$set(echo = TRUE,
	             cache = TRUE,
               prompt = FALSE,
               tidy = FALSE,
               collapse = TRUE, # set TRUE in answers 
               comment = "#>",
               message = FALSE,
               warning = FALSE,
               ## Default figure options:
               fig.width = 8, 
               fig.asp = .618, # golden ratio
               out.width = "75%",
               fig.align = "center"
               )
opts_knit$set(width = 75)

## (e) Graphics: ----- 

# Defining colors:
seeblau <- rgb(0, 169, 224, names = "seeblau", maxColorValue = 255) # seeblau.4 (non-transparent)

seeblau.colors <- c(rgb(204, 238, 249, maxColorValue = 255), # seeblau.1
                    rgb(166, 225, 244, maxColorValue = 255), # seeblau.2 
                    rgb(89, 199, 235, maxColorValue = 255),  # seeblau.3
                    rgb(0, 169, 224, maxColorValue = 255),   # seeblau.4 
                    rgb(0, 0, 0, maxColorValue = 255),       #  5. black
                    gray(level = 0, alpha = .6),             #  6. gray 60% transparent
                    gray(level = 0, alpha = .4),             #  7. gray 40% transparent
                    gray(level = 0, alpha = .2),             #  8. gray 20% transparent
                    gray(level = 0, alpha = .1),             #  9. gray 10% transparent
                    rgb(255, 255, 255, maxColorValue = 255)  # 10. white
                    )

unikn.pal = data.frame(                             ## in one df (for the yarrr package): 
  "seeblau1" = rgb(204, 238, 249, maxColorValue = 255), #  1. seeblau1 (non-transparent)
  "seeblau2" = rgb(166, 225, 244, maxColorValue = 255), #  2. seeblau2 (non-transparent)
  "seeblau3" = rgb( 89, 199, 235, maxColorValue = 255), #  3. seeblau3 (non-transparent)
  "seeblau4" = rgb(  0, 169, 224, maxColorValue = 255), #  4. seeblau4 (= seeblau base color)
  "black"    = rgb(  0,   0,   0, maxColorValue = 255), #  5. black
  "seegrau4" = rgb(102, 102, 102, maxColorValue = 255), #  6. grey40 (non-transparent)
  "seegrau3" = rgb(153, 153, 153, maxColorValue = 255), #  7. grey60 (non-transparent)
  "seegrau2" = rgb(204, 204, 204, maxColorValue = 255), #  8. grey80 (non-transparent)
  "seegrau1" = rgb(229, 229, 229, maxColorValue = 255), #  9. grey90 (non-transparent)
  "white"    = rgb(255, 255, 255, maxColorValue = 255), # 10. white
  stringsAsFactors = FALSE)

## (f) Counters: ----- 
nr <- 0  # task number
pt <- 0  # point total
```

```{r utility_add_random_NA_values, echo = FALSE, eval = TRUE}
# Adding a random amount (number or proportion) of NA or other values to a vector:

## Function to replace a random amount of vector elements by NA values:  
add_NAs <- function(vec, amount){
  
  stopifnot((is.vector(vec)) & (amount >= 0) & (amount <= length(vec)))

  out <- vec
  n <- length(vec)
  
  amount2 <- ifelse(amount < 1, round(n * amount, 0), amount) # turn amount prop into n
  
  out[sample(x = 1:n, size = amount2, replace = FALSE)] <- NA
  
  return(out)

}

## Check:
# add_NAs(1:10, 0)
# add_NAs(1:10, 3)
# add_NAs(1:10, .5)
# add_NAs(letters[1:10], 3)

## Generalization: Replace a random amount of vector elements by what: 
add_whats <- function(vec, amount, what = NA){
  
  stopifnot((is.vector(vec)) & (amount >= 0) & (amount <= length(vec)))

  out <- vec
  n <- length(vec)
  
  amount2 <- ifelse(amount < 1, round(n * amount, 0), amount) # turn amount prop into n
  
  out[sample(x = 1:n, size = amount2, replace = FALSE)] <- what
  
  return(out)

}

## Check:
# add_whats(1:10, 3) # default: what = NA
# add_whats(1:10, 3, what = 99)
# add_whats(1:10, .5, what = "ABC")
```

# Introduction

This file contains **essential commands** from the chapters of [r4ds](http://r4ds.had.co.nz) and corresponding examples. A command is considered "essential" when you really need to _know_ it and need to know _how to use_ it to succeed in this course. 

<!-- Table with links: -->

All [ds4psy](http://rpository.com/ds4psy/) essentials: 

Nr. | Topic       |
---:|:------------| 
1.  | [Creating and using tibbles](http://rpository.com/ds4psy/R/_essentials/tibble.html) |
2.  | [Data transformation](http://rpository.com/ds4psy/R/_essentials/transform.html) |
3.  | [Visualizing data](http://rpository.com/ds4psy/R/_essentials/visualize.html) |


## Course coordinates

<!-- uni.kn logo and link to SPDS: -->  
<!-- ![](./inst/pix/uniKn_logo.png) --> 
<a href="https://www.spds.uni-konstanz.de/">
<img src = "../../inst/pix/uniKn_logo.png" alt = "spds.uni.kn" align = "right" width = "300" style = "width: 300px; float: right; border:20;"/>
<!-- <img src = "./inst/pix/uniKn_logo_s.png" alt = "spds.uni.kn" style = "float: right; border:20;"/> --> 
</a>

* Course [Data Science for Psychologists](http://rpository.com/ds4psy/) (ds4psy). 
* Taught at the [University of Konstanz](https://www.uni-konstanz.de/) by [Hansjörg Neth](http://neth.de/) (<h.neth@uni.kn>,  [SPDS](https://www.spds.uni-konstanz.de/), office D507).
* Spring/summer 2018: Mondays, 13:30--15:00, C511.  
* Links to [ZeUS](https://zeus.uni-konstanz.de:443/hioserver/pages/startFlow.xhtml?_flowId=showEvent-flow&unitId=5101&termYear=2018&termTypeValueId=1&navigationPosition=hisinoneLehrorganisation,examEventOverviewOwn) and [Ilias](https://ilias.uni-konstanz.de/ilias/goto_ilias_uni_crs_758039.html)

## Preparations

Create an R script (`.R`) or an R-Markdown file (`.Rmd`) and load the R packages of the `tidyverse`. (Hint: Structure your script by inserting spaces, meaningful comments, and sections.) 
 
```{r layout_template, echo = TRUE, eval = FALSE}
## Essential commmands | Data science for psychologists
## 2018 06 25
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##

## Preparations: ----- 

library(tidyverse)

## Data transformation (dplyr): ----- 

# ...

## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
## End of file. ----- 
```

# Data transformation

## Overview

When we have data in the form of a tibble or data frame, `dplyr` provides a range of simple tools to transform this data. Six essential `dplyr` commands are: 

1. `arrange` sorts cases (rows); 
2. `filter` selects cases (rows) by logical conditions; 
3. `select` selects and reorders variables (columns); 
4. `mutate` computes new variables (columns) and adds them to existing ones; 
5. `summarise` collapses multiple values of a variable (rows of a column) to a single one;  
6. `group_by` changes the unit of aggregation (in combination with `mutate` and `summarise`).  

Not quite as essential but still useful `dplyr` commands include:

- `slice` selects (ranges of) cases (rows) by number; 
- `rename` renames variables (columns) and keeps others; 
- `transmute` computes new variables (columns) and drops existing ones;
- `sample_n` and `sample_frac` draw random samples of cases (rows).

## Commands and examples

We save the `dplyr::starwars` data as a tibble `sw` and use it to illustrate the essential `dplyr` commands.

```{r starwars_data}
library(tidyverse)
sw <- dplyr::starwars

sw  # => A tibble: 87 rows (individuals) x 13 columns (variables)
```

**Practice:** How many `sw` variables (columns) are there and of which _type_ are they? How many _missing_ (`NA`) values are there? 


### 1. `arrange` to sort rows

Using `arrange` sorts cases (rows) by putting specific variables (columns) in specific orders (e.g., ascending or descending):

```{r dplyr_arrange}
# Sort rows alphabetically (by name):
arrange(sw, name)

# The same command using the pipe:
sw %>%           # Note: %>% is NOT + (used in ggplot) 
  arrange(name) 

# Sort rows in descending order:
sw %>% 
  arrange(desc(name)) 

# Sort by multiple variables:
sw %>% 
  arrange(eye_color, gender, desc(height))

## Note: See 
# ?dplyr::arrange  # for more help and examples.
```

Note some details: 

- All basic `dplyr` commands can be called as `verb(data, ...)` or -- using the pipe from `magrittr` -- as `data %>% verb(...)` (see `vignette("magrittr")` for details).

- Variable names are unquoted. 

- The order of variable names (`x, y, ...`) specifies the _order_ or _priority_ of operations (first by `x`, then by `y`, etc.). 

**Practice:** Arrange the `sw` data in different ways, combining multiple variables and (ascending and descending) orders. Where are cases containing `NA` values in sorted variables placed?


### 2. `filter` to select rows

Using `filter` selects cases (rows) by logical conditions. It keeps all rows for which the conditions are `TRUE` and drops all rows for which the conditions are `FALSE` or `NA`.

```{r dplyr_filter}
# Filter to keep all humans:
filter(sw, species == "Human")

# The same command using the pipe:
sw %>%           # Note: %>% is NOT + (used in ggplot) 
  filter(species == "Human")

# Filter by multiple (additive) conditions: 
sw %>%
  filter(height > 180, mass <= 75)  # tall and light individuals

# The same command using the logical operator (&): 
sw %>%
  filter(height > 180 & mass <= 75)  # tall and light individuals

# Filter for a range of a specific variable:
sw %>%
  filter(height >= 150, height <= 165)  # (a) using height twice

sw %>%
  filter(between(height, 150, 165))     # (b) using between(...)

# Filter by multiple (alternative) conditions: 
sw %>%
  filter(homeworld == "Kashyyyk" | skin_color == "green")

# Filter cases with missing (NA) values on specific variables:
sw %>%
  filter(is.na(gender))

# Filter cases with existing (non-NA) values on specific variables:
sw %>%
  filter(!is.na(mass), !is.na(birth_year))

## Note: See 
# ?dplyr::filter  # for more help and examples.
```

Note some details:

- Separating multiple conditions by commas is the same as the logical AND (`&`). 

- Variable names are unquoted.

- The comma between conditions or tests (`x, y, ...`) means the same as `&` (logical AND), as each test results in a vector of Boolean values. 

- Unlike in base R, rows for which the condition evaluates to `NA` are dropped. 

- Additional filter functions include `near()` for testing numerical (near-)identity. 


**Practice:** Use `filter` on `sw` to select very diverse or narrow subsets of individuals. 
For instance, 

- which individual with blond hair and blue eyes has an unknown mass? 
- of which species are individuals that are over 2m tall and have brown hair?
- which individuals from Tatooine are not male (but may be `NA`)? 
- which individuals are neither male nor female OR heavier than 130kg? 

```{r dplyr_filter_ex, echo = FALSE, eval = FALSE}
sw %>%
  filter(hair_color == "blond", eye_color == "blue")

sw %>%
  filter(height > 200, hair_color == "brown")

sw %>%
  filter(homeworld == "Tatooine", (gender != "male" | is.na(gender)))

sw %>%
  filter((gender != "male" & gender != "female") | mass > 130)
```


### 3. `select` to select columns 

Using `select` selects variables (columns) by their names or numbers: 

```{r dplyr_select}
# Select 4 specific variables (columns) of sw:
select(sw, name, species, birth_year, gender)

# The same when using the pipe:
sw %>%           # Note: %>% is NOT + (used in ggplot) 
  select(name, species, birth_year, gender)

# The same when providing a vector of variable names: 
sw %>%
  select(c(name, species, birth_year, gender)) 

# The same when providing column numbers:
sw %>%
  select(1, 10, 7, 8) 

# The same when providing a vector of column numbers: 
sw %>%
  select(c(1, 10, 7, 8)) 

# Select ranges of variables with ":":
sw %>%
  select(name:mass, films:starships)

# Select to re-order variables (columns) with everything():
sw %>%
  select(species, name, gender, everything())

# Select variables with helper functions:
sw %>%
  select(starts_with("s"))

sw %>%
  select(ends_with("s"))

sw %>%
  select(contains("_"))

sw %>%
  select(matches("or"))

# Renaming variables:
sw %>%
  rename(creature = name, from_planet = homeworld)

## Note: See 
# ?dplyr::select  # for more help and examples. 
?dplyr::select_if  # for more help and examples. 
```

Note some details:

- `select` works both by specifying variable (column) _names_ and by specifying column _numbers_.

- Variable names are unquoted. 

- The sequence of variable names (separated by commas) specifies the _order_ of columns in the resulting tibble.

- Selecting and adding `everything()` allows re-ordering. 

- Various helper functions (e.g., `starts_with`, `ends_with`, `contains`, `matches`, `num_range`) refer to (parts of) variable names. 

- `rename` renames specified variables (without quotes) and keeps all other variables.

**Practice:** Use `select` on `sw` to select and re-order specific subsets of variables (e.g., all variables starting with "h", all even columns, all character variables, etc.).


### 4. `mutate` to compute new variables

Using `mutate` computes new variables (columns) from scratch or existing ones: 

```{r dplyr_mutate}
# Preparation: Save only a subset variables of sw as sws:   
sws <- select(sw, name:mass, birth_year:species) 
sws    # => 87 cases (rows), but only 7 variables (columns)

# Compute 2 new variables and add them to existing ones:
mutate(sws, id = 1:nrow(sw), height_feet = .032808399 * height)

# The same using the pipe:
sws %>%
  mutate(id = 1:nrow(sw), height_feet = .032808399 * height)

# Transmute commputes and only keeps new variables:
sws %>%
  transmute(id = 1:nrow(sw), height_feet = .032808399 * height)

# Compute variables based on multiple others (including computed ones):
sws %>%
  mutate(BMI = mass / ((height / 100)  ^ 2),  # compute body mass index (kg/m^2)
         BMI_low  = BMI < 18.5,               # classify low BMI values
         BMI_high = BMI > 30,                 # classify high BMI values
         BMI_norm = !BMI_low & !BMI_high      # classify normal BMI values 
         )

## Note: See 
# ?dplyr::mutate  # for more help and examples. 
```

Note some details:

- `mutate` computes new variables (columns) and adds them to existing ones, while `transmute` drops existing ones.

- Each `mutate` command specifies a new variable name (without quotes), followed by `=` and a _rule_ for computing the new variable from existing ones. 

- Variable names are unquoted. 

- Multiple `mutate` steps are separated by commas, each of which creates a new variable.

- See <http://r4ds.had.co.nz/transform.html#mutate-funs> for useful functions for creating new variables. 

**Practice:** Compute a new variable `mass_pound` from `mass` (in kg) and the age of each individual in `sw` relative to Yoda's age. (Note that the variable `birth_year` is provided in years BBY, i.e., Before Battle of Yavin.) 

```{r mutate_ex, echo = FALSE, eval = FALSE}
# sws

age_yoda <- sws %>%
  filter(name == "Yoda") %>%
  .$birth_year
age_yoda

sws %>% 
  mutate(mass_pound = mass/.45,
         age_since_yoda = age_yoda - birth_year) %>%
  select(name, mass, mass_pound, birth_year, age_since_yoda)
```

### 5. `summarise` to compute summaries

`summarise` computes a function for a specified variable and collapses the values of the specified variable (i.e., the rows of a specified columns) to a single value. It provides many different summary statistics by itself, but is even more useful in combination with `group_by` (discussed next). 

```{r dplyr_summarise}
# Summarise allows computing a function for a variable (column): 
summarise(sw, mn_mass = mean(mass, na.rm = TRUE))  # => 97.31 kg 

# The same using the pipe: 
sw %>%
  summarise(mn_mass = mean(mass, na.rm = TRUE))  # => 97.31 kg 

# Multiple summarise steps allow applying 
# different functions for 1 dependent variable: 
sw %>%
  summarise(n_mass = sum(!is.na(mass)), 
            mn_mass = mean(mass, na.rm = TRUE),
            md_mass = median(mass, na.rm = TRUE),
            sd_mass = sd(mass, na.rm = TRUE),
            max_mass = max(mass, na.rm = TRUE),
            big_mass = any(mass > 1000)
            )
            
# Multiple summarise steps also allow applying 
# different functions to different dependent variables: 
sw %>%
  summarise(# Descriptives of height:  
            n_height = sum(!is.na(height)), 
            mn_height = mean(height, na.rm = TRUE),
            sd_height = sd(height, na.rm = TRUE), 
            # Descriptives of mass:
            n_mass = sum(!is.na(mass)), 
            mn_mass = mean(mass, na.rm = TRUE),
            sd_mass = sd(mass, na.rm = TRUE),
            # Counts of character variables:
            n_names = n(), 
            n_species = n_distinct(species),
            n_worlds = n_distinct(homeworld)
            )

## Note: See 
# ?dplyr::summarise  # for more help and examples. 
```

Note some details:

- `summarise` collapses multiple values into one value and returns a new tibble with as many rows as values computed.

- Each `summarise` step specifies a new variable name (without quotes), followed by `=`, and a _function_ for computing the new variable from existing ones. 

- Multiple `summarise` steps are separated by commas. 

- Variable names are unquoted. 

- See <https://dplyr.tidyverse.org/reference/summarise.html> for examples and useful functions in combination with `summarise`. 


**Practice:** Apply _all_ summary functions mentioned in `?dplyr::summarise` to the `sw` dataset. 


### 6. `group_by` to aggregate variables

Using `group_by` does not change the data, but the _unit of aggregation_ for other commands, which is very useful in combination with `mutate` and `summarise`. 

```{r dplyr_group_by}
# Grouping does not change the data, but lists its groups: 
group_by(sws, species)  # => 38 groups of species

# The same using the pipe: 
sws %>%
  group_by(species)  # => 38 groups of species

# group_by is ineffective by itself, but very powerful 
# (a) in combination with `mutate` and 
# (b) in combination with `summarise`. 

# ad (a):
# In combination with mutate and an aggregation function, 
# group_by changes the unit of aggregation:

sws %>%
  mutate(mn_height_1 = mean(height, na.rm = TRUE)) %>%  # aggregates over ALL cases
  group_by(species) %>%
  mutate(mn_height_2 = mean(height, na.rm = TRUE)) %>%  # aggregates over current group (species)
  group_by(gender) %>%
  mutate(mn_height_3 = mean(height, na.rm = TRUE)) %>%  # aggregates over current group (gender)
  group_by(name) %>%
  mutate(mn_height_4 = mean(height, na.rm = TRUE))      # aggregates over current group (name)

# ad (b):
# group_by is particularly useful in combination 
# with summarise:

sws %>%
  group_by(homeworld) %>%
  summarise(count = n(),
            mn_height = mean(height, na.rm = TRUE),
            mn_mass = mean(mass, na.rm = TRUE)
            )

# Note that this pipe returns a new tibble, 
# with 49 rows (= different levels of homeworld) and 
# - 1 column of the group variable (homeworld) and 
# - 3 columns of the 3 newly summarised variables.


# group_by used with multiple variables yields a tibble 
# containing the combination of all variable levels: 
sw %>%
  group_by(hair_color, eye_color)  # => 35 groups (combinations)

# Counting the frequency of cases in groups:
sw %>%
  group_by(hair_color, eye_color) %>%
  count() %>%
  arrange(desc(n))  

# The same using summarise:
sw %>%
  group_by(hair_color, eye_color) %>%
  summarise(n = n()) %>%
  arrange(desc(n))  

## Note: See 
# ?dplyr::group_by  # for more help and examples. 
```

Note some details:

- `group_by` changes the unit of aggregation for other commands (`mutate` and `summarise`). 

- Variable names are unquoted.

- When using `group_by` with multiple variables, they are separated by commas. 

- Using `group_by` with `mutate` results in a tibble that has the same number of cases (rows) as the original tibble.  By contrast, using `group_by` with `summarise` results in a new tibble with all combinations of variable levels as its cases (rows). 


**Practice:** Create some groups and compute descriptive statistics (n, mean, median, standard deviation, ...) for some variables. For instance, 

- What is the number and mean height and mass of individuals from Tatooine by species and gender? 

- Which humans are more than 5cm taller then the average human overall?

- Which humans are more than 5cm taller than the average human of their own gender?

```{r group_by_ex, echo = FALSE, eval = FALSE}
sws %>%
  filter(homeworld == "Tatooine") %>%
  group_by(species, gender) %>%
  summarise(count = n(),
            mn_height = mean(height),
            mn_mass = mean(mass, na.rm = TRUE)
            )

sws %>% 
  filter(species == "Human") %>%
  mutate(mn_height = mean(height, na.rm = TRUE),
         taller = height > mn_height + 5) %>%
  filter(taller == TRUE)

sws %>% 
  filter(species == "Human") %>%
  group_by(gender) %>% 
  mutate(mn_height_2 = mean(height, na.rm = TRUE),
         taller_2 = height > mn_height_2 + 5) %>%
  filter(taller_2 == TRUE)
```


## Combining commands

The essential `dplyr` commands are quite simple by themselves, but form the basic verbs of a language for data manipulation. The commands become particularly powerful when they are combined into pipes (by using `%>%`). Stringing together several `dplyr` commands allows slicing and dicing data (tibbles or data frames) in a step-wise fashion to run non-trivial data analyses on the fly. 

**Practice: Tidyverse meets universe**

Answer the following questions about the `dplyr::starwars` dataset by using pipes of essential `dplyr` commands:  

**a.** Basics: 

- Save the tibble `dplyr::starwars` as `sw` and report its dimensions. 

**b.** Missing values and known unknowns:

- How many missing (`NA`) values does `sw` contain?

- Which individuals come from an unknown (missing) `homeworld` but have a known `birth_year` or known `mass`?

<!-- Which variable (column) has the most missing values? --> 

<!-- Replace all missing values of `hair_color` (in the variable `sw$hair_color`) by "bald" (2). -->


**c.** Gender issues:

- How many humans are contained in `sw` overall and by gender?

- How many and which individuals in `sw` are neither male nor female?

- Of which species in `sw` exist at least 2 different gender values?


**d.** Popular homes and heights:

- From which `homeworld` do the most indidividuals (rows) come from?

- What is the mean `height` of all individuals with orange eyes from the most popular homeworld?


**e.** Size and mass issues: 

- Compute the median, mean, and standard deviation of `height` for all droids.

- Compute the average height and mass by species and save the result as `h_m`.

- Sort `h_m` to list the 3 species with the smallest individuals (in terms of mean height).

- Sort `h_m` to list the 3 species with the heaviest individuals (in terms of median mass).


**f.** Counting and arranging: 

How many individuals exist of the three most frequent (known) species?


**g.** Grouped mutates: 

- Which individuals are more than 20% lighter than the average mass of individuals of their own homeworld? 


```{r starwars_practice}
# library(tidyverse)
# ?dplyr::starwars

## (a) Basic data properties: ---- 
sw <- dplyr::starwars
dim(sw)  # => 87 rows (denoting individuals) x 13 columns (variables) 

## (b) Missing data: ----- 

## (+) How many missing data points?
sum(is.na(sw))  # => 101 missing values.

# (+) Which individuals come from an unknown (missing) homeworld 
#     but have a known birth_year or mass? 
sw %>% 
  filter(is.na(homeworld), !is.na(mass) | !is.na(birth_year))


## (x) Which variable (column) has the most missing values?
colSums(is.na(sw))  # => birth_year has 44 missing values
colMeans(is.na(sw)) #    (amounting to 50.1% of all cases). 

## (x) Replace all missing values of `hair_color` (in the variable `sw$hair_color`) by "bald": 
# sw$hair_color[is.na(sw$hair_color)] <- "bald"


## (c) Gender issues: ----- 

# (+) How many humans are there of each gender?
sw %>% 
  filter(species == "Human") %>%
  group_by(gender) %>%
  count()

## Answer: 35 Humans in total: 9 females, 26 male.

# (+) How many and which individuals are neither male nor female?
sw %>% 
  filter(gender != "male", gender != "female")

# (+) Of which species are there at least 2 different gender values?
sw %>%
  group_by(species, gender) %>%
  count() %>%  # table shows species by gender: 
  group_by(species) %>%  # Which species appear more than once in this table? 
  count() %>%
  filter(nn > 1)

## (d) Homeworld issues: ----- 

# (+) Popular homes: From which homeworld do the most indidividuals (rows) come from? 
sw %>%
  group_by(homeworld) %>%
  count() %>%
  arrange(desc(n))
# => Naboo (with 11 individuals)

# (+) What is the mean height of all individuals with orange eyes from the most popular homeworld? 
sw %>% 
  filter(homeworld == "Naboo", eye_color == "orange") %>%
  summarise(n = n(),
            mn_height = mean(height))

## Note: 
sw %>% filter(eye_color == "orange") # => 8 individuals


# (+) What is the mass and homeworld of the smallest droid?
sw %>% 
  filter(species == "Droid") %>%
  arrange(height)

## (e) Size and mass: Group summaries: ----- 

# (+) Compute the median, mean, and standard deviation of `height` for all droids.
sw %>%
  filter(species == "Droid") %>%
  summarise(n = n(),
            not_NA_h = sum(!is.na(height)),
            md_height = median(height, na.rm = TRUE),
            mn_height = mean(height, na.rm = TRUE),
            sd_height = sd(height, na.rm = TRUE))

# (+) Compute the average height and mass by species and save the result as `h_m`:
h_m <- sw %>%
  group_by(species) %>%
  summarise(n = n(),
            not_NA_h = sum(!is.na(height)),
            mn_height = mean(height, na.rm = TRUE),
            not_NA_m = sum(!is.na(mass)),
            md_mass = median(mass, na.rm = TRUE)
            )
h_m

# (+) Use `h_m` to list the 3 species with the smallest individuals (in terms of mean height)?
h_m %>% arrange(mn_height) %>% slice(1:3)

# (+) Use `h_m` to list the 3 species with the heaviest individuals (in terms of median mass)?
h_m %>% arrange(desc(md_mass)) %>%  slice(1:3)


## (+) Other questions: ----- 

# (f) How many individuals come from the 3 most frequent (known) species?
sw %>%
  group_by(species) %>%
  count %>%
  arrange(desc(n)) %>%
  filter(n > 1)

# (g) Which individuals are more than 20% lighter (in terms of mass) 
#     than the average mass of individuals of their own homeworld?
sw %>%
  select(name, homeworld, mass) %>%
  group_by(homeworld) %>%
  mutate(n_notNA_mass = sum(!is.na(mass)),  
         mn_mass = mean(mass, na.rm = TRUE),
         lighter = mass < (mn_mass - (.20 * mn_mass))
         ) %>%
  filter(lighter == TRUE)
```


## More on data transformation 

For more details on `dplyr`, 

- study `vignette("dplyr")` and the documentation for `?arrange`, `?filter`, `?select`, etc. 
- study <https://dplyr.tidyverse.org/> and its examples; 
- see the [cheat sheet on data transformation](https://www.rstudio.com/resources/cheatsheets/); 
- read [Chapter 5: Data transformation](http://r4ds.had.co.nz/transform.html) and complete its exercises. 


# Conclusion

<!-- Table with links: -->

All [ds4psy](http://rpository.com/ds4psy/) essentials: 

Nr. | Topic       |
---:|:------------| 
1.  | [Creating and using tibbles](http://rpository.com/ds4psy/R/_essentials/tibble.html) |
2.  | [Data transformation](http://rpository.com/ds4psy/R/_essentials/transform.html) |
3.  | [Visualizing data](http://rpository.com/ds4psy/R/_essentials/visualize.html) |


[Last update on `r Sys.time()` by [hn](http://neth.de/).]  

<!-- eof. --> 