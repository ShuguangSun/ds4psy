---
title: "Essential commands (ds4psy)"
author: "Hansjörg Neth, SPDS, uni.kn"
date: "2018 06 30"
output:
   rmdformats::html_clean: # html_clean html_docco readthedown material #
     code_folding: show # hide
     toc_float: true
     toc_depth: 3
     highlight: default # textmate default kate haddock monochrome #
     lightbox: true # true by default
     fig_width: 8 # in inches
editor_options: 
  chunk_output_type: console # inline
---

<!-- Example of essential commands | ds4psy: Summer 2018 -->

```{r preamble, echo = FALSE, eval = TRUE, cache = FALSE, message = FALSE, warning = FALSE}
## (a) Housekeeping: -----
rm(list=ls()) # clean all.

## (b) Current file name and path: ----- 
# cur.path <- dirname(rstudioapi::getActiveDocumentContext()$path)
# cur.path
# setwd(cur.path) # set to current directory
setwd("~/Desktop/stuff/Dropbox/_code/R/_teachR/ds4psy/R/_essentials") # set to current directory
# list.files() # all files + folders in current directory
fileName <- "essentials.Rmd"

## (c) Packages: ----- 
library(knitr)
library(rmdformats)
library(tidyverse)

## (d) Global options: ----- 
options(max.print = "75")
opts_chunk$set(echo = TRUE,
	             cache = TRUE,
               prompt = FALSE,
               tidy = FALSE,
               collapse = TRUE, # set TRUE in answers 
               comment = "#>",
               message = FALSE,
               warning = FALSE,
               ## Default figure options:
               fig.width = 8, 
               fig.asp = .618, # golden ratio
               out.width = "75%",
               fig.align = "center"
               )
opts_knit$set(width = 75)

## (e) Graphics: ----- 

# Defining colors:
seeblau <- rgb(0, 169, 224, names = "seeblau", maxColorValue = 255) # seeblau.4 (non-transparent)

seeblau.colors <- c(rgb(204, 238, 249, maxColorValue = 255), # seeblau.1
                    rgb(166, 225, 244, maxColorValue = 255), # seeblau.2 
                    rgb(89, 199, 235, maxColorValue = 255),  # seeblau.3
                    rgb(0, 169, 224, maxColorValue = 255),   # seeblau.4 
                    rgb(0, 0, 0, maxColorValue = 255),       #  5. black
                    gray(level = 0, alpha = .6),             #  6. gray 60% transparent
                    gray(level = 0, alpha = .4),             #  7. gray 40% transparent
                    gray(level = 0, alpha = .2),             #  8. gray 20% transparent
                    gray(level = 0, alpha = .1),             #  9. gray 10% transparent
                    rgb(255, 255, 255, maxColorValue = 255)  # 10. white
                    )

unikn.pal = data.frame(                             ## in one df (for the yarrr package): 
  "seeblau1" = rgb(204, 238, 249, maxColorValue = 255), #  1. seeblau1 (non-transparent)
  "seeblau2" = rgb(166, 225, 244, maxColorValue = 255), #  2. seeblau2 (non-transparent)
  "seeblau3" = rgb( 89, 199, 235, maxColorValue = 255), #  3. seeblau3 (non-transparent)
  "seeblau4" = rgb(  0, 169, 224, maxColorValue = 255), #  4. seeblau4 (= seeblau base color)
  "black"    = rgb(  0,   0,   0, maxColorValue = 255), #  5. black
  "seegrau4" = rgb(102, 102, 102, maxColorValue = 255), #  6. grey40 (non-transparent)
  "seegrau3" = rgb(153, 153, 153, maxColorValue = 255), #  7. grey60 (non-transparent)
  "seegrau2" = rgb(204, 204, 204, maxColorValue = 255), #  8. grey80 (non-transparent)
  "seegrau1" = rgb(229, 229, 229, maxColorValue = 255), #  9. grey90 (non-transparent)
  "white"    = rgb(255, 255, 255, maxColorValue = 255), # 10. white
  stringsAsFactors = FALSE)

## (f) Counters: ----- 
nr <- 0  # task number
pt <- 0  # point total
```

```{r utility_add_random_NA_values, echo = FALSE, eval = TRUE}
# Adding a random amount (number or proportion) of NA or other values to a vector:

## Function to replace a random amount of vector elements by NA values:  
add_NAs <- function(vec, amount){
  
  stopifnot((is.vector(vec)) & (amount >= 0) & (amount <= length(vec)))

  out <- vec
  n <- length(vec)
  
  amount2 <- ifelse(amount < 1, round(n * amount, 0), amount) # turn amount prop into n
  
  out[sample(x = 1:n, size = amount2, replace = FALSE)] <- NA
  
  return(out)

}

## Check:
# add_NAs(1:10, 0)
# add_NAs(1:10, 3)
# add_NAs(1:10, .5)
# add_NAs(letters[1:10], 3)

## Generalization: Replace a random amount of vector elements by what: 
add_whats <- function(vec, amount, what = NA){
  
  stopifnot((is.vector(vec)) & (amount >= 0) & (amount <= length(vec)))

  out <- vec
  n <- length(vec)
  
  amount2 <- ifelse(amount < 1, round(n * amount, 0), amount) # turn amount prop into n
  
  out[sample(x = 1:n, size = amount2, replace = FALSE)] <- what
  
  return(out)

}

## Check:
# add_whats(1:10, 3) # default: what = NA
# add_whats(1:10, 3, what = 99)
# add_whats(1:10, .5, what = "ABC")
```

# Introduction

This file contains **essential commands** from the chapters of [r4ds](http://r4ds.had.co.nz) and corresponding examples. A command is considered "essential" when you really need to _know_ it and need to know _how to use_ it to succeed in this course. 

<!-- Table with links: -->

All [ds4psy](http://rpository.com/ds4psy/) essentials: 

Nr. | Topic       |
---:|:------------| 
1.  | [Creating and using tibbles](http://rpository.com/ds4psy/R/_essentials/tibble.html) |
2.  | [Data transformation](http://rpository.com/ds4psy/R/_essentials/transform.html) |
3.  | [Visualizing data](http://rpository.com/ds4psy/R/_essentials/visualize.html) |

## Course coordinates

<!-- uni.kn logo and link to SPDS: -->  
<!-- ![](./inst/pix/uniKn_logo.png) --> 
<a href="https://www.spds.uni-konstanz.de/">
<img src = "../../inst/pix/uniKn_logo.png" alt = "spds.uni.kn" align = "right" width = "300" style = "width: 300px; float: right; border:20;"/>
<!-- <img src = "./inst/pix/uniKn_logo_s.png" alt = "spds.uni.kn" style = "float: right; border:20;"/> --> 
</a>

* Course [Data Science for Psychologists](http://rpository.com/ds4psy/) (ds4psy). 
* Taught at the [University of Konstanz](https://www.uni-konstanz.de/) by [Hansjörg Neth](http://neth.de/) (<h.neth@uni.kn>,  [SPDS](https://www.spds.uni-konstanz.de/), office D507).
* Spring/summer 2018: Mondays, 13:30--15:00, C511.  
* Links to [ZeUS](https://zeus.uni-konstanz.de:443/hioserver/pages/startFlow.xhtml?_flowId=showEvent-flow&unitId=5101&termYear=2018&termTypeValueId=1&navigationPosition=hisinoneLehrorganisation,examEventOverviewOwn) and [Ilias](https://ilias.uni-konstanz.de/ilias/goto_ilias_uni_crs_758039.html)

## Preparations

Create an R script (`.R`) or an R-Markdown file (`.Rmd`) and load the R packages of the `tidyverse`. (Hint: Structure your script by inserting spaces, meaningful comments, and sections.) 
 
```{r layout_template, echo = TRUE, eval = FALSE}
## Essential commmands | Data science for psychologists
## 2018 06 24
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##

## Preparations: ----- 

library(tidyverse)

## Topic: ----- 

# ...

## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
## End of file. ----- 
```

# Tibbles

Whenever working with rectangular data structures -- data consisting of multiple cases (rows) and variables (columns) -- our first step is to create or transform the data into a _tibble_ (i.e., a simple version of a _data frame_). 

## Creating tibbles

### Basic commands

There are 3 basic commands for creating tibbles:

1. `as_tibble` converts (or coerces) an existing data frame into a tibble.

2. `tibble` converts several vectors into (the columns of) a tibble.

3. `tribble` converts a table (entered row-by-row) into a tibble. 

**Check**: 
The 3 commands yield the same type of output (i.e., a tibble), but require different inputs. Ask yourself which kind of input each command takes and how this input needs to be structured and formatted (e.g., with commas).


### 1. `as_tibble`

Use `as_tibble` when the data to be used already is in a data frame (or matrix):

```{r as_tibble}
## Using the data frame `sleep`: ------ 

# ?datasets::sleep # provides background information on the data set.

# Save the sleep data frame as df: 
df <- datasets::sleep

# Convert df into a tibble tb: 
tb <- as_tibble(df)

# Inspect the data frame df: 
dim(df)
is.data.frame(df)
head(df)
str(df)

# Inspect the tibble tb:
dim(tb)
is.tibble(tb)
is.data.frame(tb) # => tibbles ARE data frames.
head(tb)
glimpse(tb)
```

**Practice:** 
Convert the data frames `datasets::attitude` and `datasets::iris` into tibbles and inspect their dimensions and contents. What types of variables do they contain? 

### 2. `tibble`

Use `tibble` when the data to be used appears as a collection of columns. 
For instance, imagine we have the following information about a family: 

```{r tibble_def, echo = FALSE, eval = TRUE}
# Define some data (to be shown below) as a tibble: 
tb <- tribble(
  ~id, ~name, ~age, ~gender, ~drives, ~married_2,   
  #--|------|-----|--------|----------|----------|
  1,  "Adam", 46,  "male",    TRUE,     "Eva",    
  2,  "Eva",  48,  "female",  TRUE,     "Adam",  
  3,  "Xaxi", 21,  "female",  FALSE,    "Zenon",    
  4,  "Yota", 19,  "female",  TRUE,      NA, 
  5,  "Zack", 17,  "male",    FALSE,     NA      )

knitr::kable(tb, caption = "Example data of some family.")
```

One way of viewing this table is as a series of columns. Each column consists of a variable name and the same number of (here: 5) values, which can be of different types (here: numbers, characters, or Boolean truth values).  Each column may or may not contain missing values (entered as `NA`). 

The `tibble` command expects that each column of the table is entered as a vector:

```{r tibble, echo = TRUE, eval = TRUE}
## Create a tibble from vectors (column-by-column): 
fm <- tibble(
  id       = c(1, 2, 3, 4, 5), # OR: id = 1:5, 
  name     = c("Adam", "Eva", "Xaxi", "Yota", "Zack"), 
  age      = c(46, 48, 21, 19, 17), 
  gender   = c("male", rep("female", 3), "male"), 
  drives   = c(TRUE, TRUE, FALSE, TRUE, FALSE), 
  married_2 = c("Eva", "Adam", "Zenon", NA, NA)
  )

fm  # prints the tibble: 
```

Note some details: 

- Each vector is labeled by the variable (column) name, which is _not_ put into quotes; 

- Avoid spaces within variable (column) names (or enclose names in single quotes if you really `must use spaces`); 

- All vectors need to have the same length; 

- Each vector is of a single type (numeric, character, or Boolean truth values); 

- Consecutive vectors are separated by commas (but there is no comma after the final vector).

When using `tibble`, later vectors may use the values of earlier vectors:

```{r tibble_use_early_v}
# Using earlier vectors when defining later ones:
abc <- tibble(
  ltr = LETTERS[1:5],
  num = 1:5,
  l_n = paste(ltr, num, sep = "_"),  # combining abc with num
  nsq = num^2                        # squaring num
  )

abc  # prints the tibble: 
```

**Practice:** 
Find some tabular data online (e.g., on [Wikipedia](https://en.wikipedia.org)) and enter it as a tibble.


### 3. `tribble`

Use `tribble` when the data to be used appears as a collection of rows (or already is in tabular form). 

For instance, when you copy and paste the above family data from an electronic document, it is easy to insert commas between consecutive cell values and use `tribble` to convert it into a tibble:

```{r tribble, echo = TRUE, eval = TRUE}
## Create a tibble from tabular data (row-by-row): 
fm2 <- tribble(
  ~id, ~name, ~age, ~gender, ~drives, ~married_2,   
  #--|------|-----|--------|----------|----------|
  1,  "Adam", 46,  "male",    TRUE,     "Eva",    
  2,  "Eva",  48,  "female",  TRUE,     "Adam",  
  3,  "Xaxi", 21,  "female",  FALSE,    "Zenon",    
  4,  "Yota", 19,  "female",  TRUE,      NA, 
  5,  "Zack", 17,  "male",    FALSE,     NA      )

fm2  # prints the tibble: 
```

Note some details: 

- The column names are preceded by `~`; 

- Consecutive entries are separated by a comma (but there is no comma after the final entry); 

- The line `#--|------|-----|--------|----------|----------|` is commented out and can be omitted; 

- The type of each column is determined by the type of the corresponding cell values. For instance, the NA values in `fm2` are missing character values because the entries above were characters (entered in quotes).


**Check**: If `tibble` and `tribble` really are alternative commands, then the contents of our objects `fm` and `fm2` should be identical: 

```{r check_equality, echo = TRUE, eval = TRUE}
# Are fm and fm2 equal?
all.equal(fm, fm2)
```

**Practice:** Enter the tibble `abc` by using `tribble`. 


## Accessing parts of a tibble 

Once we have an R object that is a tibble, we often want to access individual parts of it. We can distinguish between 3 simple cases: 

### 1. Variables (columns) 

As each column of a tibble is a vector, obtaining a column amounts to obtaining the corresponding vector. We can access this vector by its name (label) or by its number (column position):

```{r tibble_cols}
fm  # family tibble (defined above): 

# Get the name column of fm:
fm$name       # by label (with $)
fm[["name"]]  # by label (with [])
fm[[2]]       # by number (with [])

# Get the age column of fm: 
fm$age        # by name (with $)
fm[["age"]]   # by name (with [])
fm[[3]]       # by number (with [])

# Note: The following all yield the same vectors as a tibble:
fm[ , 2] # yields the name vector as a (5 x 1) tibble
select(fm, 2) 
select(fm, name)

fm[ , 3] # yields the age vector as a (5 x 1) tibble
select(fm, 3)
select(fm, age)
```

**Practice:** Extract the `price` column of `ggplot2::diamonds` in at least 3 different ways and verify that they all yield the same mean price. 

```{r tibble_col_ex, echo = FALSE, eval = FALSE}
# Save data ggplot2::diamonds as dm: 
dm <- ggplot2::diamonds
dm

# Compute the mean price of dm in 4 ways: 
mean(dm$price)
mean(dm[["price"]])
mean(dm[[7]])  # => US-$ 3932.80 
mean(as_vector(select(dm, price))) 
```

### 2. Cases (rows)

Extracting specific rows of a tibble amounts to filtering a tibble and typically yields smaller tibbles (as a row may contain entries of different types). The best way of filtering specific rows of a tibble is using `dplyr::filter`.  However, it's also possible to specify the desired rows by subsetting (i.e., specifying a condition that results in a Boolean value) and by row number:

```{r tibble_rows}
fm  # family tibble (defined above): 

# Filter specific rows (by condition):
filter(fm, id > 2)
filter(fm, age < 18)
fm %>% filter(drives == TRUE) 
  
# The same filters by using Boolean vectors (subsetting):
fm[fm$id > 2, ]
fm[fm$age < 18, ]
fm[fm$drives == TRUE, ]

# The same filters by providing specific row numbers:
fm[3:5, ]  # getting rows 3 to 5 of fm
fm[5, ]    # getting row 5 of fm
fm[c(1, 2, 4), ]  # getting rows 1, 2, and 4 of fm
```

**Practice:** Extract all diamonds from `ggplot2::diamonds` that have at least 2 carat. How many of them are there and what is their mean price? 

```{r tibble_row_ex, echo = FALSE, eval = FALSE}
# Save data ggplot2::diamonds as dm: 
dm <- ggplot2::diamonds
dm

# Filter dm by condition: 
dm_2 <- filter(dm, carat >= 2)
dm_2  # => 2154 rows (cases)

# Compute the mean price of dm_2 in 3 ways:
mean(dm_2$price)
mean(dm_2[["price"]])
mean(dm_2[[7]])  # => US-$ 14843.66
```

### 3. Cells

Accessing the values of individual tibble cells is relatively rare, but can be achieved by 

    a. explicitly providing both row number `r` and column number `c` (as `[r, c]`), or by  
    b. first extracting the column (as a vector `v`) and then providing the desired row number `r` (`v[r]`). 

```{r tibble_cells}
fm  # family tibble (defined above): 

# Getting specific cell values:
fm$name[4]  # getting the name of the 4th row
fm[4, 2]    # getting the same name by row and column numbers

# Note: What if we don't know the row number? 
which(fm$name == "Yota") # getting the row number that contains the name "Yota"
```

In practice, accessing individual cell values is mostly needed to _check_ for specific cell values and to _change_ or _correct_ erroneous entries by re-assigning them to a different value.

```{r tibble_cells_check_change}
# Checking and changing cell values:

# Check: "Who is Xaxi's spouse?" in 3 different ways:
fm[fm$name == "Xaxi", ]$married_2
fm$married_2[3]
fm[3, 6]

# Change: "Zenon" is actually "Zeus" in 3 different ways:
fm[fm$name == "Xaxi", ]$married_2 <- "Zeus"
fm$married_2[3] <- "Zeus"
fm[3, 6] <- "Zeus"

# Check for successful change:
fm
```

By contrast, a relatively common task is to check an entire tibble for missing values, count them, or replace them by some other value: 

```{r tibble_missing_values}
# Checking for, counting, and changing missing values:

fm  # family tibble (defined above): 

# (a) Check for missing values:
is.na(fm)       # checks each cell value for being NA

# (b) Count the number of missing values: 
sum(is.na(fm))  # counts missing values (by adding up all TRUE values)

# (c) Change all missing values: 
fm[is.na(fm)] <- "A MISSING value!"

# Check for successful change: 
fm
```


**Practice:** Determine the number and the percentage of missing values in the datasets `dplyr::starwars` and `dplyr::storms`.

```{r missing_values_ex, echo = FALSE, eval = FALSE}
sum(is.na(dplyr::starwars))   # => 101 missing values
mean(is.na(dplyr::starwars))  # => 8.93%

sum(is.na(dplyr::storms))     # => 13056 missing values
mean(is.na(dplyr::storms))    # => 10.03% 
```

More advanced operations on tibbles are covered in [Chapter 5: Data transformation](http://r4ds.had.co.nz/transform.html) and involve using the `dplyr` commands `arrange`, `filter`, and `select`. 


## More on tibbles

For more details on tibbles, 

- study `vignette("tibble")` and the documentation for `?tibble`;
- study <https://tibble.tidyverse.org/> and its examples; 
- read [Chapter 10: Tibbles](http://r4ds.had.co.nz/tibbles.html) and complete its exercises. 


# Data transformation

## Overview

When we have data in the form of a tibble or data frame, `dplyr` provides a range of simple tools to transform this data. Six essential `dplyr` commands are: 

1. `arrange` sorts cases (rows); 
2. `filter` selects cases (rows) by logical conditions; 
3. `select` selects and reorders variables (columns); 
4. `mutate` computes new variables (columns) and adds them to existing ones; 
5. `summarise` collapses multiple values of a variable (rows of a column) to a single one;  
6. `group_by` changes the unit of aggregation (in combination with `mutate` and `summarise`).  

Not quite as essential but still useful `dplyr` commands include:

- `slice` selects (ranges of) cases (rows) by number; 
- `rename` renames variables (columns) and keeps others; 
- `transmute` computes new variables (columns) and drops existing ones;
- `sample_n` and `sample_frac` draw random samples of cases (rows).

## Commands and examples

We save the `dplyr::starwars` data as a tibble `sw` and use it to illustrate the essential `dplyr` commands.

```{r starwars_data}
library(tidyverse)
sw <- dplyr::starwars

sw  # => A tibble: 87 rows (individuals) x 13 columns (variables)
```

**Practice:** How many `sw` variables (columns) are there and of which _type_ are they? How many _missing_ (`NA`) values are there? 


### 1. `arrange` to sort rows

Using `arrange` sorts cases (rows) by putting specific variables (columns) in specific orders (e.g., ascending or descending):

```{r dplyr_arrange}
# Sort rows alphabetically (by name):
arrange(sw, name)

# The same command using the pipe:
sw %>%           # Note: %>% is NOT + (used in ggplot) 
  arrange(name) 

# Sort rows in descending order:
sw %>% 
  arrange(desc(name)) 

# Sort by multiple variables:
sw %>% 
  arrange(eye_color, gender, desc(height))

## Note: See 
# ?dplyr::arrange  # for more help and examples.
```

Note some details: 

- All basic `dplyr` commands can be called as `verb(data, ...)` or -- using the pipe from `magrittr` -- as `data %>% verb(...)` (see `vignette("magrittr")` for details).

- Variable names are unquoted.

- The order of variable names (`x, y, ...`) specifies the _order_ or _priority_ of operations (first by `x`, then by `y`, etc.).

**Practice:** Arrange the `sw` data in different ways, combining multiple variables and (ascending and descending) orders. Where are cases containing `NA` values in sorted variables placed?


### 2. `filter` to select rows

Using `filter` selects cases (rows) by logical conditions. It keeps all rows for which the conditions are `TRUE` and drops all rows for which the conditions are `FALSE` or `NA`.

```{r dplyr_filter}
# Filter to keep all humans:
filter(sw, species == "Human")

# The same command using the pipe:
sw %>%           # Note: %>% is NOT + (used in ggplot) 
  filter(species == "Human")

# Filter by multiple (additive) conditions: 
sw %>%
  filter(height > 180, mass <= 75)  # tall and light individuals

# The same command using the logical operator (&): 
sw %>%
  filter(height > 180 & mass <= 75)  # tall and light individuals

# Filter for a range of a specific variable:
sw %>%
  filter(height >= 150, height <= 165)  # (a) using height twice

sw %>%
  filter(between(height, 150, 165))     # (b) using between(...)

# Filter by multiple (alternative) conditions: 
sw %>%
  filter(homeworld == "Kashyyyk" | skin_color == "green")

# Filter cases with missing (NA) values on specific variables:
sw %>%
  filter(is.na(gender))

# Filter cases with existing (non-NA) values on specific variables:
sw %>%
  filter(!is.na(mass), !is.na(birth_year))

## Note: See 
# ?dplyr::filter  # for more help and examples.
```

Note some details:

- Separating multiple conditions by commas is the same as the logical AND (`&`). 

- Variable names are unquoted.

- The comma between conditions or tests (`x, y, ...`) means the same as `&` (logical AND), as each test results in a vector of Boolean values.

- Unlike in base R, rows for which the condition evaluates to `NA` are dropped. 

- Additional filter functions include `near()` for testing numerical (near-)identity. 


**Practice:** Use `filter` on `sw` to select very diverse or narrow subsets of individuals. 
For instance, 

- which individual with blond hair and blue eyes has an unknown mass? 
- of which species are individuals that are over 2m tall and have brown hair?
- which individuals from Tatooine are not male (but may be `NA`)? 
- which individuals are neither male nor female OR heavier than 130kg? 

```{r dplyr_filter_ex, echo = FALSE, eval = FALSE}
sw %>%
  filter(hair_color == "blond", eye_color == "blue")

sw %>%
  filter(height > 200, hair_color == "brown")

sw %>%
  filter(homeworld == "Tatooine", (gender != "male" | is.na(gender)))

sw %>%
  filter((gender != "male" & gender != "female") | mass > 130)
```


### 3. `select` to select columns 

Using `select` selects variables (columns) by their names or numbers: 

```{r dplyr_select}
# Select 4 specific variables (columns) of sw:
select(sw, name, species, birth_year, gender)

# The same when using the pipe:
sw %>%           # Note: %>% is NOT + (used in ggplot) 
  select(name, species, birth_year, gender)

# The same when providing a vector of variable names: 
sw %>%
  select(c(name, species, birth_year, gender)) 

# The same when providing column numbers:
sw %>%
  select(1, 10, 7, 8) 

# The same when providing a vector of column numbers: 
sw %>%
  select(c(1, 10, 7, 8)) 

# Select ranges of variables with ":":
sw %>%
  select(name:mass, films:starships)

# Select to re-order variables (columns) with everything():
sw %>%
  select(species, name, gender, everything())

# Select variables with helper functions:
sw %>%
  select(starts_with("s"))

sw %>%
  select(ends_with("s"))

sw %>%
  select(contains("_"))

sw %>%
  select(matches("or"))

# Renaming variables:
sw %>%
  rename(creature = name, from_planet = homeworld)

## Note: See 
# ?dplyr::select  # for more help and examples. 
?dplyr::select_if  # for more help and examples. 
```

Note some details:

- `select` works both by specifying variable (column) _names_ and by specifying column _numbers_.

- Variable names are unquoted. 

- The sequence of variable names (separated by commas) specifies the _order_ of columns in the resulting tibble.

- Selecting and adding `everything()` allows re-ordering. 

- Various helper functions (e.g., `starts_with`, `ends_with`, `contains`, `matches`, `num_range`) refer to (parts of) variable names. 

- `rename` renames specified variables (without quotes) and keeps all other variables.

**Practice:** Use `select` on `sw` to select and re-order specific subsets of variables (e.g., all variables starting with "h", all even columns, all character variables, etc.).


### 4. `mutate` to compute new variables

Using `mutate` computes new variables (columns) from scratch or existing ones: 

```{r dplyr_mutate}
# Preparation: Save only a subset variables of sw as sws:   
sws <- select(sw, name:mass, birth_year:species) 
sws    # => 87 cases (rows), but only 7 variables (columns)

# Compute 2 new variables and add them to existing ones:
mutate(sws, id = 1:nrow(sw), height_feet = .032808399 * height)

# The same using the pipe:
sws %>%
  mutate(id = 1:nrow(sw), height_feet = .032808399 * height)

# Transmute commputes and only keeps new variables:
sws %>%
  transmute(id = 1:nrow(sw), height_feet = .032808399 * height)

# Compute variables based on multiple others (including computed ones):
sws %>%
  mutate(BMI = mass / ((height / 100)  ^ 2),  # compute body mass index (kg/m^2)
         BMI_low  = BMI < 18.5,               # classify low BMI values
         BMI_high = BMI > 30,                 # classify high BMI values
         BMI_norm = !BMI_low & !BMI_high      # classify normal BMI values 
         )

## Note: See 
# ?dplyr::mutate  # for more help and examples. 
```

Note some details:

- `mutate` computes new variables (columns) and adds them to existing ones, while `transmute` drops existing ones.

- Each `mutate` command specifies a new variable name (without quotes), followed by `=` and a _rule_ for computing the new variable from existing ones. 

- Variable names are unquoted. 

- Multiple `mutate` steps are separated by commas, each of which creates a new variable. 

- See <http://r4ds.had.co.nz/transform.html#mutate-funs> for useful functions for creating new variables. 

**Practice:** Compute a new variable `mass_pound` from `mass` (in kg) and the age of each individual in `sw` relative to Yoda's age. (Note that the variable `birth_year` is provided in years BBY, i.e., Before Battle of Yavin.) 

```{r mutate_ex, echo = FALSE, eval = FALSE}
# sws

age_yoda <- sws %>%
  filter(name == "Yoda") %>%
  .$birth_year
age_yoda

sws %>% 
  mutate(mass_pound = mass/.45,
         age_since_yoda = age_yoda - birth_year) %>%
  select(name, mass, mass_pound, birth_year, age_since_yoda)
```


### 5. `summarise` to compute summaries

`summarise` computes a function for a specified variable and collapses the values of the specified variable (i.e., the rows of a specified columns) to a single value. It provides many different summary statistics by itself, but is even more useful in combination with `group_by` (discussed next). 

```{r dplyr_summarise}
# Summarise allows computing a function for a variable (column): 
summarise(sw, mn_mass = mean(mass, na.rm = TRUE))  # => 97.31 kg 

# The same using the pipe: 
sw %>%
  summarise(mn_mass = mean(mass, na.rm = TRUE))  # => 97.31 kg 

# Multiple summarise steps allow applying 
# different functions for 1 dependent variable: 
sw %>%
  summarise(n_mass = sum(!is.na(mass)), 
            mn_mass = mean(mass, na.rm = TRUE),
            md_mass = median(mass, na.rm = TRUE),
            sd_mass = sd(mass, na.rm = TRUE),
            max_mass = max(mass, na.rm = TRUE),
            big_mass = any(mass > 1000)
            )
            
# Multiple summarise steps also allow applying 
# different functions to different dependent variables: 
sw %>%
  summarise(# Descriptives of height:  
            n_height = sum(!is.na(height)), 
            mn_height = mean(height, na.rm = TRUE),
            sd_height = sd(height, na.rm = TRUE), 
            # Descriptives of mass:
            n_mass = sum(!is.na(mass)), 
            mn_mass = mean(mass, na.rm = TRUE),
            sd_mass = sd(mass, na.rm = TRUE),
            # Counts of character variables:
            n_names = n(), 
            n_species = n_distinct(species),
            n_worlds = n_distinct(homeworld)
            )

## Note: See 
# ?dplyr::summarise  # for more help and examples. 
```

Note some details:

- `summarise` collapses multiple values into one value and returns a new tibble with as many rows as values computed.

- Each `summarise` step specifies a new variable name (without quotes), followed by `=`, and a _function_ for computing the new variable from existing ones. 

- Multiple `summarise` steps are separated by commas. 

- Variable names are unquoted. 

- See <https://dplyr.tidyverse.org/reference/summarise.html> for examples and useful functions in combination with `summarise`. 


**Practice:** Apply _all_ summary functions mentioned in `?dplyr::summarise` to the `sw` dataset. 


### 6. `group_by` to aggregate variables

Using `group_by` does not change the data, but the _unit of aggregation_ for other commands, which is very useful in combination with `mutate` and `summarise`. 

```{r dplyr_group_by}
# Grouping does not change the data, but lists its groups: 
group_by(sws, species)  # => 38 groups of species

# The same using the pipe: 
sws %>%
  group_by(species)  # => 38 groups of species

# group_by is ineffective by itself, but very powerful 
# (a) in combination with `mutate` and 
# (b) in combination with `summarise`. 

# ad (a):
# In combination with mutate and an aggregation function, 
# group_by changes the unit of aggregation:

sws %>%
  mutate(mn_height_1 = mean(height, na.rm = TRUE)) %>%  # aggregates over ALL cases
  group_by(species) %>%
  mutate(mn_height_2 = mean(height, na.rm = TRUE)) %>%  # aggregates over current group (species)
  group_by(gender) %>%
  mutate(mn_height_3 = mean(height, na.rm = TRUE)) %>%  # aggregates over current group (gender)
  group_by(name) %>%
  mutate(mn_height_4 = mean(height, na.rm = TRUE))      # aggregates over current group (name)

# ad (b):
# group_by is particularly useful in combination 
# with summarise:

sws %>%
  group_by(homeworld) %>%
  summarise(count = n(),
            mn_height = mean(height, na.rm = TRUE),
            mn_mass = mean(mass, na.rm = TRUE)
            )

# Note that this pipe returns a new tibble, 
# with 49 rows (= different levels of homeworld) and 
# - 1 column of the group variable (homeworld) and 
# - 3 columns of the 3 newly summarised variables.


# group_by used with multiple variables yields a tibble 
# containing the combination of all variable levels: 
sw %>%
  group_by(hair_color, eye_color)  # => 35 groups (combinations)

# Counting the frequency of cases in groups:
sw %>%
  group_by(hair_color, eye_color) %>%
  count() %>%
  arrange(desc(n))  

# The same using summarise:
sw %>%
  group_by(hair_color, eye_color) %>%
  summarise(n = n()) %>%
  arrange(desc(n))  

## Note: See 
# ?dplyr::group_by  # for more help and examples. 
```

Note some details:

- `group_by` changes the unit of aggregation for other commands (`mutate` and `summarise`). 

- Variable names are unquoted.

- When using `group_by` with multiple variables, they are separated by commas. 

- Using `group_by` with `mutate` results in a tibble that has the same number of cases (rows) as the original tibble.  By contrast, using `group_by` with `summarise` results in a new tibble with all combinations of variable levels as its cases (rows). 


**Practice:** Create some groups and compute descriptive statistics (n, mean, median, standard deviation, ...) for some variables. For instance, 

- What is the number and mean height and mass of individuals from Tatooine by species and gender? 

- Which humans are more than 5cm taller then the average human overall?

- Which humans are more than 5cm taller than the average human of their own gender?

```{r group_by_ex, echo = FALSE, eval = FALSE}
sws %>%
  filter(homeworld == "Tatooine") %>%
  group_by(species, gender) %>%
  summarise(count = n(),
            mn_height = mean(height),
            mn_mass = mean(mass, na.rm = TRUE)
            )

sws %>% 
  filter(species == "Human") %>%
  mutate(mn_height = mean(height, na.rm = TRUE),
         taller = height > mn_height + 5) %>%
  filter(taller == TRUE)

sws %>% 
  filter(species == "Human") %>%
  group_by(gender) %>% 
  mutate(mn_height_2 = mean(height, na.rm = TRUE),
         taller_2 = height > mn_height_2 + 5) %>%
  filter(taller_2 == TRUE)
```

## Combining commands

The essential `dplyr` commands are quite simple by themselves, but form the basic verbs of a language for data manipulation. The commands become particularly powerful when they are combined into pipes (by using `%>%`). Stringing together several `dplyr` commands allows slicing and dicing data (tibbles or data frames) in a step-wise fashion to run non-trivial data analyses on the fly. 

**Practice: Tidyverse meets universe**

Answer the following questions about the `dplyr::starwars` dataset by using pipes of essential `dplyr` commands:  

**a.** Basics: 

- Save the tibble `dplyr::starwars` as `sw` and report its dimensions. 

**b.** Missing values and known unknowns:

- How many missing (`NA`) values does `sw` contain?

- Which individuals come from an unknown (missing) `homeworld` but have a known `birth_year` or known `mass`?

<!-- Which variable (column) has the most missing values? --> 

<!-- Replace all missing values of `hair_color` (in the variable `sw$hair_color`) by "bald" (2). -->


**c.** Gender issues:

- How many humans are contained in `sw` overall and by gender?

- How many and which individuals in `sw` are neither male nor female?

- Of which species in `sw` exist at least 2 different gender values?


**d.** Popular homes and heights:

- From which `homeworld` do the most indidividuals (rows) come from?

- What is the mean `height` of all individuals with orange eyes from the most popular homeworld?


**e.** Size and mass issues: 

- Compute the median, mean, and standard deviation of `height` for all droids.

- Compute the average height and mass by species and save the result as `h_m`.

- Sort `h_m` to list the 3 species with the smallest individuals (in terms of mean height).

- Sort `h_m` to list the 3 species with the heaviest individuals (in terms of median mass).


**f.** Counting and arranging: 

- How many individuals exist of the three most frequent (known) species?


**g.** Grouped mutates: 

- Which individuals are more than 20% lighter than the average mass of individuals of their own homeworld? 

```{r starwars_practice}
# library(tidyverse)
# ?dplyr::starwars

## (a) Basic data properties: ---- 
sw <- dplyr::starwars
dim(sw)  # => 87 rows (denoting individuals) x 13 columns (variables) 

## (b) Missing data: ----- 

## (+) How many missing data points?
sum(is.na(sw))  # => 101 missing values.

# (+) Which individuals come from an unknown (missing) homeworld 
#     but have a known birth_year or mass? 
sw %>% 
  filter(is.na(homeworld), !is.na(mass) | !is.na(birth_year))


## (x) Which variable (column) has the most missing values?
colSums(is.na(sw))  # => birth_year has 44 missing values
colMeans(is.na(sw)) #    (amounting to 50.1% of all cases). 

## (x) Replace all missing values of `hair_color` (in the variable `sw$hair_color`) by "bald": 
# sw$hair_color[is.na(sw$hair_color)] <- "bald"


## (c) Gender issues: ----- 

# (+) How many humans are there of each gender?
sw %>% 
  filter(species == "Human") %>%
  group_by(gender) %>%
  count()

## Answer: 35 Humans in total: 9 females, 26 male.

# (+) How many and which individuals are neither male nor female?
sw %>% 
  filter(gender != "male", gender != "female")

# (+) Of which species are there at least 2 different gender values?
sw %>%
  group_by(species, gender) %>%
  count() %>%  # table shows species by gender: 
  group_by(species) %>%  # Which species appear more than once in this table? 
  count() %>%
  filter(nn > 1)

## (d) Homeworld issues: ----- 

# (+) Popular homes: From which homeworld do the most indidividuals (rows) come from? 
sw %>%
  group_by(homeworld) %>%
  count() %>%
  arrange(desc(n))
# => Naboo (with 11 individuals)

# (+) What is the mean height of all individuals with orange eyes from the most popular homeworld? 
sw %>% 
  filter(homeworld == "Naboo", eye_color == "orange") %>%
  summarise(n = n(),
            mn_height = mean(height))

## Note: 
sw %>% filter(eye_color == "orange") # => 8 individuals


# (+) What is the mass and homeworld of the smallest droid?
sw %>% 
  filter(species == "Droid") %>%
  arrange(height)

## (e) Size and mass: Group summaries: ----- 

# (+) Compute the median, mean, and standard deviation of `height` for all droids.
sw %>%
  filter(species == "Droid") %>%
  summarise(n = n(),
            not_NA_h = sum(!is.na(height)),
            md_height = median(height, na.rm = TRUE),
            mn_height = mean(height, na.rm = TRUE),
            sd_height = sd(height, na.rm = TRUE))

# (+) Compute the average height and mass by species and save the result as `h_m`:
h_m <- sw %>%
  group_by(species) %>%
  summarise(n = n(),
            not_NA_h = sum(!is.na(height)),
            mn_height = mean(height, na.rm = TRUE),
            not_NA_m = sum(!is.na(mass)),
            md_mass = median(mass, na.rm = TRUE)
            )
h_m

# (+) Use `h_m` to list the 3 species with the smallest individuals (in terms of mean height)?
h_m %>% arrange(mn_height) %>% slice(1:3)

# (+) Use `h_m` to list the 3 species with the heaviest individuals (in terms of median mass)?
h_m %>% arrange(desc(md_mass)) %>%  slice(1:3)


## (+) Other questions: ----- 

# (f) How many individuals come from the 3 most frequent (known) species?
sw %>%
  group_by(species) %>%
  count %>%
  arrange(desc(n)) %>%
  filter(n > 1)

# (g) Which individuals are more than 20% lighter (in terms of mass) 
#     than the average mass of individuals of their own homeworld?
sw %>%
  select(name, homeworld, mass) %>%
  group_by(homeworld) %>%
  mutate(n_notNA_mass = sum(!is.na(mass)),  
         mn_mass = mean(mass, na.rm = TRUE),
         lighter = mass < (mn_mass - (.20 * mn_mass))
         ) %>%
  filter(lighter == TRUE)
```


## More on data transformation 

For more details on `dplyr`, 

- study `vignette("dplyr")` and the documentation for `?arrange`, `?filter`, `?select`, etc. 
- study <https://dplyr.tidyverse.org/> and its examples; 
- see the [cheat sheet on data transformation](https://www.rstudio.com/resources/cheatsheets/); 
- read [Chapter 5: Data transformation](http://r4ds.had.co.nz/transform.html) and complete its exercises. 


# Visualizing data

In the following, we introduce some essential commands of `ggplot2` in the context of examples. However, the `ggplot2` package extends far beyond this modest introduction -- it is an important pillar (and predecessor) of the `tidyverse` and implements a language for and philosophy of data visualisation. 

See [Chapter 3: Data visualization](http://r4ds.had.co.nz/data-visualisation.html)) and [Chapter 7: Exploratory data analysis (EDA)](http://r4ds.had.co.nz/exploratory-data-analysis.html) and the links provided below for more detailed information. 

## Commands and examples 

### General structure of `ggplot` calls

A generic template for creating a graph with `ggplot` is:

```{r ggplot_template, eval = FALSE}
# Generic ggplot template: 
ggplot(data = <DATA>) + 
  <GEOM_fun>(mapping = aes(<MAPPING>), <arg_1 = val_1, ..., arg_n = val_n>) +
  <FACET_fun> +    # optional
  <LOOK_GOOD_fun>  # optional 
  
# Minimal ggplot template:
ggplot(<DATA>) + 
  <GEOM_fun>(aes(<MAPPING>) 
```

The generic template includes the following parts: 

- `<DATA>` is a data frame or tibble that contains the data that is to be plotted.

- `<GEOM_fun>` is a function that maps data to a _geometric object_ ("geom") according to an aesthetic mapping that are specified in `aes(<MAPPING>)`. (A "mapping" specifies what goes where.) 

- A geom's visual appearance (e.g., colors, shapes, sizes, ...) can be customized 
     a. in the aesthetic mapping (when varying visual features according to data properties), or 
     b. by setting its arguments to specific values in `<arg_1 = val_1, ..., arg_n = val_n>` (when remaining constant).

- An optional `<FACET_fun>` splits a complex plot into multiple subplots. 

- A sequence of optional `<LOOK_GOOD_fun>` adjusts the visual features of plots (e.g., by adding themes, plot titles and labels, color scales, and coordinate systems).

Some examples that illustrate the use of these components are:

### A histogram

A _histogram_ counts how often specific values of one (typically continuous) variable occur in the data. This allows viewing the distribution of values for this variable: 

```{r ggplot_template_mpg_hist}
library(ggplot2)

# Data: ------ 
# Using mpg data:
# ?ggplot2::mpg

# (A) Histogram: ------

# A minimal histogram:
hi1 <- ggplot(mpg, aes(x = cty)) +  # set mappings for ALL geoms
  geom_histogram() 
hi1

# The same histogram:
hi1b <- ggplot(mpg) +
  geom_histogram(aes(x = cty))      # set mappings for THIS geoms
hi1b

# (B) Adding aesthetics, labels and themes: ------ 

# Enhanced version of the same plot: 
hi2 <- ggplot(mpg) +
  geom_histogram(aes(x = cty), binwidth = 1, fill = "forestgreen", color = "black") +
  labs(title = "Distribution of fuel economy in city environments", 
       x = "cty (miles per gallon)",
       caption = "Data from ggplot2::mpg") +
  theme_light()
hi2
```

### A scatterplot

A _scatterplot_ shows a data point (observation) as a function of 2 (typically continuous) variables `x` and `y`. This allows judging the relationship between `x` and `y` in the data: 

```{r ggplot_template_mpg_scat}

# (A) Scatterplot: ------ 

# A minimal scatterplot + reference line:
sp1 <- ggplot(mpg) +
  geom_point(aes(x = cty, y = hwy)) +
  geom_abline()
sp1

# Note a potential issue: Overplotting (multiple points on the same position).


# (B) Overplotting: ----- 

# One way of dealing with overplotting is 
# adding randomness to point positions:  
sp2 <- ggplot(mpg) +
  geom_point(aes(x = cty, y = hwy), position = "jitter") +
  geom_abline()
sp2

# Another way of dealing with overplotting is 
# using transparency (via setting alpha to < 1): 
sp3 <- ggplot(mpg) +
  geom_point(aes(x = cty, y = hwy), position = "identity", 
             pch = 21, fill = "steelblue", alpha = 1/4, size = 4) +
  geom_abline(linetype = 2, color = "firebrick") # + 
  # geom_rug(aes(x = cty, y = hwy), position = "jitter", alpha = 1/4, size = 1)
sp3

# Adding labels and themes to plots: 
sp4 <- sp3 +   # use the plot defined above
  labs(title = "Fuel economy on highway vs. city",
                x = "City (miles per gallon)",
                y = "Highway (miles per gallon)",
                caption = "Data from ggplot2::mpg") +
  # coord_fixed() +
  theme_bw()
sp4


# (C) Grouping (by a categorical variable): ------  

# Grouping by color:
sp5 <- ggplot(mpg) +
  geom_point(aes(x = cty, y = hwy, color = class), 
             position = "jitter", alpha = 1/2, size = 4) +
  geom_abline(linetype = 2) +
  theme_bw()
sp5

# Grouping by facets: 
sp6 <- ggplot(mpg) +
  geom_point(aes(x = cty, y = hwy), 
             position = "jitter", alpha = 1/2, size = 2) +
  geom_abline(linetype = 2) +
  facet_wrap(~class) +
  theme_bw()
sp6
```


```{r ggplot_template_ex_mw, echo = FALSE, eval = FALSE}
# UNUSED examples:

# midwest data:
?ggplot2::midwest
mw <- ggplot2::midwest
# mw

# Check some variable types: 
unique(mw$state)
unique(mw$inmetro)
unique(mw$category)

ggplot(mw) +
  geom_histogram(aes(x = poptotal), binwidth = 10000)

ggplot(mw) +
  geom_histogram(aes(x = popdensity), binwidth = 500) +
  facet_wrap(~inmetro) +
  theme_bw()

ggplot(mw) +
  geom_histogram(aes(x = popdensity), binwidth = 1000) +
  facet_wrap(~state) +
  theme_bw()
```

See <https://ggplot2.tidyverse.org/reference/> for more examples. 

Note some details:

- `ggplot` requires data and maps independent variables to dimensions (e.g., the x- and y-axis) and dependent variables to geometric objects (called "geoms"). It typically assumes that the to-be-plotted `<DATA>` is in a table (data frame or tibble) in long format and contains independent variables as factors. 

- The arguments `data =` and `mappings =` can be omitted, but an aesthetic mapping `aes(<MAPPING>)` for at least one geom is needed. 

- Different geoms can be combined, but their order matters (as later layers are printed on top of earlier ones).

- When multiple geoms use the same mappings, their common `aes(<MAPPING>)` can be moved into the initial `ggplot` call (behind `<DATA>`).

- In `ggplot`, a sequence of commands is combined by `+`, rather than `%>%`. 

- The visual appearance of plots are highly customizable (e.g., by supplying aesthetic arguments, speciying labels and legends, and applying pre-defined themes to plots). 


## EDA 

The key to creating a good graph involves 2 steps: 

1. Knowing the number and type of variables to be plotted. 

2. Knowing the intended type of graph (i.e., knowing the available ones and identifying the suitable ones).

Even when 1. and 2. is given, creating good graphs with `ggplot` requires a lot of practice and many hours of trial-and-error experimentation. 


+++ here now +++


### Scatterplots

Trendlines

### Lines and curves

### Bar plots

### Other plots and packages

`ggplot2` comes with a large variety of geoms. Nevertheless, we sometimes want to show or do something that is not included in the standard package. [Chapter 7: Exploratory data analysis](http://r4ds.had.co.nz/exploratory-data-analysis.html) goes beyond standard `ggplot` geoms by touching on `geom_hex` (from the `hexbin` package) and `geom_beeswarm` and `geom_quasirandom` (from the `ggbeeswarm` package). When looking for new forms of visual expression, web sites like 

- [Data Visualization Catalogue](https://datavizcatalogue.com)
- [Google charts](https://developers.google.com/chart/)
- [R-graph gallery](http://www.r-graph-gallery.com)

can inspire and provide many interesting pointers. The site 

- [ggplot2-exts.org](https://www.ggplot2-exts.org/) 

also provides valuable resources for `ggplot` users, as it shows packages specifically designed to work with `ggplot2`. In the following, we illustrate the package `ggalluvial` that allows showing the transitions between categorical data. 

#### Example 1: Alluvial plot

```{r alluvial_plots_1, fig.width = 6, fig.height = 8}
# Preparations: 
library(tidyverse)
# install.packages("ggalluvial")
library(ggalluvial)

# Example 1 (adapted from vignette): ----- 

as_tibble(as.data.frame(UCBAdmissions))
is_alluvial(as.data.frame(UCBAdmissions), logical = FALSE, silent = TRUE)

ggplot(as.data.frame(UCBAdmissions),
       aes(weight = Freq, axis1 = Gender, axis2 = Dept)) +
  geom_alluvium(aes(fill = Admit), width = 1/12) +
  geom_stratum(width = 1/12, 
               fill = c("firebrick", "steelblue4", "grey10", "grey80", "grey30", "grey50", "grey70", "grey20"), 
               color = "grey10") +
  geom_label(stat = "stratum", label.strata = TRUE) +
  scale_x_continuous(breaks = 1:2, labels = c("Gender", "Department")) +
  # scale_fill_brewer(type = "qual", palette = "Set2") +
  scale_fill_manual(values = c("forestgreen", "gold2")) + 
  ggtitle("UC Berkeley admissions and rejections") +
  theme_light()
```

An important feature of these diagrams is the meaningfulness of the vertical axis: No gaps are inserted between the strata, so the total height of the diagram reflects the cumulative weight of the observations.^[This is different in _Sankey diagrams_, shown <https://developers.google.com/chart/interactive/docs/gallery/sankey>.]


#### Example 2: Parallel set diagram 

```{r alluvial_plots_2, fig.width = 7, fig.height = 7}
# Preparations: 
library(ggalluvial)

# Example 2 (adapted from vignette): ----- 

# as.data.frame(Titanic)

ggplot(as.data.frame(Titanic),
       aes(weight = Freq,
           axis1 = Survived, axis2 = Sex, axis3 = Class)) +
  geom_alluvium(aes(fill = Class),
                width = 0, knot.pos = 0, reverse = FALSE) +
  guides(fill = FALSE) +
  geom_stratum(width = 1/8, reverse = FALSE) +
  geom_text(stat = "stratum", label.strata = TRUE, reverse = FALSE) +
  scale_x_continuous(breaks = 1:3, labels = c("Survived", "Gender", "Class")) +
  coord_flip() +
  ggtitle("Titanic survival by class and gender") +
  scale_fill_brewer(type = "qual", palette = "Dark2") +
  theme_bw()

# Switching order of axes (to put Survived in middle):

ggplot(as.data.frame(Titanic),
       aes(weight = Freq,
           axis1 = Sex, axis2 = Survived, axis3 = Class)) +
  geom_alluvium(aes(fill = Class),
                width = 0, knot.pos = 0, reverse = FALSE) +
  guides(fill = FALSE) +
  geom_stratum(width = 1/8, reverse = FALSE) +
  geom_text(stat = "stratum", label.strata = TRUE, reverse = FALSE) +
  scale_x_continuous(breaks = 1:3, labels = c("Gender", "Survived", "Class")) +
  coord_flip() +
  ggtitle("Titanic survival by class and gender (2)") +
  scale_fill_brewer(type = "qual", palette = "Set1") +
  theme_bw()

# Fill by gender:

ggplot(as.data.frame(Titanic),
       aes(weight = Freq,
           axis1 = Class, axis2 = Survived, axis3 = Sex)) +
  geom_alluvium(aes(fill = Sex),
                width = 0, knot.pos = 0, reverse = FALSE) +
  guides(fill = FALSE) +
  geom_stratum(width = 1/8, reverse = FALSE) +
  geom_text(stat = "stratum", label.strata = TRUE, reverse = FALSE) +
  scale_x_continuous(breaks = 1:3, labels = c("Class", "Survived", "Gender")) +
  coord_flip() +
  ggtitle("Titanic survival by class and gender (3)") +
  # scale_fill_brewer(type = "qual", palette = "Paired") +
  scale_fill_manual(values = c("steelblue", "firebrick")) + 
  theme_bw()
```

#### Example 3: Data in long format

```{r alluvial_plots_3, fig.width = 8, fig.height = 5}
# Preparations: 
library(ggalluvial)

# Example 3 (adapted from vignette): ----- 

?majors
data(majors)
as_tibble(majors) # illustrating lode format 
majors$curriculum <- as.factor(majors$curriculum)

ggplot(majors,
       aes(x = semester, stratum = curriculum, alluvium = student,
           fill = curriculum, label = curriculum)) +
  scale_fill_brewer(type = "qual", palette = "Pastel2") +
  geom_flow(stat = "alluvium", 
            lode.guidance = "rightleft",
            color = "darkgray") +
  geom_stratum() +
  theme(legend.position = "right") + # "bottom" "top"
  ggtitle("Student curricula across several semesters") +
  theme_light()
```

See the packages `circlize`, `ggforce`, and `ggparallel` for other types of transition plots. 


## More on data visualization

- study `vignette("ggplot")` and the documentation for `ggplot` and various geoms (e.g., `geom_`);
- study <https://ggplot2.tidyverse.org/reference/> and its examples; 
- see the [cheat sheet on data visualization](https://www.rstudio.com/resources/cheatsheets/); 
- read [Chapter 3: Data visualization](http://r4ds.had.co.nz/data-visualisation.html) and [Chapter 7: Exploratory data analysis (EDA)](http://r4ds.had.co.nz/exploratory-data-analysis.html) and complete their exercises. 

# Conclusion

<!-- Table with links: -->

All [ds4psy](http://rpository.com/ds4psy/) essentials: 

Nr. | Topic       |
---:|:------------| 
1.  | [Creating and using tibbles](http://rpository.com/ds4psy/R/_essentials/tibble.html) |
2.  | [Data transformation](http://rpository.com/ds4psy/R/_essentials/transform.html) |
3.  | [Visualizing data](http://rpository.com/ds4psy/R/_essentials/visualize.html) |

[Last update on `r Sys.time()` by [hn](http://neth.de/).]  

<!-- eof. --> 